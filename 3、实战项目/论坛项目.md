# 1、创建 SpringBoot 项目

## （1）快捷创建项目

​	这里我使用的是IDEA 付费版本【IntelliJ IDEA 2023.1.2 (Ultimate Edition)】，学习该花的钱不要省（嘿嘿，当然某宝也有物美价廉的方案），已经安装好了齐全的 Spring 插件（File -> Settings -> Plugins），这里创建项目用到了 Spring Initializr。

<img src="screenshots\1-IDEA-SpringPlugins.png" style="zoom:80%;"/>

​	File -> New -> New Project，选择 Spring Initializr 来初始化项目，注意一些关键信息要填好。

<img src="screenshots\2-Init-SpringBoot.png" style="zoom:80%;"/>

​	进入下一步，选择 Spring Boot 版本，添加项目用到的 SpringBoot Starter，先选 web，后面用到其他的可以手动添加。

<img src="screenshots\3-Add-SpringBootStarter.png" style="zoom:80%;"/>





## （2）工程目录文件简介

<img src="screenshots\4-ProjectDetails.png" style="zoom:80%;"/>

* **pom.xml**

  ​	Maven 项目依赖管理文件，默认生成的 pom.xml 会以 spring-boot-starter-parent 为父工程，将使用的版本修改为 2.1.4.RELEASE（跟教学视频保持一致），这样下面引用各种 SpringBoot Starter 时就不需要显式指定依赖版本，因为父工程已经指定好了版本，如下所示：

<img src="screenshots\5-SpringBootPom.png" style="zoom:80%;"/>

​	可以看到创建工程时勾选的 web starter，除此之外，还自动引入了 test starter，用于编写对 Spring Boot 的测试代码；在构建插件中，还自动引入了 spring-boot-maven-plugin，用于对工程进行构建打包。

* **.gitignore**

  ​	定义工程中忽略的文件和目录，这些文件和目录在提交代码入库时不会会被忽略，比如 IDE 自动生成的文件和目录，生成编译代码的文件和目录等。

* **HELP.md**

  ​	在 github 上进入一个项目时会有一个简介，github 会自动加载仓库根目录的 README.md 文档并渲染到网页上，这里先把 HELP.md 重命名为 README.md，然后在文档中添加对项目的介绍，包括功能、安装和使用步骤等。

* **src/main/java**

  ​	存放 java 代码的目录，这里已经按照初始化时指定的配置生成了一个代码包 `life.majiang.community`，并且自动创建了工程主类 `CommunityApplication.java`，启动它即可将工程跑起来。

  ​	一般情况下，我们会在 `life.majiang.community` 下创建新的包，比如 `life.majiang.community.controller`、`life.majiang.community.service` 等，因为工程启动时默认会扫描主类包及其子包中所有使用了 Spring 注解定义的 Bean（常用的注解有 `@Controller`、`@Component`、`@Service`等），当然也可以不这样做，比如定义一个新的包 `life.majiang.controller` ，这样要对包扫描时，需要在主类中显式指定要扫描的包。

* **src/main/resources**

  ​	存放工程的资源文件，默认有 static、templates 两个子目录，还有一个 application.properties 文件。

  ​	static 用来存放网站需要的静态文件，比如图片、css样式文件、javascript脚本文件等，一般会在 static 下再建不同的子目录区分，比如 static/images、static/css、static/js。

  ​	templates 用来存放网站需要的模板文件，当然流行的前后端分离一般已经不再使用模板，这里我们使用的引擎是 thymeleaf，后面还要引入相关的依赖。

  ​	application.properties 文件用来配置 Spring Boot 支持的各种参数，比如 web 服务对外暴露端口的参数为 `server.port`，默认值为 8080，如果要修改为 8081，在配置文件中编写如下一行键值对配置即可：

```properties
server.port=8081
```

* **src/main/test**

  ​	存放工程的测试代码，在严格执行单元测试的开发管理中，一个类要有一个对应的 Test 测试类，测试类所处包跟类相同。





## （3）运行工程

​	启动主类，可以看到日志中显示 SpringBoot 工程中嵌入了 Tomcat 服务器，默认启动的端口是 8080。

<img src="screenshots\6-SpringBootStart.png" style="zoom:100%;"/>

​	访问下 http://localhost:8080，可以看到显示的是默认的报错白页，因为此时我们还没编写任何的处理响应的控制器，Spring 找不到处理响应的程序，就只能返回一个 404 的报错。

<img src="screenshots\7-SpringBootStart.png" style="zoom:100%;"/>





# 2、集成 thymeleaf 

​	在 https://spring.io/guides 中找到快捷接入指引：https://spring.io/guides/gs/serving-web-content/

​	首先要引入 thymeleaf 模板引擎对应的 starter，在工程 pom.xml 中添加：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```

​	在启动类所在包下创建一个子包 `life.majiang.community.controller`，并创建一个 HelloController，负责响应 Web 请求，代码如下：

```java
package life.majiang.community.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
public class HelloController {

    @GetMapping("/hello")
    public String hello(@RequestParam(name = "name") String name, Model model) {
        model.addAttribute("name", name);
        return "hello";
    }

}
```

​	首先控制器要使用 `@Controller` 注解，在控制器中创建一个 `hello` 方法，使用 `@GetMapping("/hello")` 表示该方法会响应对 "/hello" 的 GET 请求。

​	请求可能通过 URL 传递参数进来，比如 "/hello?name=hyh"，为了获取参数，在方法头添加 `@RequestParam(name = "name") String name`，表示会从 URL 中获取参数名为 name 的参数并传递给方法入参。

​	我们可能还需要将后端处理好的数据传递给前端，所以给方法添加一个 Model 参数，往 model 对象中添加属性，这些属性能随着响应传递到前端页面模板。

​	最后返回一个 `"hello"` 字符串，因为我们使用了 thymeleaf 模板引擎，所以会自动从资源模板目录 `src/main/resources/templete` 中找到 hello.html，IDEA 会自动提示找不到这个 MVC 视图

<img src="screenshots\9-mvc-view.png" style="zoom:100%;"/>

​	所以接下来到模板目录中创建 hello.html，代码如下：

```html
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Getting Started: Serving Web Content</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>
<body>
    <p th:text="'Hello, ' + ${name} + '!'" />
</body>
</html>
```

​	首先要引入模板引擎的 namespace，告诉 Spring 页面中的 `th` 要使用 Thymeleaf 引擎解析处理，`th:text="'Hello, ' + ${name} + '!'"` 表示要拼接一个字符串渲染到 `<p> ` 标签中，拼接的字符串中 `${name}` 来自后端控制器方法中通过 model 传递给模板处理的属性。

​	访问 `http://localhost:8080/hello?name=hyh` ，响应还是白页

<img src="screenshots\11-没开启自动导入导致的报错.png" style="zoom:100%;"/>

​	看看服务端有什么报错

<img src="screenshots\12-视图解析异常.png" style="zoom:100%;"/>

 	可以看到解析 `hello` 的视图失败，看一下是不是新增的依赖没有自动导入的问题

<img src="screenshots\13-未自动导入maven包.png" style="zoom:80%;"/>

​	可以看到没有我们新引入的 thymeleaf 的依赖，点击左上角的 "Reload All Maven Projects"，才看到依赖真正导入了

<img src="screenshots\14-thmeleaf.png" style="zoom:70%;"/>

​	重启应用再访问，可以看到正常的响应了。

<img src="screenshots\10-hello.png" style="zoom:100%;"/>

​	为了避免在引入新依赖时再次遇到该问题，需要设置 maven 的 auto import，步骤如下

<img src="screenshots\15-maven-autoimport.png" style="zoom:60%;"/>

<img src="screenshots\16-maven-autoimport.png" style="zoom:60%;"/>





# 3、引入 Bootstrap

【Bootstrap】https://v3.bootcss.com/

【样式】https://v3.bootcss.com/css/

【组件】https://v3.bootcss.com/components/

​	下载压缩包

<img src="screenshots\17-bootstrap.png" style="zoom:60%;"/>

​	将压缩包内的 css、fonts、js 目录拷贝到工程的静态资源目录下

<img src="screenshots\18-bootstrap.png" style="zoom:60%;"/>

​	因为这里引用的 Bootstrap V3 是依赖 JQuery 的，所以在 js 目录下还要有 jquery.js，并且在 html 中引入 js 的顺序要先于 bootstrap.js

<img src="screenshots\19-bootstrap.png" style="zoom:100%;"/>





# 4、创建导航栏

​	我们使用 Bootstrap 自带的组件实现一个网站导航栏，从组件库中将默认的导航条样式引入，再在其基础上修改，调整为想要的功能和菜单。

<img src="screenshots\20-bootstrap.png" style="zoom:100%;"/>

​	调整后的新增 index.html 如下：

```html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>鸭鸭社区</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>
    <nav class="navbar navbar-default">
        <div class="container-fluid">

            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                    <span class="sr-only">鸭鸭社区</span>
                </button>
                <a class="navbar-brand" href="/">鸭鸭社区</a>
            </div>

            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <form class="navbar-form navbar-left">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="搜索问题">
                    </div>
                    <button type="submit" class="btn btn-default">搜索</button>
                </form>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="#">登录</a></li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">我 <span class="caret"></span></a>
                        <ul class="dropdown-menu">
                            <li><a href="#">消息中心</a></li>
                            <li><a href="#">个鸭资料</a></li>
                            <li><a href="#">退出登录</a></li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </nav>
</body>
</html>
```

​	新增控制器 IndexController，增加对 `/` 请求的处理，并最后渲染视图 index。

```java
package life.majiang.community.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class IndexController {
    @GetMapping("/")
    public String index() {
        return "index";
    }
}
```

​	完成开发后启动应用，网页访问 `http://localhost:8080/` ，效果如下所示：

<img src="screenshots\21-bootstrap.png" style="zoom:100%;"/>





# 5、Github OAuth 登录开发

​	先找文档在哪里，一般有提供 API 的网站，都能在网站上找到对应的入口

<img src="screenshots\22-github.png" style="zoom:100%;"/>

​	进入可以看到开发者选项，REST API

<img src="screenshots\23-github.png" style="zoom:100%;"/>

<img src="screenshots\24-github.png" style="zoom:60%;"/>

## （1）创建 OAuth 应用

​	登录上 Github，在页面的右上方，单击个人资料照片，然后点击 "Settings"

<img src="screenshots\26-github.png" style="zoom:60%;"/>

​	在左边栏中，点击 Developer settings

<img src="screenshots\27-github.png" style="zoom:100%;"/>

​	点击右侧边栏的 OAuth Apps

<img src="screenshots\28-github.png" style="zoom:60%;"/>

​	点击 "New OAuth App"，填写应用信息：

1、在“Application name（应用程序名称）”中，输入应用程序的名称；

2、在“Homepage URL（主页 URL）”中，输入应用程序网站的完整 URL；

3、（可选）在“Application description（应用程序说明）”中，输入用户将看到的应用程序说明；

4、在“Authorization callback URL（授权回调 URL）”中，输入应用程序的回调 URL。

​	然后点击 "Register application"

<img src="screenshots\29-github.png" style="zoom:100%;"/>

​	创建应用的时候，会自动生成一个客户端ID，这个是不变的，还需要自行点击生成一个客户端密钥，这个是可以重新生成的

<img src="screenshots\30-github.png" style="zoom:100%;"/>

​	点击 "Update application"，至此完成应用创建

<img src="screenshots\31-github.png" style="zoom:65%;"/>





## （2）OAuth 处理流程

> **① 通过 GET 请求调用授权接口，获得动态生成的授权码，接口和报文如下**

```shell
GET https://github.com/login/oauth/authorize
```

| 参数名称         | 类型     | 说明                                       |
| ------------ | ------ | ---------------------------------------- |
| client_id    | string | “必需”。 [注册](https://github.com/settings/applications/new)时从 GitHub 收到的客户端 ID。 |
| redirect_uri | string | 用户获得授权后被发送到的应用程序中的 URL。 请参阅以下有关[重定向 URL](https://docs.github.com/zh/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps#redirect-urls) 的详细信息。 |
| login        | string | 提供用于登录和授权应用程序的特定账户。                      |
| scope        | string | [范围](https://docs.github.com/zh/apps/oauth-apps/building-oauth-apps/scopes-for-oauth-apps)的空格分隔列表。 如果未提供，则 `scope` 默认为未授权应用程序的任何范围的用户的空列表。 对于已向应用程序授权作用域的用户，不会显示含作用域列表的 OAuth 授权页面。 相反，通过用户向应用程序授权的作用域集，此流程步骤将自动完成。 例如，如果用户已经执行了两次 Web 流，并且已授权一个具有 `user` 范围的令牌和另一个具有 `repo` 范围的令牌，则不提供 `scope` 的第三个 Web 流将收到具有 `user` 和 `repo` 范围的令牌。 |
| state        | string | 不可猜测的随机字符串。 它用于防止跨站请求伪造攻击。               |
| allow_signup | string | 在 OAuth 流程中，是否向经过验证的用户提供注册 GitHub 的选项。 默认为 `true`。 在策略禁止注册时使用 `false`。 |



> **② 拿到动态生成的授权码后，`code` 作为访问令牌，跟生成的客户端ID和密钥一并上送获得 access_token 的接口**

```shell
POST https://github.com/login/oauth/access_token
```

| 参数名称          | 类型     | 说明                                      |
| ------------- | ------ | --------------------------------------- |
| client_id     | string | **必填。** 从 GitHub 收到的 OAuth app 的客户端 ID。 |
| client_secret | string | **必填。** 从 GitHub 收到的 OAuth app 的客户端密码。  |
| code          | string | **必填。** 收到的作为对步骤 1 的响应的代码。              |
| redirect_uri  | string | 用户获得授权后被发送到的应用程序中的 URL。                 |

得到的响应报文形式如下：

```
access_token=gho_16C7e42F292c6912E7710c838347Ae178B4a&scope=repo%2Cgist&token_type=bearer
```

如果在 `Accept` 标头中提供格式，则还可以接收不同格式的响应。 例如 `Accept: application/json` 或 `Accept: application/xml`：

```
Accept: application/json
{
  "access_token":"gho_16C7e42F292c6912E7710c838347Ae178B4a",
  "scope":"repo,gist",
  "token_type":"bearer"
}
```

```
Accept: application/xml
<OAuth>
  <token_type>bearer</token_type>
  <scope>repo,gist</scope>
  <access_token>gho_16C7e42F292c6912E7710c838347Ae178B4a</access_token>
</OAuth>
```



> **③ 使用访问令牌访问 API**

访问令牌可用于代表用户向 API 提出请求。

```
Authorization: Bearer OAUTH-TOKEN
GET https://api.github.com/user
```

例如，您可以像以下这样在 curl 中设置“授权”标头：

```
curl -H "Authorization: Bearer OAUTH-TOKEN" https://api.github.com/user
```

可以在 github 设置生成测试的 token

<img src="screenshots\32-github-testtoken.png" style="zoom:80%;"/>

作用域勾选用户

<img src="screenshots\33-scope.png" style="zoom:80%;"/>

生成 Personal access token 后，可以通过 Postman 对其进行测试<img src="screenshots\34-githubuser.png" style="zoom:80%;"/>





## （3）实战

​	首先要获得授权码，在首页登录按钮配置调整获得授权码的 URL，如下所示：

```html
...
<ul class="nav navbar-nav navbar-right">
   <li><a href="https://github.com/login/oauth/authorize?client_id=ce46b85af14a2d21447b&redirect_uri=http://localhost:8080/callback&scope=user&state=2">登录</a></li>
    
...
```

​	启动应用，访问首页点击登录，看下效果：

<img src="screenshots\32-gitoauth.png" style="zoom:65%;"/>

​	会从当前页面自动跳转到 github 的授权登录页，点击授权，会回调到设定的回调地址，并且回调的同时，返回授权码 code 和跨域用到的 state 字段。

<img src="screenshots\33-gitoauth.png" style="zoom:65%;"/>

​	但是由于暂时没开发响应授权回调的控制器程序，所以会报白页错误。

​	接下来要编写响应回调的程序，首先要编写专门负责向 Github OAuth 接口发起请求的程序，为方便发送和接收数据，先定义两个 DTO 类。

```java
package life.majiang.community.provider.dto;

import lombok.Data;

@Data
public class AccessTokenDTO {
    private String client_id;
    private String client_secret;
    private String code;
    private String redirect_uri;
    private String state;
}

package life.majiang.community.provider.dto;

import lombok.Data;

@Data
public class GithubUser {
    private Long id;
    private String name;
    private String bio;
    private String avatar_url;
}
```

​	`AccessTokenDTO` 类在请求 OAuth 接口获得 accessToken 时用到；`GithubUser` 类对应获取授权 Github 用户数据时用到。

​	发起 HTTP 请求用的是 OK HTTP，同时用到了 fastjson 来处理对象和 JSON 字符串的转换，lombok 方便类编写，先引入依赖：

```xml
<dependency>
	<groupId>com.squareup.okhttp3</groupId>
	<artifactId>okhttp</artifactId>
	<version>3.14.1</version>
</dependency>
<dependency>
	<groupId>com.alibaba</groupId>
	<artifactId>fastjson</artifactId>
	<version>1.2.57</version>
</dependency>
<dependency>
	<groupId>org.projectlombok</groupId>
	<artifactId>lombok</artifactId>
	<scope>provided</scope>
</dependency>
```

​	负责请求的组件类 GithubProvider 定义如下：

```java
package life.majiang.community.provider;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.PropertyNamingStrategy;
import com.alibaba.fastjson.parser.ParserConfig;
import life.majiang.community.provider.dto.AccessTokenDTO;
import life.majiang.community.provider.dto.GithubUser;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;
import org.springframework.stereotype.Component;
import java.io.IOException;

@Component
@Slf4j
public class GithubProvider {

    // 获取accessToken
    public String getAccessToken(AccessTokenDTO accessTokenDTO) {
        MediaType mediumType = MediaType.get("application/json; charset=utf-8");

        OkHttpClient client = new OkHttpClient();
        RequestBody body = RequestBody.create(mediumType, JSON.toJSONString(accessTokenDTO));
        Request request = new Request.Builder()
                .url("https://github.com/login/oauth/access_token")
                .post(body)
                .build();
        try (Response response = client.newCall(request).execute()) {
            String string = response.body().string();
            log.info("Get access token response: " + string);
            String token = string.split("&")[0].split("=")[1];
            return token;
        } catch (IOException e) {
            log.error("Get access token exception: {}", e);
        }
        return null;
    }

    // 获取用户信息
    public GithubUser getGithubUser(String accessToken) {
        OkHttpClient client = new OkHttpClient();
        Request request = new Request.Builder()
                                     .url("https://api.github.com/user")
                                     .addHeader("Authorization", "Bearer " + accessToken)
                                     .build();
        try (Response response = client.newCall(request).execute()) {
            String string = response.body().string();
            log.info("Get github user response: " + string);
            ParserConfig.getGlobalInstance().propertyNamingStrategy = PropertyNamingStrategy.SnakeCase;
            GithubUser githubUser = JSON.parseObject(string, GithubUser.class);
            return githubUser;
        } catch (IOException e) {
            log.error("Get github user exception: {}", e);
        }
        return null;
    }

}
```

​	创建授权控制器 `AuthorizeController` ，接收 Github 的回调后，先获得 accessToken，再用 accessToken 去获取用户信息。

​	在控制器中，要用到 OAuth App 的客户端ID和密钥，已经回调地址，将其放在配置文件 application.properties 中避免硬编码。

```properties
...
# Github OAuth
github.client.id=xxxxxxxxxxxxxx
github.client.secret=xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
github.redirect.uri=http://localhost:8080/callback
...
```

```java
package life.majiang.community.controller;

import life.majiang.community.provider.GithubProvider;
import life.majiang.community.provider.dto.AccessTokenDTO;
import life.majiang.community.provider.dto.GithubUser;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
@Slf4j
public class AuthorizeController {

    @Value("${github.client.id}")
    private String clientId;

    @Value("${github.client.secret}")
    private String clientSecret;

    @Value("${github.redirect.uri}")
    private String redirectUrl;

    @Autowired
    private GithubProvider githubProvider;

    @GetMapping("/callback")
    public String callback(@RequestParam(name = "code") String code,
                           @RequestParam(name = "state") String state) {
        AccessTokenDTO accessTokenDTO = new AccessTokenDTO();
        accessTokenDTO.setClientId(clientId);
        accessTokenDTO.setClientSecret(clientSecret);
        accessTokenDTO.setCode(code);
        accessTokenDTO.setState(state);
        accessTokenDTO.setRedirectUri(redirectUrl);
        log.info("AccessTokenDTO = " + accessTokenDTO);

        String accessToken = githubProvider.getAccessToken(accessTokenDTO);
        GithubUser githubUser = null;
        if (accessToken != null) {
            githubUser = githubProvider.getGithubUser(accessToken);
        }

        if (githubUser != null && githubUser.getId() != null) {
            log.info("Github OAuth succ");
            return "redirect:/";
        } else {
            // 登录失败，重新登录
            return "redirect:/";
        }
    }

}
```

​	启动应用，在首页上点击登录页面，可以看到打印出来的日志，登录成功了，获取到了用户信息。

<img src="screenshots\34-gitoauth.png" style="zoom:100%;"/>

 



# 6、登录会话

​	先说说 cookie 和 session，cookie 是浏览器端会保存的一小块数据缓存，每次用户从浏览器发起新的请求时，会将 cookie 中的数据全部一并发送到服务端，在服务端，通过 `HttpServletRequest` 对象获取请求头部可以拿到 cookie 信息。

​	session 是会话的意思，用户每次登录后，在网站内浏览任意一个页面都应该能够保持登录状态。所以用户每次登录后，要生成一个用户的会话信息ID，并且在登录成功后响应时将其设置到浏览器的 cookie 中，这样后续每次用户访问，服务端都能根据ID拿到用户的会话信息，进而可以判断是哪个用户及其相关登录信息。

​	所以在 Github OAuth 登录成功后，应该设置用户 session，修改授权控制器代码：

```java
    @GetMapping("/callback")
    public String callback(@RequestParam(name = "code") String code,
                           @RequestParam(name = "state") String state,
                           HttpServletRequest request) {
...
        if (githubUser != null && githubUser.getId() != null) {
            log.info("Github OAuth succ");
            // 设置用户登录会话
            request.getSession().setAttribute("user", githubUser);
            return "redirect:/";
        } else {
            // 登录失败，重新登录
            return "redirect:/";
        }
...
    }
```

​	同时页面模板要配合修改，当用户已经登录时，就不应该显示【登录】按钮，同时要显示拿到的 Github 用户名。

```html
<li th:if="${session.user == null}"><a href="https://github.com/login/oauth/authorize?client_id=ce46b85af14a2d21447b&redirect_uri=http://localhost:8080/callback&scope=user&state=2">登录</a></li>
<li th:if="${session.user != null}" class="dropdown">
	<a th:text="${session.user.name}" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">我 <span class="caret"></span></a>
	<ul class="dropdown-menu">
		<li><a href="#">消息中心</a></li>
		<li><a href="#">个鸭资料</a></li>
		<li><a href="#">退出登录</a></li>
	</ul>
</li>
```

​	重启应用，测试效果。

<img src="screenshots\35-gitoauth.png" style="zoom:100%;"/>

​	后面每次刷新页面，都会显示用户名，屏蔽登录按钮。





# 7、集成 H2 

​	H2 是一个用 Java 开发的嵌入式数据库管理系统，在本地开发中，可以使用 H2 作为数据库，方便本地开发测试。

在 IDEA 上使用 Database 组件，创建 H2 数据源

<img src="screenshots\36-h2.png" style="zoom:60%;"/>

<img src="screenshots\37-h2.png" style="zoom:60%;"/>

测试连接是否可用

<img src="screenshots\38-h2.png" style="zoom:60%;"/>

<img src="screenshots\39-h2.png" style="zoom:60%;"/>

创建数据表

<img src="screenshots\40-h2.png" style="zoom:70%;"/>

```sql
create table c_user
(
    id           long auto_increment primary key,
    account_id   varchar(100),
    name         varchar(50),
    token        char(36),
    gmt_create   bigint,
    gmt_modified bigint
);

comment on table c_user is '用户信息表';
comment on column c_user.id is '用户id';
comment on column c_user.account_id is 'github账号ID';
comment on column c_user.name is '用户名';
comment on column c_user.token is '登录token';
comment on column c_user.gmt_create is '创建时间';
comment on column c_user.gmt_modified is '修改时间';
```

<img src="screenshots\43-h2.png" style="zoom:70%;"/>

​	使用 H2 数据库，需要先引入依赖：

```xml
<!-- H2 DB(必须和IDEA Database插件中创建的H2数据库驱动版本一致，否则会报错) -->
<dependency>
	<groupId>com.h2database</groupId>
	<artifactId>h2</artifactId>
	<version>2.1.210</version>
	<scope>runtime</scope>
</dependency>
```

​	使用 H2 作为数据源，需要在 application.properties 中配置数据源：

```properties
# DataSource
spring.datasource.url=jdbc:h2:~/community
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=org.h2.Driver
```





# 8、集成 Mybatis 记录登录用户

​	首先引入依赖：

```xml
<dependency>
	<groupId>org.mybatis.spring.boot</groupId>
	<artifactId>mybatis-spring-boot-starter</artifactId>
	<version>2.0.1</version>
</dependency>
```

​	定义用户对象

```java
package life.majiang.community.model;

import lombok.Data;

@Data
public class User {

    private long id;
    private String accountId;
    private String name;
    private String token;
    private long gmtCreate;
    private long gmtModified;

}
```

​	定义 Mapper 接口

```java
package life.majiang.community.mapper;

import life.majiang.community.model.User;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface UserMapper {

    @Insert("insert into c_user (account_id, name, token, gmt_create, gmt_modified) values (#{accountId}, #{name}, #{token}, #{gmtCreate}, #{gmtModified})")
    public void insert(User user);

}
```

​	修改授权控制器 `AuthorizeController` ，新增获取 Github 用户数据成功后插入到数据库中

```java
@Controller
@Slf4j
public class AuthorizeController {
	...
    @Autowired
    private UserMapper userMapper;	
	...
	
	@GetMapping("/callback")
    public String callback(@RequestParam(name = "code") String code,
                           @RequestParam(name = "state") String state,
                           HttpServletRequest request) {
        if (githubUser != null && githubUser.getId() != null) {
            log.info("Github OAuth succ");
            User user = new User();
            user.setAccountId(String.valueOf(githubUser.getId()));
            user.setName(githubUser.getName());
            user.setToken(UUID.randomUUID().toString());
            user.setGmtCreate(System.currentTimeMillis());
            user.setGmtModified(user.getGmtCreate());
            userMapper.insert(user);

            // 设置用户登录会话
            request.getSession().setAttribute("user", user);
            response.addCookie(new Cookie("token", user.getToken()));          
          
            return "redirect:/";
        } else {
            // 登录失败，重新登录
            log.info("Github OAuth fail");
            return "redirect:/";
        }                           
	}
}
```

​	启动应用进入首页登录，发现点击登录后回显用户名信息了，并且在数据库中插入了一条新的记录

<img src="screenshots\44-h2.png" style="zoom:70%;"/>

​	但是如果关闭应用程序，再重启，由于 session 数据是保存在服务端内存中的数据，所以应用重启后，之前的 session 数据就被清空了，所以重启再打开首页默认还是未登录状态。

​	**优化思路是**，在每次访问首页时，后端尝试从 cookie 中拿到上次登录的 token，再用 token 去查询数据库的用户数据，查到再放到 session 中，这样渲染页面时，就能保持上次的登录状态。

​	首先要在 `UserMapper` 里添加根据 token 查询用户信息的方法：

```java
@Mapper
public interface UserMapper {

	...

    @Select("select * from c_user where token = #{token}")
    public User getByToken(@Param("token") String token);
}
```

​	在访问首页的控制器`IndexController`，修改代码如下：

```java
package life.majiang.community.controller;

import life.majiang.community.mapper.UserMapper;
import life.majiang.community.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;

@Controller
public class IndexController {

    @Autowired
    private UserMapper userMapper;

    @GetMapping("/")
    public String index(HttpServletRequest request) {
        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if ("token".equals(cookie.getName())) {
                    String token = cookie.getValue();
                    User user = userMapper.getByToken(token);
                    if (user != null) {
                        request.getSession().setAttribute("user", user);
                    }
                    break;
                }
            }
        }

        return "index";
    }

}
```

​	一般 cookie 需要设有效期，防止非用户本人访问自动保持登录会话，修改授权控制器 `AuthorizeController` ，代码如下：

```java
@Controller
@Slf4j
public class AuthorizeController {

  	...

    @GetMapping("/callback")
    public String callback(@RequestParam(name = "code") String code,
                           @RequestParam(name = "state") String state,
                           HttpServletRequest request,
                           HttpServletResponse response) {
	    ...

        if (githubUser != null && githubUser.getId() != null) {
            log.info("Github OAuth succ");

		   ...

            // 设置用户登录会话
            //request.getSession().setAttribute("user", user);
            Cookie cookie = new Cookie("token", user.getToken());
            cookie.setPath("/");
            cookie.setMaxAge(3600);
            response.addCookie(cookie);

            return "redirect:/";
        } else {
            // 登录失败，重新登录
            log.info("Github OAuth fail");
            return "redirect:/";
        }
    }

}
```

​	启动应用，点击登录测试

<img src="screenshots\45-h2.png" style="zoom:70%;"/>

​	可以看到浏览器 cookie 中有了 token 的数据，并且设置了有效期。

​	停止应用程序，查看数据库，有了一条新的数据，并且 token 跟浏览器中看到的一致

<img src="screenshots\46-h2.png" style="zoom:100%;"/>

​	重新启动应用，测试是否自动保持登录状态，结果正常登录，再次访问数据库并未发现新增的记录，说明根据 cookie 中的 token 查询数据库并且设置用户会话的处理生效了。

​	与此同时，发现一个新的问题，设置的 token cookie 的有效时间时区不对，跟当前差了 8 个小时，在 application.properties 中设置：

```properties
spring.jackson.time-zone=Asia/Shanghai
```





# 9、集成 Flyway Migration

## （1）简介

​	flyway 是一款让数据库迁移变得简单的工具，下面简单介绍其工作原理，最简单的情况是用 Flyway 将数据库结构迁移到一个空数据库。

<img src="screenshots\47-flyway.png" style="zoom:100%;"/>



​	flyway 自带一个 schema 历史迁移表。若找不到该表，则会先创建该表。

​	执行了之后，数据库中会出现一张空表  *flyway_schema_history*  

<img src="screenshots\48-flyway.png" style="zoom:100%;"/>

​	该表用于跟踪数据库的状态

​	紧接着 Flyway 会开始扫描文件系统或应用的类路径来找到迁移文件，这些文件可能是 Sql 也可能是 Java 文件。

​	迁移的执行顺序会按照文件的版本号进行：

<img src="screenshots\49-flyway.png" style="zoom:100%;"/>

​	应用每次迁移时，架构历史表都会相应更新：

<img src="screenshots\50-flyway.png" style="zoom:100%;"/>

​	元数据和初始状态就位后，我们现在可以讨论迁移到新版本。

​	Flyway 会再次扫描文件系统或应用的类路径，根据架构历史表检查迁移，如果它们的版本号低于或等于标记为当前的版本号，则它们将被忽略。

​	剩余的迁移是待处理的迁移：可用，但未应用。

<img src="screenshots\51-flyway.png" style="zoom:100%;"/>

​	然后它们按版本号排序并按顺序执行：

<img src="screenshots\52-flyway.png" style="zoom:100%;"/>

​	架构历史表会相应更新：

<img src="screenshots\53-flyway.png" style="zoom:100%;"/>

​	每次需要改进数据库时，无论是结构（DDL）还是参考数据（DML），只需创建一个版本号高于当前版本号的新迁移即可。Flyway下次启动时，它会找到它并相应地升级数据库。



## （2）Maven 插件

​	首先在 Maven 工程的 pom.xml 中添加配置：

```xml
<project xmlns="...">
    <build>
        <plugins>
            <plugin>
                <groupId>org.flywaydb</groupId>
                <artifactId>flyway-maven-plugin</artifactId>
                <version>9.17.0</version>
                <configuration>
                    <url>jdbc:h2:~/community</url>
                    <user>root</user>
                    <password>root</password>
                </configuration>
                <dependencies>
                    <!-- 插件的版本要跟Jar包引入保持一致 -->
                    <dependency>
                        <groupId>com.h2database</groupId>
                        <artifactId>h2</artifactId>
                        <version>2.1.210</version>
                    </dependency>
                </dependencies>
            </plugin>
        </plugins>
    </build>
</project>
```

​	迁移文件的目录是 `src/main/resources/db/migration` ，在该目录下创建迁移文件 `V1__Create_user_table.sql` :

```sql
create table c_user
(
    id           long auto_increment primary key,
    account_id   varchar(100),
    name         varchar(50),
    token        char(36),
    gmt_create   bigint,
    gmt_modified bigint
);

comment on table c_user is '用户信息表';
comment on column c_user.id is '用户id';
comment on column c_user.account_id is 'github账号ID';
comment on column c_user.name is '用户名';
comment on column c_user.token is '登录token';
comment on column c_user.gmt_create is '创建时间';
comment on column c_user.gmt_modified is '修改时间';
```

​	在工程目录下执行 `mvn flyway:migrate` 

<img src="screenshots\54-flyway.png" style="zoom:100%;"/>

​	原来的用户表被删了再重建，数据被清空，同时还多了一张迁移表

<img src="screenshots\55-flyway.png" style="zoom:100%;"/>

​	迁移表记录了执行迁移的记录，包括文件、版本等信息

<img src="screenshots\56-flyway.png" style="zoom:100%;"/>

​	新增一个 V2 版本的迁移 SQL 文件，脚本如下：

```sql
ALTER TABLE C_USER ADD bio VARCHAR(256) NULL;
```

​	再次执行 `mvn flyway:migrate` 

<img src="screenshots\57-flyway.png" style="zoom:100%;"/>

​	查看迁移表，又多了一条记录

<img src="screenshots\58-flyway.png" style="zoom:100%;"/>

​	查看变结构，多了一个字段

<img src="screenshots\59-flyway.png" style="zoom:60%;"/>

​	



# 10、添加文章发布功能

## （1）前端

​	新增页面 publish.html

```html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>鸭鸭社区</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/community.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>
    <nav class="navbar navbar-default">
        <div class="container-fluid">

            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                    <span class="sr-only">鸭鸭社区</span>
                </button>
                <a class="navbar-brand" href="/">鸭鸭社区</a>
            </div>

            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <form class="navbar-form navbar-left">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="搜索问题">
                    </div>
                    <button type="submit" class="btn btn-default">搜索</button>
                </form>
                <ul class="nav navbar-nav navbar-right">
                    <li th:if="${session.user != null}"><a href="/publish">发布</a></li>
                    <li th:if="${session.user == null}"><a href="https://github.com/login/oauth/authorize?client_id=ce46b85af14a2d21447b&redirect_uri=http://localhost:8080/callback&scope=user&state=2">登录</a></li>
                    <li th:if="${session.user != null}" class="dropdown">
                        <a th:text="${session.user.name}" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">我 <span class="caret"></span></a>
                        <ul class="dropdown-menu">
                            <li><a href="#">消息中心</a></li>
                            <li><a href="#">个鸭资料</a></li>
                            <li><a href="#">退出登录</a></li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container-fluid main">
        <div class="row">
            <div class="col-lg-9 col-md-12 col-sm-12 col-xs-12">
                <h2><span class="glyphicon glyphicon-plus" aria-hidden="true"></span>发起</h2>
                <hr>

                <form action="/publish" method="post">
                    <input type="text" style="display:none" id="id" name="id" th:value="${id}"/>
                    <div class="form-group">
                        <label for="title">问题标题（简单扼要）：</label>
                        <input type="text" class="form-control" id="title" name="title" placeholder="问题标题……" th:value="${title}">
                    </div>
                    <div class="form-group">
                        <label for="description">问题补充（必填，请参照右侧提示）:</label>
                        <textarea class="form-control" id="description" name="description" rows="10" cols="30" th:text="${description}"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="tag">添加标签：</label>
                        <input type="text" class="form-control" id="tag" name="tag" placeholder="输入标签，以逗号分隔" th:value="${tag}">
                    </div>

                    <div class="container-fluid" style="padding-right: 0">
                        <div class="row">
                            <div class="col-lg-9 col-md-12 col-sm-12 col-xs-12">
                                <div class="alert alert-danger" role="alert" th:text="${error}" th:if="${error != null}"></div>
                            </div>
                            <div class="col-lg-3 col-md-12 col-sm-12 col-xs-12">
                                <button type="submit" class="btn btn-success btn-publish">提问</button>
                            </div>
                        </div>
                    </div>
                </form>
            </div>
            <div class="col-lg-3 col-md-12 col-sm-12 col-xs-12">
                <h3>热门话题</h3>
            </div>
        </div>
    </div>

</body>
</html>
```

​	编写一个响应请求展现页面的控制器 `PublishController` ，代码如下：

```java
package life.majiang.community.controller;

import life.majiang.community.mapper.QuestionMapper;
import life.majiang.community.model.Question;
import life.majiang.community.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletRequest;

@Controller
public class PublishController {

    @GetMapping("/publish")
    public String publish(HttpServletRequest request) {
        return "publish";
    }
}
```

​	启动应用，访问 `http://localhost:8080/publish` ，页面展现如下

<img src="screenshots\60-publish.png" style="zoom:100%;"/>

​	用户还没登录，就可以发布问题，显然是不合理的，所以在访问页面时，控制器里应先判断当前用户会话是否为空，会话中保存的用户信息是否为空，是则跳转到首页，用户在首页登录后再访问本页才能展现页面，代码修改如下：

```java
    @GetMapping("/publish")
    public String publish(HttpServletRequest request) {
        if (request.getSession() != null && request.getSession().getAttribute("user") == null) {
            return "redirect:/";
        }
        return "publish";
    }
```

​	重启应用再次访问 `http://localhost:8080/publish` ，会发现会重定向到 `http://localhost:8080/` ，达到想要的效果。

<img src="screenshots\61-publish.png" style="zoom:100%;"/>



## （2）后端

​	首先要有一张表存储用户发布的问题，除了发布页面的标题、内容和标签外，还要有评论数、阅读数、点赞数、作者，方便在接下来的文章详情展示页中展示，除此之外，每条数据还要有创建时间、修改时间，综上所述，建表语句如下：

```sql
create table question
(
    id            INT auto_increment primary key,
    title         VARCHAR(50) COMMENT '问题标题',
    description   TEXT COMMENT '问题描述',
    gmt_create    BIGINT COMMENT '创建时间',
    gmt_modified  BIGINT COMMENT '修改时间',
    creator       INT comment '创建者',
    comment_count INT DEFAULT 0 COMMENT '评论数',
    view_count    INT DEFAULT 0 COMMENT '阅读数',
    like_count    INT DEFAULT 0 COMMENT '点赞数',
    tag           VARCHAR(256) COMMENT '标签'
);
```

​	将其放在 resource/db/migration 目录下的 `V3__Create_question_table.sql` 中，然后执行 `mvn flyway:migrate` 命令执行迁移。

​	接着建立表对应的 POJO 类 `Question` ，代码如下：

```java
package life.majiang.community.model;

import lombok.Data;

@Data
public class Question {

    private Long id;
    private String title;
    private String description;
    private Long gmtCreate;
    private Long gmtModified;
    private Long creator;
    private Integer commentCount;
    private Integer viewCount;
    private Integer likeCount;
    private String tag;

}
```

​	定义对应的 Mapper，新增插入数据的方法：

```java
package life.majiang.community.mapper;

import life.majiang.community.model.Question;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface QuestionMapper {

    @Insert("insert into question (title, description, gmt_create, gmt_modified, creator, tag) values (#{title}, #{description}, #{gmtCreate}, #{gmtModified}, #{creator}, #{tag})")
    void insert(Question question);

}
```

​	在 `PublishController` 中定义处理 POST 请求的方法

```java
@Controller
public class PublishController {
  
	// other code	
  
    @PostMapping("/publish")
    public String doPublish(@RequestParam(value = "title") String title,
                            @RequestParam(value = "description") String description,
                            @RequestParam(value = "tag") String tag,
                            HttpServletRequest request,
                            Model model) {
        // 方便页面回显，这样页面已经填了的信息不用再重填一次
        model.addAttribute("title", title);
        model.addAttribute("description", description);
        model.addAttribute("tag", tag);
        //model.addAttribute("id", id);

        if (StringUtils.isEmpty(title)) {
            model.addAttribute("error", "标题不能为空");
            return "publish";
        }
        if (StringUtils.isEmpty(description)) {
            model.addAttribute("error", "问题补充不能为空");
            return "publish";
        }
        if (StringUtils.isEmpty(tag)) {
            model.addAttribute("error", "标签不能为空");
            return "publish";
        }

        // 如果cookie中不存在token，或根据token查无用户，则返回报错
        if (request.getSession() == null || request.getSession().getAttribute("user") == null) {
            model.addAttribute("error", "用户未登录");
            return "publish";
        }

        User user = (User) request.getSession().getAttribute("user");
        // 记录提交问题带数据库
        Question question = new Question();
        question.setTitle(title);
        question.setDescription(description);
        question.setGmtCreate(System.currentTimeMillis());
        question.setGmtModified(question.getGmtCreate());
        question.setCreator(user.getId());
        question.setTag(tag);
        questionMapper.insert(question);

        return "redirect:/";
    }
}
```

​	启动应用，访问首页登录后点击发布，填写问题相关信息

<img src="screenshots\62-publish.png" style="zoom:100%;"/>

​	点击提交成功后自动跳转到首页，查看数据库，成功插入了一条数据

<img src="screenshots\63-publish.png" style="zoom:100%;"/>

​	当提交问题为空时，会返回报错回显到页面上提示

<img src="screenshots\64-publish.png" style="zoom:100%;"/>





# 11、添加文章列表功能

## （1）添加字段

​	一些论坛社区的通常会有一个帖子或文章列表，如下图所示：

<img src="screenshots\65-list.png" style="zoom:100%;"/>

​	会展示用户头像，所以需要在用户表和对应的 POJO 以及数据库处理中增加对应的字段，新增迁移文件 `V4__Add_avatarUrl_col_to_user_table.sql`：

```sql
ALTER TABLE C_USER ADD avatar_url VARCHAR(100) NULL;

comment on column c_user.avatar_url is '用户头像';
```

​	执行迁移命令，在 `User` 类中添加相应字段

```java
@Data
public class User {

    private long id;
    private String accountId;
    private String name;
    private String token;
    private long gmtCreate;
    private long gmtModified;
    private String bio;
    private String avatarUrl;

}
```

​	在 `AuthorizeController` 中修改 OAuth 登录成功之后的处理代码：

```java
            User user = new User();
            user.setAccountId(String.valueOf(githubUser.getId()));
            user.setName(githubUser.getName());
            user.setToken(UUID.randomUUID().toString());
            user.setGmtCreate(System.currentTimeMillis());
            user.setGmtModified(user.getGmtCreate());
            user.setBio(githubUser.getBio());                 // 新增代码
            user.setAvatarUrl(githubUser.getAvatarUrl());     // 新增代码
            userMapper.insert(user);
```

​	修改 `UserMapper` 

```java
@Mapper
public interface UserMapper {

    @Insert("insert into c_user (account_id, name, token, gmt_create, gmt_modified, bio, avatar_url) values (#{accountId}, #{name}, #{token}, #{gmtCreate}, #{gmtModified}, #{bio}, #{avatarUrl})")
    public void insert(User user);
    
    // other code
}    
```

​	启动程序再次登录，登录成功后查看数据库，记录下了简介和头像两个用户信息

<img src="screenshots\66-list.png" style="zoom:100%;"/>



## （2）前端

​	修改前端页面 `index.html`

```html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>鸭鸭社区</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/community.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>
    <nav class="navbar navbar-default">
        <div class="container-fluid">

            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                    <span class="sr-only">鸭鸭社区</span>
                </button>
                <a class="navbar-brand" href="/">鸭鸭社区</a>
            </div>

            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <form class="navbar-form navbar-left">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="搜索问题">
                    </div>
                    <button type="submit" class="btn btn-default">搜索</button>
                </form>
                <ul class="nav navbar-nav navbar-right">
                    <li th:if="${session.user != null}"><a href="/publish">发布</a></li>
                    <li th:if="${session.user == null}"><a href="https://github.com/login/oauth/authorize?client_id=ce46b85af14a2d21447b&redirect_uri=http://localhost:8080/callback&scope=user&state=2">登录</a></li>
                    <li th:if="${session.user != null}" class="dropdown">
                        <a th:text="${session.user.name}" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">我 <span class="caret"></span></a>
                        <ul class="dropdown-menu">
                            <li><a href="#">消息中心</a></li>
                            <li><a href="#">个鸭资料</a></li>
                            <li><a href="#">退出登录</a></li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container-fluid main">
        <div class="row">
            <div class="col-lg-9 col-md-12 col-sm-12 col-xs-12 question-list">
                <h2><span class="glyphicon glyphicon-plus" aria-hidden="true"></span>发起</h2>
                <hr>
                <div class="media">
                    <div class="media-left">
                        <a href="#">
                            <img class="media-object img-rounded" src="https://avatars.githubusercontent.com/u/11757351?v=4">
                        </a>
                    </div>
                    <div class="media-body">
                        <h4 class="media-heading">Media heading</h4>
                        ...
                        <span class="text-desc">0 个评论 • 409 次浏览 • 2 天前</span>
                    </div>
                </div>
            </div>
            <div class="col-lg-3 col-md-12 col-sm-12 col-xs-12">
                <h3>热门话题</h3>
            </div>
        </div>
    </div>

</body>
</html>
```

​	启动应用访问 `http://localhost:8080`，效果如下：

<img src="screenshots\67-list.png" style="zoom:100%;"/>

​	只要后端提供一个查询问题数据列表的接口，并将数据渲染到该页面上，就可得到一个文章列表。



## （3）后端

​	首先要有一个查询问题列表的数据服务，同时每条数据还要带上用户信息（用于显示提问用户头像），可以选择在 `Question` 类中添加一个 `User` 的成员属性，但是这样不符合类设计的单一职责原则，为了将问题和用户的信息关联组合在一个类中，需要定义一个新的 `QuestionDTO` 类，代码如下：

```java
package life.majiang.community.dto;

import life.majiang.community.model.User;
import lombok.Data;

@Data
public class QuestionDTO {

    private Long id;
    private String title;
    private String description;
    private Long gmtCreate;
    private Long gmtModified;
    private Long creator;
    private Integer commentCount;
    private Integer viewCount;
    private Integer likeCount;
    private String tag;
    private User user;

}
```

​	定义一个问题服务类 `QuestionService` ，代码如下：

```java
package life.majiang.community.service;

import life.majiang.community.dto.QuestionDTO;
import life.majiang.community.mapper.QuestionMapper;
import life.majiang.community.mapper.UserMapper;
import life.majiang.community.model.Question;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;

@Service
public class QuestionService {

    @Autowired
    private QuestionMapper questionMapper;

    @Autowired
    private UserMapper userMapper;

    public List<QuestionDTO> list() {
        List<QuestionDTO> list = new ArrayList<>();

        List<Question> questions = questionMapper.list();
        for (Question question : questions) {
            QuestionDTO questionDTO = new QuestionDTO();
            BeanUtils.copyProperties(question, questionDTO);
            questionDTO.setUser(userMapper.getById(question.getCreator()));
            list.add(questionDTO);
        }

        return list;
    }

}
```

​	该服务中注入了 mapper，并通过 mapper 的数据操作来获取数据，首先 `QuestionMapper` 要有查询所有问题列表的方法，新增代码如下：

```java
@Mapper
public interface QuestionMapper {

    // other code

    @Select("select * from question")
    List<Question> list();
}
```

​	查到问题后，要对每个问题逐个查询提交人是谁，所以 `UserMapper` 也要根据用户id查询用户的方法，新增代码如下：

```java
@Mapper
public interface UserMapper {

	// other code

    @Select("select * from c_user where id = #{id}")
    public User getById(@Param("id") long id);
}
```

​	完成了服务的编写，在访问首页时使用，并将其放到 model 中才能在页面上渲染

```java
@Controller
public class IndexController {

    @Autowired
    private UserMapper userMapper;

    @Autowired
    private QuestionService questionService;

    @GetMapping("/")
    public String index(HttpServletRequest request,
                        Model model) {
		// other code

        List<QuestionDTO> questionDTOS = questionService.list();
        model.addAttribute("questions", questionDTOS);

        return "index";
    }

}
```

​	返回的数据是一个列表，借助 thymeleaf 模板引擎的 `th:each` 进行遍历和渲染，index.html的局部代码修改如下：

```html
<div class="container-fluid main">
    <div class="row">
        <div class="col-lg-9 col-md-12 col-sm-12 col-xs-12 question-list">
            <h2><span class="glyphicon glyphicon-plus" aria-hidden="true"></span>发起</h2>
            <hr>
            <div class="media" th:each="question : ${questions}">
                <div class="media-left">
                    <a href="#">
                        <img class="media-object img-rounded" th:src="${question.user.avatarUrl}"/>
                    </a>
                </div>
                <div class="media-body">
                    <h4 class="media-heading" th:text="${question.title}"></h4>
                    <span th:text="${question.description}"></span><br>
                    <span class="text-desc">
                        <span th:text="${question.commentCount}"></span> 个评论 •
                        <span th:text="${question.viewCount}"></span> 次浏览 •
                        <span th:text="${#dates.format(question.gmtCreate,'yyyy-MM-dd HH:mm')}"></span>
                    </span>
                </div>
            </div>
        </div>
        <div class="col-lg-3 col-md-12 col-sm-12 col-xs-12">
            <h3>热门话题</h3>
        </div>
    </div>
</div>
```

​	启动应用，访问 `http://localhost:8080` ，效果如下：

<img src="screenshots\68-list.png" style="zoom:100%;"/>

​	好像并不是我们要的效果，问题内容应该在详情页才展现，参考下 elasticsearch 中文社区

<img src="screenshots\69-list.png" style="zoom:100%;"/>

​	显示的是文章标签和作者，修改代码如下：

```html
<div class="container-fluid main">
    <div class="row">
        <div class="col-lg-9 col-md-12 col-sm-12 col-xs-12 question-list">
            <h2><span class="glyphicon glyphicon-plus" aria-hidden="true"></span>发起</h2>
            <hr>
            <div class="media" th:each="question : ${questions}">
                <div class="media-left">
                    <a href="#">
                        <img class="media-object img-rounded" th:src="${question.user.avatarUrl}"/>
                    </a>
                </div>
                <div class="media-body">
                    <h4 class="media-heading" th:text="${question.title}"></h4>
                    <span class="text-desc">
                        <a class="question-tags" href="#" th:text="${question.tag}"></a> •
                        <span th:text="${question.user.name}"></span> 发表了文章 •
                        <span th:text="${question.commentCount}"></span> 个评论 •
                        <span th:text="${question.viewCount}"></span> 次浏览 •
                        <span th:text="${#dates.format(question.gmtCreate,'yyyy-MM-dd HH:mm')}"></span>
                    </span>
                </div>
            </div>
        </div>
        <div class="col-lg-3 col-md-12 col-sm-12 col-xs-12">
            <h3>热门话题</h3>
        </div>
    </div>
</div>
```

​	再次启动应用访问首页，达到了想要的效果

<img src="screenshots\70-list.png" style="zoom:100%;"/>

​	再发布一个问题，发布成功跳转回首页，展现列表如下：

<img src="screenshots\71-list.png" style="zoom:100%;"/>





# 12、IDEA 自动热部署

## （1）IDEA 配置

​	打开 `Settings` 编译配置，勾选 `Build project automatically`

<img src="screenshots\72-devtools.png" style="zoom:100%;"/>

​	在旧版的 IDEA，通过 `ctrl + alt + shift + ?` ，然后进入 `Registry`

<img src="screenshots\74-devtools.png" style="zoom:60%;"/>

​	找到一个 `compiler.automake.allow.when.app.running` 的配置勾选

<img src="screenshots\75-devtools.png" style="zoom:100%;"/>

​	在新版本的 IDEA 中，打开 `Settings` -> `Advanced Settings` ，勾选以下选项

<img src="screenshots\73-devtools.png" style="zoom:100%;"/>

​	在最新版本的 2023 IDEA，还要添加配置

<img src="screenshots\76-devtools.png" style="zoom:100%;"/>



## （2）Devtools

​	Spring Boot 包含一组额外的工具，可以使应用程序开发体验更加愉快。 spring-boot-devtools 模块可以包含在任何项目中以提供额外的开发时功能。

​	在工程中添加 `spring-boot-devtools` 的依赖

```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-devtools</artifactId>
	<optional>true</optional>
</dependency>
```

​	对于完成打包的应用程序 Devtools 默认是不启用的，如果您的应用程序是从 java -jar 启动的，或者是从特殊的类加载器启动的，那么它被视为“生产应用程序”。可以通过 `spring.devtools.restart.enabled` 属性配置自由控制是否启用，但是在生产环境中时很危险的。

​	某些资源在更改时不一定需要触发重新启动。例如，Thymeleaf 模板可以就地编辑。默认情况下，更改 `/META-INF/maven`、`/META-INF/resources`、`/resources`、`/static`、`/public` 或 `/templates` 中的资源不会触发重新启动，但会被浏览器端的 LiveReload 感知并重新加载。如果要自定义这些排除项，可以使用 `spring.devtools.restart.exclude` 属性。

​	例如，要仅排除 /static 和 /public，您可以设置以下属性：

```properties
spring.devtools.restart.exclude=static/**,public/**
```

​	这样修改 static/、public/ 目录下的静态文件时也会触发应用自动重启。



## （3）测试

​	启动应用，再修改代码保存，可以触发自动重启

<img src="screenshots\77-devtools.png" style="zoom:100%;"/>

​	Devtools 还可以跟浏览器端的 LiveReload 组件配合使用，比如访问网页，然后在浏览器上设置当前网站启用  LiveReload，接着在 IDE 里修改 HTML 文件（静态资源文件不会重启应用）。

<img src="screenshots\78-livereload.png" style="zoom:100%;"/>

​	这时浏览器会自动刷新

<img src="screenshots\79-livereload.png" style="zoom:100%;"/>





# 13、实现分页功能

​	当问题比较多时，放在一个页面显示的话数据量太大，需要有个分页查询的功能，通过数据库以下语法查询：

```
select * from tab where ... limit size offset (page-1) * size
# 也可以用语法
limit (page-1) * size, size
```

​	`size` 是每页的数据量，`page` 表示第几页，`(page-1) * size` 是计算出来的偏移量。

​	假设每页有3条数据，查询第一页是 `limit 3 offset 0` ，第二页是 `limit 3 offset 3` ，以此类推。

​	实现分页要获取当前页的数据，还要知道总页数，所以在 `QuestionMapper` 中添加对应的数据操作方法

```java
@Mapper
public interface QuestionMapper {
	// other code

    // 查询分页问题列表
    @Select("select * from question limit #{offset}, #{size}")
    List<Question> listPage(@Param("offset") Integer offset, @Param("size") Integer size);

    // 获取总记录条数
    @Select("select count(1) from question")
    Integer count();
}
```

​	每次返回当前页的数据列表的同时，还要返回展现分页栏需要的信息

<img src="screenshots\80-pagination.png" style="zoom:100%;"/>

​	我们想要这样一个分页栏：

（1）当前页为首页时，不显示上一页和首页的跳转箭头

<img src="screenshots\81-pagination.png" style="zoom:100%;"/>

（2）当前页为尾页时，不显示下一页和尾页的跳转箭头

<img src="screenshots\82-pagination.png" style="zoom:100%;"/>

（3）当前页离首页超过3页时，显示跳转到首页的箭头；当前页离尾页超过3页时，显示跳转到尾页的箭头

<img src="screenshots\80-pagination.png" style="zoom:100%;"/>

​	根据以上需求，返回的分页栏信息中，要包含以下信息：

* 是否显示上一页、下一页箭头

* 是否显示首页、尾页箭头

* 当前页

* 当前页的前后3页，靠近头部和尾部则显示到头尾为止

  我们首先需要封装一个分页的类 `PaginationDTO`，按照上述需求，代码如下：

```java
package life.majiang.community.dto;

import lombok.Data;

import java.util.ArrayList;
import java.util.List;

@Data
public class PaginationDTO {

    private boolean showFirstPage;                      // 是否显示头页标签 <<
    private boolean showLastPage;                       // 是否显示尾页标签 >>
    private boolean showPrevPage;                       // 是否显示前一页 <
    private boolean showNextPage;                       // 是否显示下一页 >
    private Integer currentPage;                        // 当前页是第几页
    private Integer totalPages;                         // 一共有多少页
    private List<Integer> pages = new ArrayList<>();    // 显示页码
    private List<Object> data;

    /**
     *
     * @param totalCount    总数据条数
     * @param page          第几页
     * @param size          每页数据条数
     */
    public void init(Integer totalCount, Integer page, Integer size) {
        this.currentPage = page;
        this.totalPages = (totalCount % size == 0) ? totalCount/size : totalCount/size + 1;
        this.showFirstPage = (page - 3 > 1);
        this.showLastPage = (totalPages - page > 3);
        this.showPrevPage = (page != 1);
        this.showNextPage = (page != totalPages);

        /**
         * 假设page为4，总页数为10
         * 则页码列表应为 1,2,3,4,5,6,7
         */
        pages.add(page);
        for (int i = 1; i <= 3; i++) {
            if (page - i > 0) {
                pages.add(0, page - i);
            }
            if (page + i <= totalPages) {
                pages.add(page + i);
            }
        }
    }

}
```

​	在 `QuestionService` 中添加查询分页的方法：

```java
public PaginationDTO pageListWithBar(Integer page, Integer size) {
	// 获得要展现页的数据
	Integer offset = (page - 1) * size;
	List<QuestionDTO> questionDTOS = getQuestionDTOS( questionMapper.listPage(offset, size));

	Integer totalCount = questionMapper.count();
	PaginationDTO paginationDTO = new PaginationDTO();
	paginationDTO.init(totalCount, page, size);
	paginationDTO.setData(questionDTOS.stream()
									  .map(o -> (Object) o)
									  .collect(Collectors.toList()));

	return paginationDTO;
}

private List<QuestionDTO> getQuestionDTOS(List<Question> questions) {
	List<QuestionDTO> questionDTOS = new ArrayList<>();

	for (Question question : questions) {
		QuestionDTO questionDTO = new QuestionDTO();
		BeanUtils.copyProperties(question, questionDTO);
		questionDTO.setUser(userMapper.getById(question.getCreator()));
		questionDTOS.add(questionDTO);
	}

	return questionDTOS;
}
```

​	修改 `IndexController` 代码：

```java
@Controller
public class IndexController {

    // other code

    @Autowired
    private QuestionService questionService;

    @GetMapping("/")
    public String index(HttpServletRequest request,
                        Model model,
                        @RequestParam(name = "page", defaultValue = "1") Integer page,
                        @RequestParam(name = "size", defaultValue = "2") Integer size) {
        // other code

        PaginationDTO questionDTOS = questionService.pageListWithBar(page, size);
        model.addAttribute("pagination", questionDTOS);

        return "index";
    }

}
```

​	`page` 是前端上送的查询数据页页码，`size` 是每个数据页包含的数据条数。

​	修改 `index.html` ，使用 Bootstrap 的分页组件，代码如下：

```html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>鸭鸭社区</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/community.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>
<nav class="navbar navbar-default">
	// other code
</nav>

<div class="container-fluid main">
    <div class="row">
        <div class="col-lg-9 col-md-12 col-sm-12 col-xs-12 question-list">
            <h2><span class="glyphicon glyphicon-list" aria-hidden="true"></span> 发现</h2>
            <hr>
            <div class="media" th:each="question : ${pagination.data}">
                <div class="media-left">
                    <a href="#">
                        <img class="media-object img-rounded" th:src="${question.user.avatarUrl}"/>
                    </a>
                </div>
                <div class="media-body">
                    <h4 class="media-heading" th:text="${question.title}"></h4>
                    <span class="text-desc">
                        <a class="question-tags" href="#" th:text="${question.tag}"></a> •
                        <span th:text="${question.user.name}"></span> 发表了文章 •
                        <span th:text="${question.commentCount}"></span> 个评论 •
                        <span th:text="${question.viewCount}"></span> 次浏览 •
                        <span th:text="${#dates.format(question.gmtCreate,'yyyy-MM-dd HH:mm')}"></span>
                    </span>
                </div>
            </div>

            <div class="comm-pagination">
                <nav aria-label="...">
                    <ul class="pagination">
                        <li th:if="${pagination.showFirstPage}">
                            <a th:href="@{/(page=1)}" aria-label="Previous"><span aria-hidden="true">&lt;&lt;</span></a>
                        </li>
                        <li th:if="${pagination.showPrevPage}">
                            <a th:href="@{/(page=${pagination.currentPage-1})}" aria-label="Previous"><span aria-hidden="true">&lt;</span></a>
                        </li>

                        <li th:each="page : ${pagination.pages}" th:class="${pagination.currentPage == page}? 'active' : ''">
                            <a th:href="@{/(page=${page})}" th:text="${page}"></a>
                        </li>

                        <li th:if="${pagination.showNextPage}">
                            <a th:href="@{/(page=${pagination.currentPage+1})}" aria-label="Next"><span aria-hidden="true">&gt;</span></a>
                        </li>
                        <li th:if="${pagination.showLastPage}">
                            <a th:href="@{/(page=${pagination.totalPages})}" aria-label="Next"><span aria-hidden="true">&gt;&gt;</span></a>
                        </li>
                    </ul>
                </nav>
            </div>
        </div>
        <div class="col-lg-3 col-md-12 col-sm-12 col-xs-12">
            <h3>热门话题</h3>
        </div>
    </div>
</div>

</body>
</html>
```

​	启动应用程序，访问 `http://localhost:8080/` ，效果如下：

<img src="screenshots\83-pagination.png" style="zoom:100%;"/>

<img src="screenshots\84-pagination.png" style="zoom:100%;"/>

<img src="screenshots\85-pagination.png" style="zoom:100%;"/>

<img src="screenshots\86-pagination.png" style="zoom:100%;"/>





# 14、页面拆解复用导航栏

​	首先需要创建一个专门放复用模板段的文件 `navigation.html` ，代码如下：

```html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<body>

    <div th:fragment="navigation">
        <nav class="navbar navbar-default">
            <div class="container-fluid">

                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                        <span class="sr-only">鸭鸭社区</span>
                    </button>
                    <a class="navbar-brand" href="/">鸭鸭社区</a>
                </div>

                <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                    <form class="navbar-form navbar-left">
                        <div class="form-group">
                            <input type="text" class="form-control" placeholder="搜索问题">
                        </div>
                        <button type="submit" class="btn btn-default">搜索</button>
                    </form>
                    <ul class="nav navbar-nav navbar-right">
                        <li th:if="${session.user != null}"><a href="/publish">提问</a></li>
                        <li th:if="${session.user == null}"><a href="https://github.com/login/oauth/authorize?client_id=ce46b85af14a2d21447b&redirect_uri=http://localhost:8080/callback&scope=user&state=2">登录</a></li>
                        <li th:if="${session.user != null}" class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
                                <span th:text="${session.user.name}"></span>
                                <span class="caret"></span>
                            </a>
                            <ul class="dropdown-menu">
                                <li><a href="/profile/questions">消息中心</a></li>
                                <li><a href="#">个鸭资料</a></li>
                                <li><a href="/logout">退出登录</a></li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>
        </nav>
    </div>

</body>
```

​	在 `index.html ` 、`publish.html` 中引入模板段，删除重复代码

```html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>鸭鸭社区</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/community.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>
<!-- 引用模板 -->
<div th:insert="navigation :: navigation"></div>

<div class="container-fluid main">
	...
</div>
```

​	我们发现问题列表页和分页导航栏，也很适合拆解复用，在 `navigation.html` 中新增代码模板：

```java
...

   <div th:fragment="questionList">
        <div class="media" th:each="question : ${pagination.data}">
            <div class="media-left">
                <a href="#">
                    <img class="media-object img-rounded" th:src="${question.user.avatarUrl}"/>
                </a>
            </div>
            <div class="media-body">
                <a th:href="@{'/question/' + ${question.id}}">
                <h4 class="media-heading" th:text="${question.title}"></h4>
                </a>
                <span class="text-desc">
                        <a class="question-tags" href="#" th:text="${question.tag}"></a> •
                        <span th:text="${question.user.name}"></span> 发表了文章 •
                        <span th:text="${question.commentCount}"></span> 个评论 •
                        <span th:text="${question.viewCount}"></span> 次浏览 •
                        <span th:text="${#dates.format(question.gmtCreate,'yyyy-MM-dd HH:mm')}"></span>
                    </span>
            </div>
        </div>
    </div>

    <div th:fragment="pagination">
        <div class="comm-pagination">
            <nav aria-label="...">
                <ul class="pagination">
                    <li th:if="${pagination.showFirstPage}">
                        <a th:href="${section == null} ? @{./(page=1)} : @{'./'+${section}(page=1)}" aria-label="Previous"><span aria-hidden="true">&lt;&lt;</span></a>
                    </li>
                    <li th:if="${pagination.showPrevPage}">
                        <a th:href="${section == null} ? @{./(page=${pagination.currentPage-1})} : @{'./'+${section}(page=${pagination.currentPage-1})}" aria-label="Previous"><span aria-hidden="true">&lt;</span></a>
                    </li>

                    <li th:each="page : ${pagination.pages}" th:class="${pagination.currentPage == page}? 'active' : ''">
                        <a th:href="${section == null} ? @{./(page=${page})} : @{'./'+${section}(page=${page})}" th:text="${page}"></a>
                    </li>

                    <li th:if="${pagination.showNextPage}">
                        <a th:href="${section == null} ? @{./(page=${pagination.currentPage+1})} : @{'./'+${section}(page=${pagination.currentPage+1})}" aria-label="Next"><span aria-hidden="true">&gt;</span></a>
                    </li>
                    <li th:if="${pagination.showLastPage}">
                        <a th:href="${section == null} ? @{./(page=${pagination.totalPages})} : @{'./'+${section}(page=${pagination.totalPages})}" aria-label="Next"><span aria-hidden="true">&gt;&gt;</span></a>
                    </li>
                </ul>
            </nav>
        </div>
    </div>
...
```

​	这样 `index.html` 、`profile.html` 可以简化为：

```html
<!--index.html-->
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>鸭鸭社区</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/community.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>
<!-- 引用模板 -->
<div th:insert="navigation :: navigation"></div>

<div class="container-fluid main">
    <div class="row">
        <div class="col-lg-9 col-md-12 col-sm-12 col-xs-12 question-list">
            <h2><span class="glyphicon glyphicon-list" aria-hidden="true"></span> 发现</h2>
            <hr>
            <div th:insert="navigation :: questionList"></div>
            <div th:insert="navigation :: pagination"></div>
        </div>
        <div class="col-lg-3 col-md-12 col-sm-12 col-xs-12">
            <h3>热门话题</h3>
        </div>
    </div>
</div>

</body>
</html>

<!--profile.html-->
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title th:text="${sectionName}"></title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/community.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>

    <div th:insert="navigation :: navigation"></div>

    <div class="container-fluid main">
        <div class="row">
            <div class="col-lg-9 col-md-12 col-sm-12 col-xs-12 question-list">
                <h2>
                    <span class="glyphicon glyphicon-pushpin" aria-hidden="true"></span>
                    <span th:text="${sectionName}"></span>
                </h2>
                <hr>
                <div th:insert="navigation :: questionList"></div>
                <div th:insert="navigation :: pagination"></div>
            </div>

            <div class="col-lg-3 col-md-12 col-sm-12 col-xs-12 profile">
                <div class="list-group section">
                    <a href="/profile/questions" th:class="${section == 'questions'} ? 'list-group-item active' : 'list-group-item'">
                        我的问题
                        <span class="badge" th:if="${section == 'questions'}" th:text="${pagination.totalCount}"></span>
                    </a>
                    <a href="/profile/replies" th:class="${section == 'replies'} ? 'list-group-item active' : 'list-group-item'">
                        最新回复
                        <span class="badge" th:if="${section == 'replies'}" th:text="${pagination.totalCount}"></span>
                    </a>
                </div>
            </div>
        </div>
    </div>

</body>
</html>
```





# 15、添加个人资料发布问题列表功能

​	首先要实现数据接口，在首页显示列表的基础上新增一个根据用户ID查询的条件，在 `QuestionMapper` 中新增方法如下：

```java
@Select("select * from question where creator = #{creator} limit #{offset}, #{size}")
List<Question> userListPage(@Param("creator") Long creator, @Param("offset") Integer offset, @Param("size") Integer size);

@Select("select count(1) from question where creator = #{creator}")
Integer userCount(@Param("creator") Long creator);
```

​	在 `QuestionService` 中新增查询用户发布问题分页的方法：

```java
public PaginationDTO userPageListWithBar(Long userId, Integer page, Integer size) {
	Integer offset = (page - 1) * size;
	List<QuestionDTO> questionDTOS = getQuestionDTOS(questionMapper.userListPage(userId, offset, size));

	Integer totalCount = questionMapper.userCount(userId);
	PaginationDTO paginationDTO = new PaginationDTO();
	paginationDTO.init(totalCount, page, size);
	paginationDTO.setData(questionDTOS.stream()
			.map(o -> (Object) o)
			.collect(Collectors.toList()));

	return paginationDTO;
}
```

​	在查询用户发布问题列表的网页右侧，还要显示用户已发布问题的数量，所以要在 `PaginationDTO` 中新增一个 `totalCount` 的整型属性，并且在初始化方法中赋值：

```java
@Data
public class PaginationDTO {
    // ...
    private Integer totalCount;
    
    public void init(Integer totalCount, Integer page, Integer size) {
        this.totalCount = totalCount;
        // ...
    }
}
```

​	创建一个处理用户消息中心的控制器 `ProfileController` ，代码如下：

```java
package life.majiang.community.controller;

import life.majiang.community.dto.PaginationDTO;
import life.majiang.community.dto.QuestionDTO;
import life.majiang.community.mapper.QuestionMapper;
import life.majiang.community.model.Question;
import life.majiang.community.model.User;
import life.majiang.community.service.QuestionService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletRequest;
import java.util.List;

@Controller
public class ProfileController {

    @Autowired
    QuestionService questionService;

    @GetMapping("/profile/{action}")
    public String profile(HttpServletRequest request,
                          Model model,
                          @PathVariable(name = "action") String action,
                          @RequestParam(name = "page", defaultValue = "1") Integer page,
                          @RequestParam(name = "size", defaultValue = "2") Integer size) {
        if (request.getSession() != null && request.getSession().getAttribute("user") == null) {
            return "redirect:/";
        }
        User user = (User) request.getSession().getAttribute("user");

        model.addAttribute("section", action);
        if ("questions".equals(action)) {
            model.addAttribute("sectionName", "我的问题");

            PaginationDTO paginationDTO = questionService.userPageListWithBar(user.getId(), page, size);
            model.addAttribute("pagination", paginationDTO);
        } else if ("replies".equals(action)) {
            model.addAttribute("sectionName", "最新回复");
        }

        return "profile";
    }

}
```

​	控制器可以根据不同的分支，决定 model 要返回页面渲染的数据填充的内容。

​	创建一个 `profile.html` ，代码如下：

```html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title th:text="${sectionName}"></title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/community.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>

    <div th:insert="navigation :: navigation"></div>

    <div class="container-fluid main">
        <div class="row">
            <div class="col-lg-9 col-md-12 col-sm-12 col-xs-12 question-list">
                <h2>
                    <span class="glyphicon glyphicon-pushpin" aria-hidden="true"></span>
                    <span th:text="${sectionName}"></span>
                </h2>
                <hr>
                <div class="media" th:each="question : ${pagination.data}">
                    <div class="media-left">
                        <a href="#">
                            <img class="media-object img-rounded" th:src="${question.user.avatarUrl}"/>
                        </a>
                    </div>
                    <div class="media-body">
                        <h4 class="media-heading" th:text="${question.title}"></h4>
                        <span class="text-desc">
                        <a class="question-tags" href="#" th:text="${question.tag}"></a> •
                        <span th:text="${question.user.name}"></span> 发表了文章 •
                        <span th:text="${question.commentCount}"></span> 个评论 •
                        <span th:text="${question.viewCount}"></span> 次浏览 •
                        <span th:text="${#dates.format(question.gmtCreate,'yyyy-MM-dd HH:mm')}"></span>
                    </span>
                    </div>
                </div>

                <div class="comm-pagination">
                    <nav aria-label="...">
                        <ul class="pagination">
                            <li th:if="${pagination.showFirstPage}">
                                <a th:href="@{'./'+${section}(page=1)}" aria-label="Previous"><span aria-hidden="true">&lt;&lt;</span></a>
                            </li>
                            <li th:if="${pagination.showPrevPage}">
                                <a th:href="@{'./'+${section}(page=${pagination.currentPage-1})}" aria-label="Previous"><span aria-hidden="true">&lt;</span></a>
                            </li>

                            <li th:each="page : ${pagination.pages}" th:class="${pagination.currentPage == page}? 'active' : ''">
                                <a th:href="@{'./'+${section}(page=${page})}" th:text="${page}"></a>
                            </li>

                            <li th:if="${pagination.showNextPage}">
                                <a th:href="@{'./'+${section}(page=${pagination.currentPage+1})}" aria-label="Next"><span aria-hidden="true">&gt;</span></a>
                            </li>
                            <li th:if="${pagination.showLastPage}">
                                <a th:href="@{'./'+${section}(page=${pagination.totalPages})}" aria-label="Next"><span aria-hidden="true">&gt;&gt;</span></a>
                            </li>
                        </ul>
                    </nav>
                </div>
            </div>

            <div class="col-lg-3 col-md-12 col-sm-12 col-xs-12 profile">
                <div class="list-group section">
                    <a href="/profile/questions" th:class="${section == 'questions'} ? 'list-group-item active' : 'list-group-item'">
                        我的问题
                        <span class="badge" th:if="${section == 'questions'}" th:text="${pagination.totalCount}"></span>
                    </a>
                    <a href="/profile/replies" th:class="${section == 'replies'} ? 'list-group-item active' : 'list-group-item'">
                        最新回复
                        <span class="badge" th:if="${section == 'replies'}" th:text="${pagination.totalCount}"></span>
                    </a>
                </div>
            </div>
        </div>
    </div>

</body>
</html>
```

​	启动应用，访问 `http://localhost:8080/profile/questions` ，效果如下：

<img src="screenshots\87-pagination.png" style="zoom:100%;"/>





# 16、拦截器

​	对于所有需要检查用户登录状态的页面，都在控制器里做检查比较繁琐，可以利用 Spring Web 的拦截器功能。

​	自定义一个拦截器需要继承 `org.springframework.web.servlet.HandlerInterceptor` 接口，可以选择实现以下方法：

- `preHandle(..)`：在实际处理程序运行之前
- `postHandle(..)`：处理程序运行后
- `afterCompletion(..)`：完整请求完成后

该`preHandle(..)`方法返回一个布尔值。您可以使用此方法来中断或继续执行链的处理。当此方法返回时`true`，处理程序执行链将继续。当它返回 false 时，`DispatcherServlet` 假设拦截器本身已经处理了请求（例如，呈现了适当的视图）并且不会继续执行执行链中的其他拦截器和实际处理程序。

有关如何配置拦截器的示例，请参阅 MVC 配置部分中的拦截[器](https://docs.spring.io/spring-framework/docs/5.3.28/reference/html/web.html#mvc-config-interceptors)。您还可以通过在各个实现上使用 setter 直接注册它们 `HandlerMapping`。

`postHandle` 方法对于 `@ResponseBody` 和 `ResponseEntity` 方法不太有用，因为它们的响应是在 `HandlerAdapter` 内、`postHandle` 之前写入和提交的。这意味着对响应进行任何更改（例如添加额外的标头）为时已晚。或者在这种情况下，您可以实现 ResponseBodyAdvice 并将其声明为 Controller Advice bean 或直接在 RequestMappingHandlerAdapter 上配置它。

​	首先定义一个拦截器 `SessionInterceptor` ，代码如下：

```java
package life.majiang.community.interceptor;

import life.majiang.community.mapper.UserMapper;
import life.majiang.community.model.User;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

@Component
@Slf4j
public class SessionInterceptor implements HandlerInterceptor {

    @Autowired
    UserMapper userMapper;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        log.info("SessionInterceptor preHandle: set user session!");

        // 若用户已登录并记录session，直接访问视图
        HttpSession session = request.getSession();
        if (session != null && session.getAttribute("user") != null) {
            return true;
        }

        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if ("token".equals(cookie.getName())) {
                    String token = cookie.getValue();
                    User user = userMapper.getByToken(token);
                    if (user != null) {
                        request.getSession().setAttribute("user", user);
                    }
                    break;
                }
            }
        }

        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        HandlerInterceptor.super.afterCompletion(request, response, handler, ex);
    }
}
```

​	重写 `preHandle` 方法，先判断当前请求会话中是否已有用户对象属性，有则直接返回；否则会进入下面的处理，先从 Cookie 中拿到登录 token，再用该 token 从数据库查询用户数据并放到会话属性中。

​	用使用该拦截器，还要先注册，需要定义一个 `WebMvcConfigurer` 的实现类，并重写 `addInterceptor` 方法注册拦截器，代码如下：

```java
package life.majiang.community.interceptor;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Autowired
    SessionInterceptor sessionInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(sessionInterceptor).addPathPatterns("/**");
    }

}
```

​	删除 `IndexController` 拿 Cookie token 查用户再放会话的代码。

​	启动应用，访问页面，发现样式渲染有问题

<img src="screenshots\89-pagination.png" style="zoom:100%;"/>

​	发现是 `/css/community.css` 的加载有问题404 NOT FOUND，查看日志，发现页面去获取样式文件时，Spring 将其当成一个 Web 请求来处理了。

<img src="screenshots\88-pagination.png" style="zoom:100%;"/>

​	为了解决该问题，`WebMvcConfigurer` 同样提供了注册资源处理器的方法，在 `WebConfig` 中新增代码：

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    // other code
  	
    private static final String[] CLASS_RESOURCE_LOACTIONS = {
            "classpath:/META-INF/resources/",
            "classpath:/resources/",
            "classpath:/static/",
            "classpath:/public/"
    };

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/**").addResourceLocations(CLASS_RESOURCE_LOACTIONS);
    }
}

```

​	重启应用访问，页面样式渲染恢复正常。





# 17、完成问题详情页面

​	我们希望通过 `http://localhost:8080/question/12` 这种形式访问某个问题的详情页面，首先这个访问路径的 id 要传递给后端，后端根据 id 从数据库中查到对应的记录。

​	在 `QuestionMapper` 中添加查询方法：

```java
    @Select("select * from question where id = #{id}")
    Question getById(@Param("id") Integer id);
```

​	在 `QuestionService` 中添加提供控制器调用的方法，在方法中调用 mapper 方法并将 bean 转换为 dto 返回，代码如下：

```java
    public QuestionDTO getById(Integer id) {
        Question question = questionMapper.getById(id);
        QuestionDTO questionDTO = new QuestionDTO();
        BeanUtils.copyProperties(question, questionDTO);
        User user = userMapper.getById(question.getCreator());
        questionDTO.setUser(user);

        return questionDTO;
    }
```

​	新增问题控制器 `QuestionController` ，代码如下：

```java
package life.majiang.community.controller;

import life.majiang.community.dto.QuestionDTO;
import life.majiang.community.service.QuestionService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@Controller
public class QuestionController {

    @Autowired
    QuestionService questionService;

    @GetMapping("/question/{id}")
    public String question(@PathVariable(name = "id") Integer id,
                           Model model) {

        QuestionDTO questionDTO = questionService.getById(id);
        model.addAttribute("question", questionDTO);

        return "question";
    }

}
```

​	后端部分完成，前端新增页面 `question.html` ，代码如下：

```java
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title th:text="${question.title}"></title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/community.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>

<div th:insert="navigation :: navigation"></div>

<div class="container-fluid main">
    <div class="row">
        <div class="col-lg-9 col-md-12 col-sm-12 col-xs-12 question-block">
            <h3 class="question-title"><span th:text="${question.title}"></span></h3>
            <span class="text-desc">
            作者：<span th:text="${question.user != null ? question.user.name : '匿名'}"></span> |
            发布时间：<span th:text="${#dates.format(question.gmtCreate,'yyyy-MM-dd HH:mm')}"></span> |
            阅读数：<span th:text="${question.viewCount}"></span>
            </span><br>
            <hr style="margin-top: 10px">

            <div class="col-lg-12 col-md-12 col-sm-12 col-xs-12" style="padding: 0px">
                <span class="question-content" th:text="${question.description}"></span>
                <hr>
                <span class="topic-tag">
                    <a th:text="${question.tag}"></a>
                </span><br>
                <hr>
            </div><br>

            <a th:if="${session.user != null && session.user.id == question.creator}"
               th:href="@{'/publish/'+${question.id}}" class="community-menu">
                <span class="glyphicon glyphicon-pencil" aria-hidden="true">编辑</span>
            </a>
            <hr>
        </div>
        <div class="col-lg-3 col-md-12 col-sm-12 col-xs-12" style="padding: 20px">
            <h5>发起人</h5>
            <div class="media">
                <div class="media-left">
                    <a href="#">
                        <img class="media-object img-rounded" th:src="${question.user != null ? question.user.avatarUrl : '/images/xhy.jpg'}">
                    </a>
                </div>
                <div class="media-body">
                    <h5 class="media-heading" th:text="${question.user != null ? question.user.name : '匿名'}"></h5>
                    <span class="text-desc">
                        <span th:text="${question.user != null} ? ${question.user.bio} : '这个人很神秘'"/>
                    </span>
                </div>
            </div>
            <hr>
            <h4>相关问题</h4>
        </div>
    </div>
</div>

</body>
</html>
```

​	访问首页，点击标题即可进入问题详情页

<img src="screenshots\90-question.png" style="zoom:100%;"/>

​	问题详情页的展现如下：

<img src="screenshots\91-question.png" style="zoom:100%;"/>





# 18、修复登录bug

​	在原来的登录处理中，每次登录都会往用户表插入一条数据，导致同一用户的多次登录产生多条数据

<img src="screenshots\95-loginout.png" style="zoom:90%;"/>

​	这会导致用户下次登录后无法编辑自己上次登录发布的问题，所以在原来往用户表插数的逻辑应该优化为，若用户之前登录过，则更新除了用户 github 账户ID外的其他信息；若用户没登过，才实际插入一条数据的逻辑。

​	为了方便处理逻辑的复用，以及调用代码的间接，首先定义一个 `UserService` 的服务类，代码如下：

```java
package life.majiang.community.service;

import life.majiang.community.mapper.UserMapper;
import life.majiang.community.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    @Autowired
    private UserMapper userMapper;

    public void createOrUpdate(User user) {
        User dbUser = userMapper.getByAccountId(user.getAccountId());
        if (dbUser == null) {
            // 用户尚未授权登录过，插表
            userMapper.insert(user);
        } else {
            // 用户授权登录过，更新用户信息
            dbUser.setName(user.getName());
            dbUser.setToken(user.getToken());
            dbUser.setGmtModified(user.getGmtModified());
            dbUser.setBio(user.getBio());
            dbUser.setAvatarUrl(user.getAvatarUrl());
            userMapper.update(dbUser);
        }

    }
}
```

​	之前 `UserMapper` 还没有更新数据的 SQL，因此在 mapper 中新增对应方法：

```java
    @Update("update c_user set name = #{name}, token = #{token}, gmt_modified = #{gmtModified}, bio = #{bio}, avatar_url = #{avatarUrl} where account_id = #{accountId}")
    public void update(User dbUser);
```

​	最后修改 `AuthorizeController` 的回调方法，将获取到 github 账户信息后由直接插入改为调用 `UserService` 的方法：

```java
userService.createOrUpdate(user);
//userMapper.insert(user);
```

​	在用户登录后的导航栏，点击用户会显示下拉列表，其中有个退出登录的功能，需要编写针对 `/logout` 请求的控制器方法，在授权控制器中新增登出方法，代码如下：

```java
    // 用户登出
    @GetMapping("/logout")
    public String logout(HttpServletRequest request,
                         HttpServletResponse response) {
        // 清除用户会话
        request.removeAttribute("user");

        // 清除cookie
        Cookie cookie = new Cookie("token", null);
        cookie.setMaxAge(0);
        cookie.setPath("/");
        response.addCookie(cookie);

        return "redirect:/";
    }
```

​	在用户登录后，可看到 cookies 中的 token

<img src="screenshots\92-loginout.png" style="zoom:100%;"/>

​	在点击用户退出登录后，再查看 cookie token 信息已被清空

<img src="screenshots\93-loginout.png" style="zoom:100%;"/>

​	启动应用，登录，报错，发现是查询用户返回了多个数据

<img src="screenshots\94-loginout.png" style="zoom:100%;"/>

​	查询发现相同的 accountId 的数据有两条，删除第一条数据

<img src="screenshots\95-loginout.png" style="zoom:100%;"/>

​	重新登录，点击消息中心，可以看到重新登录后，用户依然可以编辑之前发布的问题，用户表更新了时间和token，并没实际插入数据

<img src="screenshots\97-loginout.png" style="zoom:100%;"/>

<img src="screenshots\98-loginout.png" style="zoom:100%;"/>





# 19、实现问题编辑功能

​	对某个以及发布的问题信息进行编辑修改，首先要回显问题信息，在 `PublishController` 中新增编辑方法，代码如下：

```java
    @GetMapping("/publish/{id}")
    public String edit(@PathVariable(name = "id") Integer id,
                       Model model) {
        QuestionDTO question = questionService.getById(id);
        model.addAttribute("title", question.getTitle());
        model.addAttribute("description", question.getDescription());
        model.addAttribute("tag", question.getTag());
        model.addAttribute("id", question.getId());

        return "publish";
    }
```

​	当提交修改时，可以复用原来的 `doPublish` 方法，更新问题信息也需要将 id 上送给该方法，所以修改方法头，新增入参，因为该方法要复用问题发布和编辑，所以新的参数要声明为 `required = false` ，同时原来插入的问题表的代码也要调整为，若上送id则更新；否则插入。所以要先在 `QustionService` 中新增方法如下：

```java
    public void createOrUpdate(Question question) {
        if (question.getId() == null) {
            question.setGmtCreate(System.currentTimeMillis());
            question.setGmtModified(question.getGmtCreate());
            questionMapper.insert(question);
        } else {
            question.setGmtModified(question.getGmtCreate());
            questionMapper.update(question);
        }
    }
```

​	在 `QuestionMapper` 中新增方法：

```java
    @Update("update question set title = #{title}, description = #{description}, tag = #{tag}, gmt_modified = #{gmtModified} where id = #{id}")
    void update(Question question);
```

​	最后修改 `PublishController` ：

```java
    @PostMapping("/publish")
    public String doPublish(@RequestParam(value = "title", required = true) String title,
                            @RequestParam(value = "description", required = true) String description,
                            @RequestParam(value = "tag", required = true) String tag,
                            @RequestParam(value = "id", required = false) Integer id,
                            HttpServletRequest request,
                            Model model) {
        // 方便页面回显，这样页面已经填了的信息不用再重填一次
        model.addAttribute("title", title);
        model.addAttribute("description", description);
        model.addAttribute("tag", tag);
        model.addAttribute("id", id);

        if (StringUtils.isEmpty(title)) {
            model.addAttribute("error", "标题不能为空");
            return "publish";
        }
        if (StringUtils.isEmpty(description)) {
            model.addAttribute("error", "问题补充不能为空");
            return "publish";
        }
        if (StringUtils.isEmpty(tag)) {
            model.addAttribute("error", "标签不能为空");
            return "publish";
        }

        // 如果cookie中不存在token，或根据token查无用户，则返回报错
        if (request.getSession() == null || request.getSession().getAttribute("user") == null) {
            model.addAttribute("error", "用户未登录");
            return "publish";
        }

        User user = (User) request.getSession().getAttribute("user");
        // 记录提交问题带数据库
        Question question = new Question();
        question.setTitle(title);
        question.setDescription(description);
        question.setCreator(user.getId());
        question.setTag(tag);
        //questionMapper.insert(question);
        questionService.createOrUpdate(question);

        return "redirect:/";
    }
```

​	启动应用，访问某个问题 

<img src="screenshots\99-edit.png" style="zoom:100%;"/>

​	提交修改时却返回 tomcat 报错 `Request header is too large ` ，原因是默认的 HTTP 请求头部数据大小为8KB，超过这一大小就会报错，所以调整该参数为100KB

<img src="screenshots\100-edit.png" style="zoom:100%;"/>

​	重新进入编辑页面，再次提交修改，不会再报上述错误。



# 20、MyBatis Generator

【官网】https://mybatis.org/generator/quickstart.html

【掘金】https://juejin.cn/post/6844904116422983694





















































```sql
-- auto-generated definition
create table QUESTION
(
    ID            INTEGER auto_increment
        primary key,
    TITLE         CHARACTER VARYING(50),
    DESCRIPTION   CHARACTER LARGE OBJECT,
    GMT_CREATE    BIGINT,
    GMT_MODIFIED  BIGINT,
    CREATOR       INTEGER,
    COMMENT_COUNT INTEGER default 0,
    VIEW_COUNT    INTEGER default 0,
    LIKE_COUNT    INTEGER default 0,
    TAG           CHARACTER VARYING(256)
);

comment on column QUESTION.TITLE is '问题标题';
comment on column QUESTION.GMT_CREATE is '创建时间';
comment on column QUESTION.GMT_MODIFIED is '修改时间';
comment on column QUESTION.CREATOR is '创建者';
comment on column QUESTION.COMMENT_COUNT is '评论数';
comment on column QUESTION.VIEW_COUNT is '阅读数';
comment on column QUESTION.LIKE_COUNT is '点赞数';
comment on column QUESTION.TAG is '标签';
```









# 【附录】

## 1、Spring 功能集成

访问：https://spring.io/guides

在简明教程列表中选择要集成的功能：

<img src="screenshots\8-SpringGuides.png" style="zoom:100%;"/>






## 2、文档

* [Spring文档](https://spring.io/guides)

  * [Spring Boot](https://docs.spring.io/spring-boot/docs/current/reference/html/index.html)

    * [Spring Boot DataSource](https://docs.spring.io/spring-boot/docs/current/reference/html/data.html)
    * [Spring Boot Mybatis](https://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/zh/index.html)


    * [Spring Boot Devtools](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools)

  * [Spring Web](https://docs.spring.io/spring-framework/docs/5.3.28/reference/html/web.html#spring-web)

    * [Interception](https://docs.spring.io/spring-framework/docs/5.3.28/reference/html/web.html#mvc-handlermapping-interceptor)

* [Thymeleaf 官方文档](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html)

  * [Thymeleaf模板](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#including-template-fragments)

* [Bootstrap](https://v3.bootcss.com/)

* [Github OAuth](https://docs.github.com/zh/apps/oauth-apps/building-oauth-apps)

* [H2](https://www.h2database.com/html/main.html)

* [Flyway](https://documentation.red-gate.com/fd)

* [lombok](https://projectlombok.org/features/)

* [MyBatis](https://mybatis.org/mybatis-3/zh/index.html)
  * [MyBatis Generator](https://mybatis.org/generator/quickstart.html)



## 3、工具






















```json
{
    "login":"huyihao",
    "id":11757351,
    "node_id":"MDQ6VXNlcjExNzU3MzUx",
    "avatar_url":"https://avatars.githubusercontent.com/u/11757351?v=4",
    "gravatar_id":"",
    "url":"https://api.github.com/users/huyihao",
    "html_url":"https://github.com/huyihao",
    "followers_url":"https://api.github.com/users/huyihao/followers",
    "following_url":"https://api.github.com/users/huyihao/following{/other_user}",
    "gists_url":"https://api.github.com/users/huyihao/gists{/gist_id}",
    "starred_url":"https://api.github.com/users/huyihao/starred{/owner}{/repo}",
    "subscriptions_url":"https://api.github.com/users/huyihao/subscriptions",
    "organizations_url":"https://api.github.com/users/huyihao/orgs",
    "repos_url":"https://api.github.com/users/huyihao/repos",
    "events_url":"https://api.github.com/users/huyihao/events{/privacy}",
    "received_events_url":"https://api.github.com/users/huyihao/received_events",
    "type":"User",
    "site_admin":false,
    "name":"codedog",
    "company":null,
    "blog":"",
    "location":null,
    "email":"1123176978@qq.com",
    "hireable":null,
    "bio":"a simple codedog",
    "twitter_username":null,
    "public_repos":18,
    "public_gists":0,
    "followers":0,
    "following":2,
    "created_at":"2015-04-01T16:18:30Z",
    "updated_at":"2023-05-09T13:14:10Z",
    "private_gists":0,
    "total_private_repos":5,
    "owned_private_repos":5,
    "disk_usage":2023496,
    "collaborators":0,
    "two_factor_authentication":false,
    "plan":{
        "name":"free",
        "space":976562499,
        "collaborators":0,
        "private_repos":10000
    }
}
```







# 使用MyBatis Generator

1、引入插件

```xml
<project>
  ...
  <build>
    ...
    <plugins>
      ...
      <plugin>
		<groupId>org.mybatis.generator</groupId>
		<artifactId>mybatis-generator-maven-plugin</artifactId>
		<version>1.3.7</version>
      </plugin>
    </plugins>
  </build>
</project>
```



2、执行maven命令（生成执行 MyBatis 需要的 model 和 mapper 文件）

```shell
# -Dmybatis.generator.overwrite=true 表示生成的文件是否覆盖原文件，不覆盖则生成文件为 MyClass.java.1
mvn mybatis-generator:generate -Dmybatis.generator.overwrite=true
```



3、创建配置文件

【默认路径】src/main/resources/generatorConfig.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
<generatorConfiguration>
    <context id="simple" targetRuntime="MyBatis3">
        <!-- 配置数据库连接，MBG才知道去连接哪个数据库获取表信息 -->
        <jdbcConnection driverClass="org.h2.Driver"
                        connectionURL="jdbc:h2:~/community"
                        userId="root"
                        password="root"/>

        <!-- 配置生成的Java Model类要放在哪个目录哪个包中 -->
        <javaModelGenerator targetPackage="life.majiang.community.model" targetProject="src/main/java"/>

        <!-- 配置生成的mapper.xml存放位置 -->
        <sqlMapGenerator targetPackage="mapper" targetProject="src/main/resources"/>

        <!-- ava 客户端生成器构建 Java 接口和类，以便轻松使用生成的 Java 模型和 XML 映射文件。 -->
        <javaClientGenerator type="XMLMAPPER" targetPackage="life.majiang.community.mapper" targetProject="src/main/java"/>

        <!-- 配置要扫描哪些表生成文件 -->
        <table tableName="cuser" domainObjectName="User"/>
    </context>
</generatorConfiguration>
```





# 1、Spring Error Handler

​	默认情况下，Spring Boot 提供了一个 `/error` 映射，以合理的方式处理所有错误，并且它在 servlet 容器中被注册为一个“全局”的错误页面。对于机器客户端，它会生成一个 JSON 响应，其中包含错误、HTTP 状态和异常消息的详细信息。对于浏览器客户端，有一个“白标签”错误视图以 HTML 格式呈现相同的数据（要自定义它，请添加一个解析错误的视图）。

​	要替代默认的异常报错白页，可以在 `/src/main/resources/templates` 目录下创建一个 error.html 的错误页，代码如下所示：

```html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>鸭鸭社区</title>
    <meta http-equiv="content-type" content="text/html" charset="UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/community.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>
<div th:insert="navigation :: navigation"></div>

<div class="container-fluid">
    <div class="jumbotron">
        <h1>出错啦！！！</h1>
        <p>服务太热啦，要不然稍等下再来试试~</p>
        <p><a class="btn btn-primary btn-lg" href="/" role="button">回到主页</a></p>
    </div>
</div>
</body>
</html>
```

​	启动应用，访问 `http://localhost:8080/question/301`，不存在ID为301的问题，所以访问该页面应该跳到错误白页，因为我们自定义了错误页，所以会访问 error.html，效果如下：

<img src="screenshots/替换报错白页.png"/>

​	但是页面上只是显示固定的报错信息，我们希望有个组件可以拦截异常报错，并且把异常信息渲染展现到页面上。

