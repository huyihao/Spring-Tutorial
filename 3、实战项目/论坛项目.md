# 1、创建 SpringBoot 项目

## （1）快捷创建项目

​	这里我使用的是IDEA 付费版本【IntelliJ IDEA 2023.1.2 (Ultimate Edition)】，学习该花的钱不要省（嘿嘿，当然某宝也有物美价廉的方案），已经安装好了齐全的 Spring 插件（File -> Settings -> Plugins），这里创建项目用到了 Spring Initializr。

<img src="screenshots\1-IDEA-SpringPlugins.png" style="zoom:80%;"/>

​	File -> New -> New Project，选择 Spring Initializr 来初始化项目，注意一些关键信息要填好。

<img src="screenshots\2-Init-SpringBoot.png" style="zoom:80%;"/>

​	进入下一步，选择 Spring Boot 版本，添加项目用到的 SpringBoot Starter，先选 web，后面用到其他的可以手动添加。

<img src="screenshots\3-Add-SpringBootStarter.png" style="zoom:80%;"/>





## （2）工程目录文件简介

<img src="screenshots\4-ProjectDetails.png" style="zoom:80%;"/>

* **pom.xml**

  ​	Maven 项目依赖管理文件，默认生成的 pom.xml 会以 spring-boot-starter-parent 为父工程，将使用的版本修改为 2.1.4.RELEASE（跟教学视频保持一致），这样下面引用各种 SpringBoot Starter 时就不需要显式指定依赖版本，因为父工程已经指定好了版本，如下所示：

<img src="screenshots\5-SpringBootPom.png" style="zoom:80%;"/>

​	可以看到创建工程时勾选的 web starter，除此之外，还自动引入了 test starter，用于编写对 Spring Boot 的测试代码；在构建插件中，还自动引入了 spring-boot-maven-plugin，用于对工程进行构建打包。

* **.gitignore**

  ​	定义工程中忽略的文件和目录，这些文件和目录在提交代码入库时不会会被忽略，比如 IDE 自动生成的文件和目录，生成编译代码的文件和目录等。

* **HELP.md**

  ​	在 github 上进入一个项目时会有一个简介，github 会自动加载仓库根目录的 README.md 文档并渲染到网页上，这里先把 HELP.md 重命名为 README.md，然后在文档中添加对项目的介绍，包括功能、安装和使用步骤等。

* **src/main/java**

  ​	存放 java 代码的目录，这里已经按照初始化时指定的配置生成了一个代码包 `life.majiang.community`，并且自动创建了工程主类 `CommunityApplication.java`，启动它即可将工程跑起来。

  ​	一般情况下，我们会在 `life.majiang.community` 下创建新的包，比如 `life.majiang.community.controller`、`life.majiang.community.service` 等，因为工程启动时默认会扫描主类包及其子包中所有使用了 Spring 注解定义的 Bean（常用的注解有 `@Controller`、`@Component`、`@Service`等），当然也可以不这样做，比如定义一个新的包 `life.majiang.controller` ，这样要对包扫描时，需要在主类中显式指定要扫描的包。

* **src/main/resources**

  ​	存放工程的资源文件，默认有 static、templates 两个子目录，还有一个 application.properties 文件。

  ​	static 用来存放网站需要的静态文件，比如图片、css样式文件、javascript脚本文件等，一般会在 static 下再建不同的子目录区分，比如 static/images、static/css、static/js。

  ​	templates 用来存放网站需要的模板文件，当然流行的前后端分离一般已经不再使用模板，这里我们使用的引擎是 thymeleaf，后面还要引入相关的依赖。

  ​	application.properties 文件用来配置 Spring Boot 支持的各种参数，比如 web 服务对外暴露端口的参数为 `server.port`，默认值为 8080，如果要修改为 8081，在配置文件中编写如下一行键值对配置即可：

```properties
server.port=8081
```

* **src/main/test**

  ​	存放工程的测试代码，在严格执行单元测试的开发管理中，一个类要有一个对应的 Test 测试类，测试类所处包跟类相同。





## （3）运行工程

​	启动主类，可以看到日志中显示 SpringBoot 工程中嵌入了 Tomcat 服务器，默认启动的端口是 8080。

<img src="screenshots\6-SpringBootStart.png" style="zoom:100%;"/>

​	访问下 http://localhost:8080，可以看到显示的是默认的报错白页，因为此时我们还没编写任何的处理响应的控制器，Spring 找不到处理响应的程序，就只能返回一个 404 的报错。

<img src="screenshots\7-SpringBootStart.png" style="zoom:100%;"/>





# 2、集成 thymeleaf 

​	在 https://spring.io/guides 中找到快捷接入指引：https://spring.io/guides/gs/serving-web-content/

​	首先要引入 thymeleaf 模板引擎对应的 starter，在工程 pom.xml 中添加：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```

​	在启动类所在包下创建一个子包 `life.majiang.community.controller`，并创建一个 HelloController，负责响应 Web 请求，代码如下：

```java
package life.majiang.community.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
public class HelloController {

    @GetMapping("/hello")
    public String hello(@RequestParam(name = "name") String name, Model model) {
        model.addAttribute("name", name);
        return "hello";
    }

}
```

​	首先控制器要使用 `@Controller` 注解，在控制器中创建一个 `hello` 方法，使用 `@GetMapping("/hello")` 表示该方法会响应对 "/hello" 的 GET 请求。

​	请求可能通过 URL 传递参数进来，比如 "/hello?name=hyh"，为了获取参数，在方法头添加 `@RequestParam(name = "name") String name`，表示会从 URL 中获取参数名为 name 的参数并传递给方法入参。

​	我们可能还需要将后端处理好的数据传递给前端，所以给方法添加一个 Model 参数，往 model 对象中添加属性，这些属性能随着响应传递到前端页面模板。

​	最后返回一个 `"hello"` 字符串，因为我们使用了 thymeleaf 模板引擎，所以会自动从资源模板目录 `src/main/resources/templete` 中找到 hello.html，IDEA 会自动提示找不到这个 MVC 视图

<img src="screenshots\9-mvc-view.png" style="zoom:100%;"/>

​	所以接下来到模板目录中创建 hello.html，代码如下：

```html
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Getting Started: Serving Web Content</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>
<body>
    <p th:text="'Hello, ' + ${name} + '!'" />
</body>
</html>
```

​	首先要引入模板引擎的 namespace，告诉 Spring 页面中的 `th` 要使用 Thymeleaf 引擎解析处理，`th:text="'Hello, ' + ${name} + '!'"` 表示要拼接一个字符串渲染到 `<p> ` 标签中，拼接的字符串中 `${name}` 来自后端控制器方法中通过 model 传递给模板处理的属性。

​	访问 `http://localhost:8080/hello?name=hyh` ，响应还是白页

<img src="screenshots\11-没开启自动导入导致的报错.png" style="zoom:100%;"/>

​	看看服务端有什么报错

<img src="screenshots\12-视图解析异常.png" style="zoom:100%;"/>

 	可以看到解析 `hello` 的视图失败，看一下是不是新增的依赖没有自动导入的问题

<img src="screenshots\13-未自动导入maven包.png" style="zoom:80%;"/>

​	可以看到没有我们新引入的 thymeleaf 的依赖，点击左上角的 "Reload All Maven Projects"，才看到依赖真正导入了

<img src="screenshots\14-thmeleaf.png" style="zoom:70%;"/>

​	重启应用再访问，可以看到正常的响应了。

<img src="screenshots\10-hello.png" style="zoom:100%;"/>

​	为了避免在引入新依赖时再次遇到该问题，需要设置 maven 的 auto import，步骤如下

<img src="screenshots\15-maven-autoimport.png" style="zoom:60%;"/>

<img src="screenshots\16-maven-autoimport.png" style="zoom:60%;"/>





# 3、引入 Bootstrap

【Bootstrap】https://v3.bootcss.com/

【样式】https://v3.bootcss.com/css/

【组件】https://v3.bootcss.com/components/

​	下载压缩包

<img src="screenshots\17-bootstrap.png" style="zoom:60%;"/>

​	将压缩包内的 css、fonts、js 目录拷贝到工程的静态资源目录下

<img src="screenshots\18-bootstrap.png" style="zoom:60%;"/>

​	因为这里引用的 Bootstrap V3 是依赖 JQuery 的，所以在 js 目录下还要有 jquery.js，并且在 html 中引入 js 的顺序要先于 bootstrap.js

<img src="screenshots\19-bootstrap.png" style="zoom:100%;"/>





# 4、创建导航栏

​	我们使用 Bootstrap 自带的组件实现一个网站导航栏，从组件库中将默认的导航条样式引入，再在其基础上修改，调整为想要的功能和菜单。

<img src="screenshots\20-bootstrap.png" style="zoom:100%;"/>

​	调整后的新增 index.html 如下：

```html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>鸭鸭社区</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>
    <nav class="navbar navbar-default">
        <div class="container-fluid">

            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                    <span class="sr-only">鸭鸭社区</span>
                </button>
                <a class="navbar-brand" href="/">鸭鸭社区</a>
            </div>

            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <form class="navbar-form navbar-left">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="搜索问题">
                    </div>
                    <button type="submit" class="btn btn-default">搜索</button>
                </form>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="#">登录</a></li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">我 <span class="caret"></span></a>
                        <ul class="dropdown-menu">
                            <li><a href="#">消息中心</a></li>
                            <li><a href="#">个鸭资料</a></li>
                            <li><a href="#">退出登录</a></li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </nav>
</body>
</html>
```

​	新增控制器 IndexController，增加对 `/` 请求的处理，并最后渲染视图 index。

```java
package life.majiang.community.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class IndexController {
    @GetMapping("/")
    public String index() {
        return "index";
    }
}
```

​	完成开发后启动应用，网页访问 `http://localhost:8080/` ，效果如下所示：

<img src="screenshots\21-bootstrap.png" style="zoom:100%;"/>





# 5、Github OAuth 登录开发

​	先找文档在哪里，一般有提供 API 的网站，都能在网站上找到对应的入口

<img src="screenshots\22-github.png" style="zoom:100%;"/>

​	进入可以看到开发者选项，REST API

<img src="screenshots\23-github.png" style="zoom:100%;"/>

<img src="screenshots\24-github.png" style="zoom:60%;"/>

## （1）创建 OAuth 应用

​	登录上 Github，在页面的右上方，单击个人资料照片，然后点击 "Settings"

<img src="screenshots\26-github.png" style="zoom:60%;"/>

​	在左边栏中，点击 Developer settings

<img src="screenshots\27-github.png" style="zoom:100%;"/>

​	点击右侧边栏的 OAuth Apps

<img src="screenshots\28-github.png" style="zoom:60%;"/>

​	点击 "New OAuth App"，填写应用信息：

1、在“Application name（应用程序名称）”中，输入应用程序的名称；

2、在“Homepage URL（主页 URL）”中，输入应用程序网站的完整 URL；

3、（可选）在“Application description（应用程序说明）”中，输入用户将看到的应用程序说明；

4、在“Authorization callback URL（授权回调 URL）”中，输入应用程序的回调 URL。

​	然后点击 "Register application"

<img src="screenshots\29-github.png" style="zoom:100%;"/>

​	创建应用的时候，会自动生成一个客户端ID，这个是不变的，还需要自行点击生成一个客户端密钥，这个是可以重新生成的

<img src="screenshots\30-github.png" style="zoom:100%;"/>

​	点击 "Update application"，至此完成应用创建

<img src="screenshots\31-github.png" style="zoom:65%;"/>





## （2）OAuth 处理流程

> **① 通过 GET 请求调用授权接口，获得动态生成的授权码，接口和报文如下**

```shell
GET https://github.com/login/oauth/authorize
```

| 参数名称         | 类型     | 说明                                       |
| ------------ | ------ | ---------------------------------------- |
| client_id    | string | “必需”。 [注册](https://github.com/settings/applications/new)时从 GitHub 收到的客户端 ID。 |
| redirect_uri | string | 用户获得授权后被发送到的应用程序中的 URL。 请参阅以下有关[重定向 URL](https://docs.github.com/zh/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps#redirect-urls) 的详细信息。 |
| login        | string | 提供用于登录和授权应用程序的特定账户。                      |
| scope        | string | [范围](https://docs.github.com/zh/apps/oauth-apps/building-oauth-apps/scopes-for-oauth-apps)的空格分隔列表。 如果未提供，则 `scope` 默认为未授权应用程序的任何范围的用户的空列表。 对于已向应用程序授权作用域的用户，不会显示含作用域列表的 OAuth 授权页面。 相反，通过用户向应用程序授权的作用域集，此流程步骤将自动完成。 例如，如果用户已经执行了两次 Web 流，并且已授权一个具有 `user` 范围的令牌和另一个具有 `repo` 范围的令牌，则不提供 `scope` 的第三个 Web 流将收到具有 `user` 和 `repo` 范围的令牌。 |
| state        | string | 不可猜测的随机字符串。 它用于防止跨站请求伪造攻击。               |
| allow_signup | string | 在 OAuth 流程中，是否向经过验证的用户提供注册 GitHub 的选项。 默认为 `true`。 在策略禁止注册时使用 `false`。 |



> **② 拿到动态生成的授权码后，`code` 作为访问令牌，跟生成的客户端ID和密钥一并上送获得 access_token 的接口**

```shell
POST https://github.com/login/oauth/access_token
```

| 参数名称          | 类型     | 说明                                      |
| ------------- | ------ | --------------------------------------- |
| client_id     | string | **必填。** 从 GitHub 收到的 OAuth app 的客户端 ID。 |
| client_secret | string | **必填。** 从 GitHub 收到的 OAuth app 的客户端密码。  |
| code          | string | **必填。** 收到的作为对步骤 1 的响应的代码。              |
| redirect_uri  | string | 用户获得授权后被发送到的应用程序中的 URL。                 |

得到的响应报文形式如下：

```
access_token=gho_16C7e42F292c6912E7710c838347Ae178B4a&scope=repo%2Cgist&token_type=bearer
```

如果在 `Accept` 标头中提供格式，则还可以接收不同格式的响应。 例如 `Accept: application/json` 或 `Accept: application/xml`：

```
Accept: application/json
{
  "access_token":"gho_16C7e42F292c6912E7710c838347Ae178B4a",
  "scope":"repo,gist",
  "token_type":"bearer"
}
```

```
Accept: application/xml
<OAuth>
  <token_type>bearer</token_type>
  <scope>repo,gist</scope>
  <access_token>gho_16C7e42F292c6912E7710c838347Ae178B4a</access_token>
</OAuth>
```



> **③ 使用访问令牌访问 API**

访问令牌可用于代表用户向 API 提出请求。

```
Authorization: Bearer OAUTH-TOKEN
GET https://api.github.com/user
```

例如，您可以像以下这样在 curl 中设置“授权”标头：

```
curl -H "Authorization: Bearer OAUTH-TOKEN" https://api.github.com/user
```

可以在 github 设置生成测试的 token

<img src="screenshots\32-github-testtoken.png" style="zoom:80%;"/>

作用域勾选用户

<img src="screenshots\33-scope.png" style="zoom:80%;"/>

生成 Personal access token 后，可以通过 Postman 对其进行测试<img src="screenshots\34-githubuser.png" style="zoom:80%;"/>





## （3）实战

​	首先要获得授权码，在首页登录按钮配置调整获得授权码的 URL，如下所示：

```html
...
<ul class="nav navbar-nav navbar-right">
   <li><a href="https://github.com/login/oauth/authorize?client_id=ce46b85af14a2d21447b&redirect_uri=http://localhost:8080/callback&scope=user&state=2">登录</a></li>
    
...
```

​	启动应用，访问首页点击登录，看下效果：

<img src="screenshots\32-gitoauth.png" style="zoom:65%;"/>

​	会从当前页面自动跳转到 github 的授权登录页，点击授权，会回调到设定的回调地址，并且回调的同时，返回授权码 code 和跨域用到的 state 字段。

<img src="screenshots\33-gitoauth.png" style="zoom:65%;"/>

​	但是由于暂时没开发响应授权回调的控制器程序，所以会报白页错误。

​	接下来要编写响应回调的程序，首先要编写专门负责向 Github OAuth 接口发起请求的程序，为方便发送和接收数据，先定义两个 DTO 类。

```java
package life.majiang.community.provider.dto;

import lombok.Data;

@Data
public class AccessTokenDTO {
    private String client_id;
    private String client_secret;
    private String code;
    private String redirect_uri;
    private String state;
}

package life.majiang.community.provider.dto;

import lombok.Data;

@Data
public class GithubUser {
    private Long id;
    private String name;
    private String bio;
    private String avatar_url;
}
```

​	`AccessTokenDTO` 类在请求 OAuth 接口获得 accessToken 时用到；`GithubUser` 类对应获取授权 Github 用户数据时用到。

​	发起 HTTP 请求用的是 OK HTTP，同时用到了 fastjson 来处理对象和 JSON 字符串的转换，lombok 方便类编写，先引入依赖：

```xml
<dependency>
	<groupId>com.squareup.okhttp3</groupId>
	<artifactId>okhttp</artifactId>
	<version>3.14.1</version>
</dependency>
<dependency>
	<groupId>com.alibaba</groupId>
	<artifactId>fastjson</artifactId>
	<version>1.2.57</version>
</dependency>
<dependency>
	<groupId>org.projectlombok</groupId>
	<artifactId>lombok</artifactId>
	<scope>provided</scope>
</dependency>
```

​	负责请求的组件类 GithubProvider 定义如下：

```java
package life.majiang.community.provider;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.PropertyNamingStrategy;
import com.alibaba.fastjson.parser.ParserConfig;
import life.majiang.community.provider.dto.AccessTokenDTO;
import life.majiang.community.provider.dto.GithubUser;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;
import org.springframework.stereotype.Component;
import java.io.IOException;

@Component
@Slf4j
public class GithubProvider {

    // 获取accessToken
    public String getAccessToken(AccessTokenDTO accessTokenDTO) {
        MediaType mediumType = MediaType.get("application/json; charset=utf-8");

        OkHttpClient client = new OkHttpClient();
        RequestBody body = RequestBody.create(mediumType, JSON.toJSONString(accessTokenDTO));
        Request request = new Request.Builder()
                .url("https://github.com/login/oauth/access_token")
                .post(body)
                .build();
        try (Response response = client.newCall(request).execute()) {
            String string = response.body().string();
            log.info("Get access token response: " + string);
            String token = string.split("&")[0].split("=")[1];
            return token;
        } catch (IOException e) {
            log.error("Get access token exception: {}", e);
        }
        return null;
    }

    // 获取用户信息
    public GithubUser getGithubUser(String accessToken) {
        OkHttpClient client = new OkHttpClient();
        Request request = new Request.Builder()
                                     .url("https://api.github.com/user")
                                     .addHeader("Authorization", "Bearer " + accessToken)
                                     .build();
        try (Response response = client.newCall(request).execute()) {
            String string = response.body().string();
            log.info("Get github user response: " + string);
            ParserConfig.getGlobalInstance().propertyNamingStrategy = PropertyNamingStrategy.SnakeCase;
            GithubUser githubUser = JSON.parseObject(string, GithubUser.class);
            return githubUser;
        } catch (IOException e) {
            log.error("Get github user exception: {}", e);
        }
        return null;
    }

}
```

​	创建授权控制器 `AuthorizeController` ，接收 Github 的回调后，先获得 accessToken，再用 accessToken 去获取用户信息。

​	在控制器中，要用到 OAuth App 的客户端ID和密钥，已经回调地址，将其放在配置文件 application.properties 中避免硬编码。

```properties
...
# Github OAuth
github.client.id=xxxxxxxxxxxxxx
github.client.secret=xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
github.redirect.uri=http://localhost:8080/callback
...
```

```java
package life.majiang.community.controller;

import life.majiang.community.provider.GithubProvider;
import life.majiang.community.provider.dto.AccessTokenDTO;
import life.majiang.community.provider.dto.GithubUser;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
@Slf4j
public class AuthorizeController {

    @Value("${github.client.id}")
    private String clientId;

    @Value("${github.client.secret}")
    private String clientSecret;

    @Value("${github.redirect.uri}")
    private String redirectUrl;

    @Autowired
    private GithubProvider githubProvider;

    @GetMapping("/callback")
    public String callback(@RequestParam(name = "code") String code,
                           @RequestParam(name = "state") String state) {
        AccessTokenDTO accessTokenDTO = new AccessTokenDTO();
        accessTokenDTO.setClientId(clientId);
        accessTokenDTO.setClientSecret(clientSecret);
        accessTokenDTO.setCode(code);
        accessTokenDTO.setState(state);
        accessTokenDTO.setRedirectUri(redirectUrl);
        log.info("AccessTokenDTO = " + accessTokenDTO);

        String accessToken = githubProvider.getAccessToken(accessTokenDTO);
        GithubUser githubUser = null;
        if (accessToken != null) {
            githubUser = githubProvider.getGithubUser(accessToken);
        }

        if (githubUser != null && githubUser.getId() != null) {
            log.info("Github OAuth succ");
            return "redirect:/";
        } else {
            // 登录失败，重新登录
            return "redirect:/";
        }
    }

}
```

​	启动应用，在首页上点击登录页面，可以看到打印出来的日志，登录成功了，获取到了用户信息。

<img src="screenshots\34-gitoauth.png" style="zoom:100%;"/>

 



# 6、登录会话

​	先说说 cookie 和 session，cookie 是浏览器端会保存的一小块数据缓存，每次用户从浏览器发起新的请求时，会将 cookie 中的数据全部一并发送到服务端，在服务端，通过 `HttpServletRequest` 对象获取请求头部可以拿到 cookie 信息。

​	session 是会话的意思，用户每次登录后，在网站内浏览任意一个页面都应该能够保持登录状态。所以用户每次登录后，要生成一个用户的会话信息ID，并且在登录成功后响应时将其设置到浏览器的 cookie 中，这样后续每次用户访问，服务端都能根据ID拿到用户的会话信息，进而可以判断是哪个用户及其相关登录信息。

​	所以在 Github OAuth 登录成功后，应该设置用户 session，修改授权控制器代码：

```java
    @GetMapping("/callback")
    public String callback(@RequestParam(name = "code") String code,
                           @RequestParam(name = "state") String state,
                           HttpServletRequest request) {
...
        if (githubUser != null && githubUser.getId() != null) {
            log.info("Github OAuth succ");
            // 设置用户登录会话
            request.getSession().setAttribute("user", githubUser);
            return "redirect:/";
        } else {
            // 登录失败，重新登录
            return "redirect:/";
        }
...
    }
```

​	同时页面模板要配合修改，当用户已经登录时，就不应该显示【登录】按钮，同时要显示拿到的 Github 用户名。

```html
<li th:if="${session.user == null}"><a href="https://github.com/login/oauth/authorize?client_id=ce46b85af14a2d21447b&redirect_uri=http://localhost:8080/callback&scope=user&state=2">登录</a></li>
<li th:if="${session.user != null}" class="dropdown">
	<a th:text="${session.user.name}" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">我 <span class="caret"></span></a>
	<ul class="dropdown-menu">
		<li><a href="#">消息中心</a></li>
		<li><a href="#">个鸭资料</a></li>
		<li><a href="#">退出登录</a></li>
	</ul>
</li>
```

​	重启应用，测试效果。

<img src="screenshots\35-gitoauth.png" style="zoom:100%;"/>

​	后面每次刷新页面，都会显示用户名，屏蔽登录按钮。





# 7、集成 H2 

​	H2 是一个用 Java 开发的嵌入式数据库管理系统，在本地开发中，可以使用 H2 作为数据库，方便本地开发测试。

在 IDEA 上使用 Database 组件，创建 H2 数据源

<img src="screenshots\36-h2.png" style="zoom:60%;"/>

<img src="screenshots\37-h2.png" style="zoom:60%;"/>

测试连接是否可用

<img src="screenshots\38-h2.png" style="zoom:60%;"/>

<img src="screenshots\39-h2.png" style="zoom:60%;"/>

创建数据表

<img src="screenshots\40-h2.png" style="zoom:70%;"/>

```sql
create table c_user
(
    id           long auto_increment primary key,
    account_id   varchar(100),
    name         varchar(50),
    token        char(36),
    gmt_create   bigint,
    gmt_modified bigint
);

comment on table c_user is '用户信息表';
comment on column c_user.id is '用户id';
comment on column c_user.account_id is 'github账号ID';
comment on column c_user.name is '用户名';
comment on column c_user.token is '登录token';
comment on column c_user.gmt_create is '创建时间';
comment on column c_user.gmt_modified is '修改时间';
```

<img src="screenshots\43-h2.png" style="zoom:70%;"/>

​	使用 H2 数据库，需要先引入依赖：

```xml
<!-- H2 DB(必须和IDEA Database插件中创建的H2数据库驱动版本一致，否则会报错) -->
<dependency>
	<groupId>com.h2database</groupId>
	<artifactId>h2</artifactId>
	<version>2.1.210</version>
	<scope>runtime</scope>
</dependency>
```

​	使用 H2 作为数据源，需要在 application.properties 中配置数据源：

```properties
# DataSource
spring.datasource.url=jdbc:h2:~/community
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=org.h2.Driver
```





# 8、集成 Mybatis 记录登录用户

​	首先引入依赖：

```xml
<dependency>
	<groupId>org.mybatis.spring.boot</groupId>
	<artifactId>mybatis-spring-boot-starter</artifactId>
	<version>2.0.1</version>
</dependency>
```

​	定义用户对象

```java
package life.majiang.community.model;

import lombok.Data;

@Data
public class User {

    private long id;
    private String accountId;
    private String name;
    private String token;
    private long gmtCreate;
    private long gmtModified;

}
```

​	定义 Mapper 接口

```java
package life.majiang.community.mapper;

import life.majiang.community.model.User;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface UserMapper {

    @Insert("insert into c_user (account_id, name, token, gmt_create, gmt_modified) values (#{accountId}, #{name}, #{token}, #{gmtCreate}, #{gmtModified})")
    public void insert(User user);

}
```

​	修改授权控制器 `AuthorizeController` ，新增获取 Github 用户数据成功后插入到数据库中

```java
@Controller
@Slf4j
public class AuthorizeController {
	...
    @Autowired
    private UserMapper userMapper;	
	...
	
	@GetMapping("/callback")
    public String callback(@RequestParam(name = "code") String code,
                           @RequestParam(name = "state") String state,
                           HttpServletRequest request) {
        if (githubUser != null && githubUser.getId() != null) {
            log.info("Github OAuth succ");
            User user = new User();
            user.setAccountId(String.valueOf(githubUser.getId()));
            user.setName(githubUser.getName());
            user.setToken(UUID.randomUUID().toString());
            user.setGmtCreate(System.currentTimeMillis());
            user.setGmtModified(user.getGmtCreate());
            userMapper.insert(user);

            // 设置用户登录会话
            request.getSession().setAttribute("user", user);
            response.addCookie(new Cookie("token", user.getToken()));          
          
            return "redirect:/";
        } else {
            // 登录失败，重新登录
            log.info("Github OAuth fail");
            return "redirect:/";
        }                           
	}
}
```

​	启动应用进入首页登录，发现点击登录后回显用户名信息了，并且在数据库中插入了一条新的记录

<img src="screenshots\44-h2.png" style="zoom:70%;"/>

​	但是如果关闭应用程序，再重启，由于 session 数据是保存在服务端内存中的数据，所以应用重启后，之前的 session 数据就被清空了，所以重启再打开首页默认还是未登录状态。

​	**优化思路是**，在每次访问首页时，后端尝试从 cookie 中拿到上次登录的 token，再用 token 去查询数据库的用户数据，查到再放到 session 中，这样渲染页面时，就能保持上次的登录状态。

​	首先要在 `UserMapper` 里添加根据 token 查询用户信息的方法：

```java
@Mapper
public interface UserMapper {

	...

    @Select("select * from c_user where token = #{token}")
    public User getByToken(@Param("token") String token);
}
```

​	在访问首页的控制器`IndexController`，修改代码如下：

```java
package life.majiang.community.controller;

import life.majiang.community.mapper.UserMapper;
import life.majiang.community.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;

@Controller
public class IndexController {

    @Autowired
    private UserMapper userMapper;

    @GetMapping("/")
    public String index(HttpServletRequest request) {
        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if ("token".equals(cookie.getName())) {
                    String token = cookie.getValue();
                    User user = userMapper.getByToken(token);
                    if (user != null) {
                        request.getSession().setAttribute("user", user);
                    }
                    break;
                }
            }
        }

        return "index";
    }

}
```

​	一般 cookie 需要设有效期，防止非用户本人访问自动保持登录会话，修改授权控制器 `AuthorizeController` ，代码如下：

```java
@Controller
@Slf4j
public class AuthorizeController {

  	...

    @GetMapping("/callback")
    public String callback(@RequestParam(name = "code") String code,
                           @RequestParam(name = "state") String state,
                           HttpServletRequest request,
                           HttpServletResponse response) {
	    ...

        if (githubUser != null && githubUser.getId() != null) {
            log.info("Github OAuth succ");

		   ...

            // 设置用户登录会话
            //request.getSession().setAttribute("user", user);
            Cookie cookie = new Cookie("token", user.getToken());
            cookie.setPath("/");
            cookie.setMaxAge(3600);
            response.addCookie(cookie);

            return "redirect:/";
        } else {
            // 登录失败，重新登录
            log.info("Github OAuth fail");
            return "redirect:/";
        }
    }

}
```

​	启动应用，点击登录测试

<img src="screenshots\45-h2.png" style="zoom:70%;"/>

​	可以看到浏览器 cookie 中有了 token 的数据，并且设置了有效期。

​	停止应用程序，查看数据库，有了一条新的数据，并且 token 跟浏览器中看到的一致

<img src="screenshots\46-h2.png" style="zoom:100%;"/>

​	重新启动应用，测试是否自动保持登录状态，结果正常登录，再次访问数据库并未发现新增的记录，说明根据 cookie 中的 token 查询数据库并且设置用户会话的处理生效了。

​	与此同时，发现一个新的问题，设置的 token cookie 的有效时间时区不对，跟当前差了 8 个小时，在 application.properties 中设置：

```properties
spring.jackson.time-zone=Asia/Shanghai
```





# 9、集成 Flyway Migration

## （1）简介

​	flyway 是一款让数据库迁移变得简单的工具，下面简单介绍其工作原理，最简单的情况是用 Flyway 将数据库结构迁移到一个空数据库。

<img src="screenshots\47-flyway.png" style="zoom:100%;"/>



​	flyway 自带一个 schema 历史迁移表。若找不到该表，则会先创建该表。

​	执行了之后，数据库中会出现一张空表  *flyway_schema_history*  

<img src="screenshots\48-flyway.png" style="zoom:100%;"/>

​	该表用于跟踪数据库的状态

​	紧接着 Flyway 会开始扫描文件系统或应用的类路径来找到迁移文件，这些文件可能是 Sql 也可能是 Java 文件。

​	迁移的执行顺序会按照文件的版本号进行：

<img src="screenshots\49-flyway.png" style="zoom:100%;"/>

​	应用每次迁移时，架构历史表都会相应更新：

<img src="screenshots\50-flyway.png" style="zoom:100%;"/>

​	元数据和初始状态就位后，我们现在可以讨论迁移到新版本。

​	Flyway 会再次扫描文件系统或应用的类路径，根据架构历史表检查迁移，如果它们的版本号低于或等于标记为当前的版本号，则它们将被忽略。

​	剩余的迁移是待处理的迁移：可用，但未应用。

<img src="screenshots\51-flyway.png" style="zoom:100%;"/>

​	然后它们按版本号排序并按顺序执行：

<img src="screenshots\52-flyway.png" style="zoom:100%;"/>

​	架构历史表会相应更新：

<img src="screenshots\53-flyway.png" style="zoom:100%;"/>

​	每次需要改进数据库时，无论是结构（DDL）还是参考数据（DML），只需创建一个版本号高于当前版本号的新迁移即可。Flyway下次启动时，它会找到它并相应地升级数据库。



## （2）Maven 插件

​	首先在 Maven 工程的 pom.xml 中添加配置：

```xml
<project xmlns="...">
    <build>
        <plugins>
            <plugin>
                <groupId>org.flywaydb</groupId>
                <artifactId>flyway-maven-plugin</artifactId>
                <version>9.17.0</version>
                <configuration>
                    <url>jdbc:h2:~/community</url>
                    <user>root</user>
                    <password>root</password>
                </configuration>
                <dependencies>
                    <!-- 插件的版本要跟Jar包引入保持一致 -->
                    <dependency>
                        <groupId>com.h2database</groupId>
                        <artifactId>h2</artifactId>
                        <version>2.1.210</version>
                    </dependency>
                </dependencies>
            </plugin>
        </plugins>
    </build>
</project>
```

​	迁移文件的目录是 `src/main/resources/db/migration` ，在该目录下创建迁移文件 `V1__Create_user_table.sql` :

```sql
create table c_user
(
    id           long auto_increment primary key,
    account_id   varchar(100),
    name         varchar(50),
    token        char(36),
    gmt_create   bigint,
    gmt_modified bigint
);

comment on table c_user is '用户信息表';
comment on column c_user.id is '用户id';
comment on column c_user.account_id is 'github账号ID';
comment on column c_user.name is '用户名';
comment on column c_user.token is '登录token';
comment on column c_user.gmt_create is '创建时间';
comment on column c_user.gmt_modified is '修改时间';
```

​	在工程目录下执行 `mvn flyway:migrate` 

<img src="screenshots\54-flyway.png" style="zoom:100%;"/>

​	原来的用户表被删了再重建，数据被清空，同时还多了一张迁移表

<img src="screenshots\55-flyway.png" style="zoom:100%;"/>

​	迁移表记录了执行迁移的记录，包括文件、版本等信息

<img src="screenshots\56-flyway.png" style="zoom:100%;"/>

​	新增一个 V2 版本的迁移 SQL 文件，脚本如下：

```sql
ALTER TABLE C_USER ADD bio VARCHAR(256) NULL;
```

​	再次执行 `mvn flyway:migrate` 

<img src="screenshots\57-flyway.png" style="zoom:100%;"/>

​	查看迁移表，又多了一条记录

<img src="screenshots\58-flyway.png" style="zoom:100%;"/>

​	查看变结构，多了一个字段

<img src="screenshots\59-flyway.png" style="zoom:60%;"/>

​	



# 10、添加文章发布功能

## （1）前端

​	新增页面 publish.html

```html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>鸭鸭社区</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/community.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>
    <nav class="navbar navbar-default">
        <div class="container-fluid">

            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                    <span class="sr-only">鸭鸭社区</span>
                </button>
                <a class="navbar-brand" href="/">鸭鸭社区</a>
            </div>

            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <form class="navbar-form navbar-left">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="搜索问题">
                    </div>
                    <button type="submit" class="btn btn-default">搜索</button>
                </form>
                <ul class="nav navbar-nav navbar-right">
                    <li th:if="${session.user != null}"><a href="/publish">发布</a></li>
                    <li th:if="${session.user == null}"><a href="https://github.com/login/oauth/authorize?client_id=ce46b85af14a2d21447b&redirect_uri=http://localhost:8080/callback&scope=user&state=2">登录</a></li>
                    <li th:if="${session.user != null}" class="dropdown">
                        <a th:text="${session.user.name}" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">我 <span class="caret"></span></a>
                        <ul class="dropdown-menu">
                            <li><a href="#">消息中心</a></li>
                            <li><a href="#">个鸭资料</a></li>
                            <li><a href="#">退出登录</a></li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container-fluid main">
        <div class="row">
            <div class="col-lg-9 col-md-12 col-sm-12 col-xs-12">
                <h2><span class="glyphicon glyphicon-plus" aria-hidden="true"></span>发起</h2>
                <hr>

                <form action="/publish" method="post">
                    <input type="text" style="display:none" id="id" name="id" th:value="${id}"/>
                    <div class="form-group">
                        <label for="title">问题标题（简单扼要）：</label>
                        <input type="text" class="form-control" id="title" name="title" placeholder="问题标题……" th:value="${title}">
                    </div>
                    <div class="form-group">
                        <label for="description">问题补充（必填，请参照右侧提示）:</label>
                        <textarea class="form-control" id="description" name="description" rows="10" cols="30" th:text="${description}"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="tag">添加标签：</label>
                        <input type="text" class="form-control" id="tag" name="tag" placeholder="输入标签，以逗号分隔" th:value="${tag}">
                    </div>

                    <div class="container-fluid" style="padding-right: 0">
                        <div class="row">
                            <div class="col-lg-9 col-md-12 col-sm-12 col-xs-12">
                                <div class="alert alert-danger" role="alert" th:text="${error}" th:if="${error != null}"></div>
                            </div>
                            <div class="col-lg-3 col-md-12 col-sm-12 col-xs-12">
                                <button type="submit" class="btn btn-success btn-publish">提问</button>
                            </div>
                        </div>
                    </div>
                </form>
            </div>
            <div class="col-lg-3 col-md-12 col-sm-12 col-xs-12">
                <h3>热门话题</h3>
            </div>
        </div>
    </div>

</body>
</html>
```

​	编写一个响应请求展现页面的控制器 `PublishController` ，代码如下：

```java
package life.majiang.community.controller;

import life.majiang.community.mapper.QuestionMapper;
import life.majiang.community.model.Question;
import life.majiang.community.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletRequest;

@Controller
public class PublishController {

    @GetMapping("/publish")
    public String publish(HttpServletRequest request) {
        return "publish";
    }
}
```

​	启动应用，访问 `http://localhost:8080/publish` ，页面展现如下

<img src="screenshots\60-publish.png" style="zoom:100%;"/>

​	用户还没登录，就可以发布问题，显然是不合理的，所以在访问页面时，控制器里应先判断当前用户会话是否为空，会话中保存的用户信息是否为空，是则跳转到首页，用户在首页登录后再访问本页才能展现页面，代码修改如下：

```java
    @GetMapping("/publish")
    public String publish(HttpServletRequest request) {
        if (request.getSession() != null && request.getSession().getAttribute("user") == null) {
            return "redirect:/";
        }
        return "publish";
    }
```

​	重启应用再次访问 `http://localhost:8080/publish` ，会发现会重定向到 `http://localhost:8080/` ，达到想要的效果。

<img src="screenshots\61-publish.png" style="zoom:100%;"/>



## （2）后端

​	首先要有一张表存储用户发布的问题，除了发布页面的标题、内容和标签外，还要有评论数、阅读数、点赞数、作者，方便在接下来的文章详情展示页中展示，除此之外，每条数据还要有创建时间、修改时间，综上所述，建表语句如下：

```sql
create table question
(
    id            INT auto_increment primary key,
    title         VARCHAR(50) COMMENT '问题标题',
    description   TEXT COMMENT '问题描述',
    gmt_create    BIGINT COMMENT '创建时间',
    gmt_modified  BIGINT COMMENT '修改时间',
    creator       INT comment '创建者',
    comment_count INT DEFAULT 0 COMMENT '评论数',
    view_count    INT DEFAULT 0 COMMENT '阅读数',
    like_count    INT DEFAULT 0 COMMENT '点赞数',
    tag           VARCHAR(256) COMMENT '标签'
);
```

​	将其放在 resource/db/migration 目录下的 `V3__Create_question_table.sql` 中，然后执行 `mvn flyway:migrate` 命令执行迁移。

​	接着建立表对应的 POJO 类 `Question` ，代码如下：

```java
package life.majiang.community.model;

import lombok.Data;

@Data
public class Question {

    private Long id;
    private String title;
    private String description;
    private Long gmtCreate;
    private Long gmtModified;
    private Long creator;
    private Integer commentCount;
    private Integer viewCount;
    private Integer likeCount;
    private String tag;

}
```

​	定义对应的 Mapper，新增插入数据的方法：

```java
package life.majiang.community.mapper;

import life.majiang.community.model.Question;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface QuestionMapper {

    @Insert("insert into question (title, description, gmt_create, gmt_modified, creator, tag) values (#{title}, #{description}, #{gmtCreate}, #{gmtModified}, #{creator}, #{tag})")
    void insert(Question question);

}
```

​	在 `PublishController` 中定义处理 POST 请求的方法

```java
@Controller
public class PublishController {
  
	// other code	
  
    @PostMapping("/publish")
    public String doPublish(@RequestParam(value = "title") String title,
                            @RequestParam(value = "description") String description,
                            @RequestParam(value = "tag") String tag,
                            HttpServletRequest request,
                            Model model) {
        // 方便页面回显，这样页面已经填了的信息不用再重填一次
        model.addAttribute("title", title);
        model.addAttribute("description", description);
        model.addAttribute("tag", tag);
        //model.addAttribute("id", id);

        if (StringUtils.isEmpty(title)) {
            model.addAttribute("error", "标题不能为空");
            return "publish";
        }
        if (StringUtils.isEmpty(description)) {
            model.addAttribute("error", "问题补充不能为空");
            return "publish";
        }
        if (StringUtils.isEmpty(tag)) {
            model.addAttribute("error", "标签不能为空");
            return "publish";
        }

        // 如果cookie中不存在token，或根据token查无用户，则返回报错
        if (request.getSession() == null || request.getSession().getAttribute("user") == null) {
            model.addAttribute("error", "用户未登录");
            return "publish";
        }

        User user = (User) request.getSession().getAttribute("user");
        // 记录提交问题带数据库
        Question question = new Question();
        question.setTitle(title);
        question.setDescription(description);
        question.setGmtCreate(System.currentTimeMillis());
        question.setGmtModified(question.getGmtCreate());
        question.setCreator(user.getId());
        question.setTag(tag);
        questionMapper.insert(question);

        return "redirect:/";
    }
}
```

​	启动应用，访问首页登录后点击发布，填写问题相关信息

<img src="screenshots\62-publish.png" style="zoom:100%;"/>

​	点击提交成功后自动跳转到首页，查看数据库，成功插入了一条数据

<img src="screenshots\63-publish.png" style="zoom:100%;"/>

​	当提交问题为空时，会返回报错回显到页面上提示

<img src="screenshots\64-publish.png" style="zoom:100%;"/>





# 11、添加文章列表功能

## （1）添加字段

​	一些论坛社区的通常会有一个帖子或文章列表，如下图所示：

<img src="screenshots\65-list.png" style="zoom:100%;"/>

​	会展示用户头像，所以需要在用户表和对应的 POJO 以及数据库处理中增加对应的字段，新增迁移文件 `V4__Add_avatarUrl_col_to_user_table.sql`：

```sql
ALTER TABLE C_USER ADD avatar_url VARCHAR(100) NULL;

comment on column c_user.avatar_url is '用户头像';
```

​	执行迁移命令，在 `User` 类中添加相应字段

```java
@Data
public class User {

    private long id;
    private String accountId;
    private String name;
    private String token;
    private long gmtCreate;
    private long gmtModified;
    private String bio;
    private String avatarUrl;

}
```

​	在 `AuthorizeController` 中修改 OAuth 登录成功之后的处理代码：

```java
            User user = new User();
            user.setAccountId(String.valueOf(githubUser.getId()));
            user.setName(githubUser.getName());
            user.setToken(UUID.randomUUID().toString());
            user.setGmtCreate(System.currentTimeMillis());
            user.setGmtModified(user.getGmtCreate());
            user.setBio(githubUser.getBio());                 // 新增代码
            user.setAvatarUrl(githubUser.getAvatarUrl());     // 新增代码
            userMapper.insert(user);
```

​	修改 `UserMapper` 

```java
@Mapper
public interface UserMapper {

    @Insert("insert into c_user (account_id, name, token, gmt_create, gmt_modified, bio, avatar_url) values (#{accountId}, #{name}, #{token}, #{gmtCreate}, #{gmtModified}, #{bio}, #{avatarUrl})")
    public void insert(User user);
    
    // other code
}    
```

​	启动程序再次登录，登录成功后查看数据库，记录下了简介和头像两个用户信息

<img src="screenshots\66-list.png" style="zoom:100%;"/>



## （2）前端

​	修改前端页面 `index.html`

```html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>鸭鸭社区</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/community.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>
    <nav class="navbar navbar-default">
        <div class="container-fluid">

            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                    <span class="sr-only">鸭鸭社区</span>
                </button>
                <a class="navbar-brand" href="/">鸭鸭社区</a>
            </div>

            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <form class="navbar-form navbar-left">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="搜索问题">
                    </div>
                    <button type="submit" class="btn btn-default">搜索</button>
                </form>
                <ul class="nav navbar-nav navbar-right">
                    <li th:if="${session.user != null}"><a href="/publish">发布</a></li>
                    <li th:if="${session.user == null}"><a href="https://github.com/login/oauth/authorize?client_id=ce46b85af14a2d21447b&redirect_uri=http://localhost:8080/callback&scope=user&state=2">登录</a></li>
                    <li th:if="${session.user != null}" class="dropdown">
                        <a th:text="${session.user.name}" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">我 <span class="caret"></span></a>
                        <ul class="dropdown-menu">
                            <li><a href="#">消息中心</a></li>
                            <li><a href="#">个鸭资料</a></li>
                            <li><a href="#">退出登录</a></li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container-fluid main">
        <div class="row">
            <div class="col-lg-9 col-md-12 col-sm-12 col-xs-12 question-list">
                <h2><span class="glyphicon glyphicon-plus" aria-hidden="true"></span>发起</h2>
                <hr>
                <div class="media">
                    <div class="media-left">
                        <a href="#">
                            <img class="media-object img-rounded" src="https://avatars.githubusercontent.com/u/11757351?v=4">
                        </a>
                    </div>
                    <div class="media-body">
                        <h4 class="media-heading">Media heading</h4>
                        ...
                        <span class="text-desc">0 个评论 • 409 次浏览 • 2 天前</span>
                    </div>
                </div>
            </div>
            <div class="col-lg-3 col-md-12 col-sm-12 col-xs-12">
                <h3>热门话题</h3>
            </div>
        </div>
    </div>

</body>
</html>
```

​	启动应用访问 `http://localhost:8080`，效果如下：

<img src="screenshots\67-list.png" style="zoom:100%;"/>

​	只要后端提供一个查询问题数据列表的接口，并将数据渲染到该页面上，就可得到一个文章列表。



## （3）后端

​	首先要有一个查询问题列表的数据服务，同时每条数据还要带上用户信息（用于显示提问用户头像），可以选择在 `Question` 类中添加一个 `User` 的成员属性，但是这样不符合类设计的单一职责原则，为了将问题和用户的信息关联组合在一个类中，需要定义一个新的 `QuestionDTO` 类，代码如下：

```java
package life.majiang.community.dto;

import life.majiang.community.model.User;
import lombok.Data;

@Data
public class QuestionDTO {

    private Long id;
    private String title;
    private String description;
    private Long gmtCreate;
    private Long gmtModified;
    private Long creator;
    private Integer commentCount;
    private Integer viewCount;
    private Integer likeCount;
    private String tag;
    private User user;

}
```

​	定义一个问题服务类 `QuestionService` ，代码如下：

```java
package life.majiang.community.service;

import life.majiang.community.dto.QuestionDTO;
import life.majiang.community.mapper.QuestionMapper;
import life.majiang.community.mapper.UserMapper;
import life.majiang.community.model.Question;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;

@Service
public class QuestionService {

    @Autowired
    private QuestionMapper questionMapper;

    @Autowired
    private UserMapper userMapper;

    public List<QuestionDTO> list() {
        List<QuestionDTO> list = new ArrayList<>();

        List<Question> questions = questionMapper.list();
        for (Question question : questions) {
            QuestionDTO questionDTO = new QuestionDTO();
            BeanUtils.copyProperties(question, questionDTO);
            questionDTO.setUser(userMapper.getById(question.getCreator()));
            list.add(questionDTO);
        }

        return list;
    }

}
```

​	该服务中注入了 mapper，并通过 mapper 的数据操作来获取数据，首先 `QuestionMapper` 要有查询所有问题列表的方法，新增代码如下：

```java
@Mapper
public interface QuestionMapper {

    // other code

    @Select("select * from question")
    List<Question> list();
}
```

​	查到问题后，要对每个问题逐个查询提交人是谁，所以 `UserMapper` 也要根据用户id查询用户的方法，新增代码如下：

```java
@Mapper
public interface UserMapper {

	// other code

    @Select("select * from c_user where id = #{id}")
    public User getById(@Param("id") long id);
}
```

​	完成了服务的编写，在访问首页时使用，并将其放到 model 中才能在页面上渲染

```java
@Controller
public class IndexController {

    @Autowired
    private UserMapper userMapper;

    @Autowired
    private QuestionService questionService;

    @GetMapping("/")
    public String index(HttpServletRequest request,
                        Model model) {
		// other code

        List<QuestionDTO> questionDTOS = questionService.list();
        model.addAttribute("questions", questionDTOS);

        return "index";
    }

}
```

​	返回的数据是一个列表，借助 thymeleaf 模板引擎的 `th:each` 进行遍历和渲染，index.html的局部代码修改如下：

```html
<div class="container-fluid main">
    <div class="row">
        <div class="col-lg-9 col-md-12 col-sm-12 col-xs-12 question-list">
            <h2><span class="glyphicon glyphicon-plus" aria-hidden="true"></span>发起</h2>
            <hr>
            <div class="media" th:each="question : ${questions}">
                <div class="media-left">
                    <a href="#">
                        <img class="media-object img-rounded" th:src="${question.user.avatarUrl}"/>
                    </a>
                </div>
                <div class="media-body">
                    <h4 class="media-heading" th:text="${question.title}"></h4>
                    <span th:text="${question.description}"></span><br>
                    <span class="text-desc">
                        <span th:text="${question.commentCount}"></span> 个评论 •
                        <span th:text="${question.viewCount}"></span> 次浏览 •
                        <span th:text="${#dates.format(question.gmtCreate,'yyyy-MM-dd HH:mm')}"></span>
                    </span>
                </div>
            </div>
        </div>
        <div class="col-lg-3 col-md-12 col-sm-12 col-xs-12">
            <h3>热门话题</h3>
        </div>
    </div>
</div>
```

​	启动应用，访问 `http://localhost:8080` ，效果如下：

<img src="screenshots\68-list.png" style="zoom:100%;"/>

​	好像并不是我们要的效果，问题内容应该在详情页才展现，参考下 elasticsearch 中文社区

<img src="screenshots\69-list.png" style="zoom:100%;"/>

​	显示的是文章标签和作者，修改代码如下：

```html
<div class="container-fluid main">
    <div class="row">
        <div class="col-lg-9 col-md-12 col-sm-12 col-xs-12 question-list">
            <h2><span class="glyphicon glyphicon-plus" aria-hidden="true"></span>发起</h2>
            <hr>
            <div class="media" th:each="question : ${questions}">
                <div class="media-left">
                    <a href="#">
                        <img class="media-object img-rounded" th:src="${question.user.avatarUrl}"/>
                    </a>
                </div>
                <div class="media-body">
                    <h4 class="media-heading" th:text="${question.title}"></h4>
                    <span class="text-desc">
                        <a class="question-tags" href="#" th:text="${question.tag}"></a> •
                        <span th:text="${question.user.name}"></span> 发表了文章 •
                        <span th:text="${question.commentCount}"></span> 个评论 •
                        <span th:text="${question.viewCount}"></span> 次浏览 •
                        <span th:text="${#dates.format(question.gmtCreate,'yyyy-MM-dd HH:mm')}"></span>
                    </span>
                </div>
            </div>
        </div>
        <div class="col-lg-3 col-md-12 col-sm-12 col-xs-12">
            <h3>热门话题</h3>
        </div>
    </div>
</div>
```

​	再次启动应用访问首页，达到了想要的效果

<img src="screenshots\70-list.png" style="zoom:100%;"/>

​	再发布一个问题，发布成功跳转回首页，展现列表如下：

<img src="screenshots\71-list.png" style="zoom:100%;"/>





# 12、IDEA 自动热部署

## （1）IDEA 配置

​	打开 `Settings` 编译配置，勾选 `Build project automatically`

<img src="screenshots\72-devtools.png" style="zoom:100%;"/>

​	在旧版的 IDEA，通过 `ctrl + alt + shift + ?` ，然后进入 `Registry`

<img src="screenshots\74-devtools.png" style="zoom:60%;"/>

​	找到一个 `compiler.automake.allow.when.app.running` 的配置勾选

<img src="screenshots\75-devtools.png" style="zoom:100%;"/>

​	在新版本的 IDEA 中，打开 `Settings` -> `Advanced Settings` ，勾选以下选项

<img src="screenshots\73-devtools.png" style="zoom:100%;"/>

​	在最新版本的 2023 IDEA，还要添加配置

<img src="screenshots\76-devtools.png" style="zoom:100%;"/>



## （2）Devtools

​	Spring Boot 包含一组额外的工具，可以使应用程序开发体验更加愉快。 spring-boot-devtools 模块可以包含在任何项目中以提供额外的开发时功能。

​	在工程中添加 `spring-boot-devtools` 的依赖

```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-devtools</artifactId>
	<optional>true</optional>
</dependency>
```

​	对于完成打包的应用程序 Devtools 默认是不启用的，如果您的应用程序是从 java -jar 启动的，或者是从特殊的类加载器启动的，那么它被视为“生产应用程序”。可以通过 `spring.devtools.restart.enabled` 属性配置自由控制是否启用，但是在生产环境中时很危险的。

​	某些资源在更改时不一定需要触发重新启动。例如，Thymeleaf 模板可以就地编辑。默认情况下，更改 `/META-INF/maven`、`/META-INF/resources`、`/resources`、`/static`、`/public` 或 `/templates` 中的资源不会触发重新启动，但会被浏览器端的 LiveReload 感知并重新加载。如果要自定义这些排除项，可以使用 `spring.devtools.restart.exclude` 属性。

​	例如，要仅排除 /static 和 /public，您可以设置以下属性：

```properties
spring.devtools.restart.exclude=static/**,public/**
```

​	这样修改 static/、public/ 目录下的静态文件时也会触发应用自动重启。



## （3）测试

​	启动应用，再修改代码保存，可以触发自动重启

<img src="screenshots\77-devtools.png" style="zoom:100%;"/>

​	Devtools 还可以跟浏览器端的 LiveReload 组件配合使用，比如访问网页，然后在浏览器上设置当前网站启用  LiveReload，接着在 IDE 里修改 HTML 文件（静态资源文件不会重启应用）。

<img src="screenshots\78-livereload.png" style="zoom:100%;"/>

​	这时浏览器会自动刷新

<img src="screenshots\79-livereload.png" style="zoom:100%;"/>





# 13、分页功能

​	当问题比较多时，放在一个页面显示的话数据量太大，需要有个分页查询的功能，通过数据库以下语法查询：

```
select * from tab where ... limit size offset (page-1) * size
# 也可以用语法
limit (page-1) * size, size
```

​	`size` 是每页的数据量，`page` 表示第几页，`(page-1) * size` 是计算出来的偏移量。

​	假设每页有3条数据，查询第一页是 `limit 3 offset 0` ，第二页是 `limit 3 offset 3` ，以此类推。

​	实现分页要获取当前页的数据，还要知道总页数，所以在 `QuestionMapper` 中添加对应的数据操作方法

```java
@Mapper
public interface QuestionMapper {
	// other code

    // 查询分页问题列表
    @Select("select * from question limit #{offset}, #{size}")
    List<Question> listPage(@Param("offset") Integer offset, @Param("size") Integer size);

    // 获取总记录条数
    @Select("select count(1) from question")
    Integer count();
}
```

​	每次返回当前页的数据列表的同时，还要返回展现分页栏需要的信息

<img src="screenshots\80-pagination.png" style="zoom:100%;"/>

​	我们想要这样一个分页栏：

（1）当前页为首页时，不显示上一页和首页的跳转箭头

<img src="screenshots\81-pagination.png" style="zoom:100%;"/>

（2）当前页为尾页时，不显示下一页和尾页的跳转箭头

<img src="screenshots\82-pagination.png" style="zoom:100%;"/>

（3）当前页离首页超过3页时，显示跳转到首页的箭头；当前页离尾页超过3页时，显示跳转到尾页的箭头

<img src="screenshots\80-pagination.png" style="zoom:100%;"/>

​	根据以上需求，返回的分页栏信息中，要包含以下信息：

* 是否显示上一页、下一页箭头

* 是否显示首页、尾页箭头

* 当前页

* 当前页的前后3页，靠近头部和尾部则显示到头尾为止

  我们首先需要封装一个分页的类 `PaginationDTO`，按照上述需求，代码如下：

```java
package life.majiang.community.dto;

import lombok.Data;

import java.util.ArrayList;
import java.util.List;

@Data
public class PaginationDTO {

    private boolean showFirstPage;                      // 是否显示头页标签 <<
    private boolean showLastPage;                       // 是否显示尾页标签 >>
    private boolean showPrevPage;                       // 是否显示前一页 <
    private boolean showNextPage;                       // 是否显示下一页 >
    private Integer currentPage;                        // 当前页是第几页
    private Integer totalPages;                         // 一共有多少页
    private List<Integer> pages = new ArrayList<>();    // 显示页码
    private List<Object> data;

    /**
     *
     * @param totalCount    总数据条数
     * @param page          第几页
     * @param size          每页数据条数
     */
    public void init(Integer totalCount, Integer page, Integer size) {
        this.currentPage = page;
        this.totalPages = (totalCount % size == 0) ? totalCount/size : totalCount/size + 1;
        this.showFirstPage = (page - 3 > 1);
        this.showLastPage = (totalPages - page > 3);
        this.showPrevPage = (page != 1);
        this.showNextPage = (page != totalPages);

        /**
         * 假设page为4，总页数为10
         * 则页码列表应为 1,2,3,4,5,6,7
         */
        pages.add(page);
        for (int i = 1; i <= 3; i++) {
            if (page - i > 0) {
                pages.add(0, page - i);
            }
            if (page + i <= totalPages) {
                pages.add(page + i);
            }
        }
    }

}
```

​	在 `QuestionService` 中添加查询分页的方法：

```java
public PaginationDTO pageListWithBar(Integer page, Integer size) {
	// 获得要展现页的数据
	Integer offset = (page - 1) * size;
	List<QuestionDTO> questionDTOS = getQuestionDTOS( questionMapper.listPage(offset, size));

	Integer totalCount = questionMapper.count();
	PaginationDTO paginationDTO = new PaginationDTO();
	paginationDTO.init(totalCount, page, size);
	paginationDTO.setData(questionDTOS.stream()
									  .map(o -> (Object) o)
									  .collect(Collectors.toList()));

	return paginationDTO;
}

private List<QuestionDTO> getQuestionDTOS(List<Question> questions) {
	List<QuestionDTO> questionDTOS = new ArrayList<>();

	for (Question question : questions) {
		QuestionDTO questionDTO = new QuestionDTO();
		BeanUtils.copyProperties(question, questionDTO);
		questionDTO.setUser(userMapper.getById(question.getCreator()));
		questionDTOS.add(questionDTO);
	}

	return questionDTOS;
}
```

​	修改 `IndexController` 代码：

```java
@Controller
public class IndexController {

    // other code

    @Autowired
    private QuestionService questionService;

    @GetMapping("/")
    public String index(HttpServletRequest request,
                        Model model,
                        @RequestParam(name = "page", defaultValue = "1") Integer page,
                        @RequestParam(name = "size", defaultValue = "2") Integer size) {
        // other code

        PaginationDTO questionDTOS = questionService.pageListWithBar(page, size);
        model.addAttribute("pagination", questionDTOS);

        return "index";
    }

}
```

​	`page` 是前端上送的查询数据页页码，`size` 是每个数据页包含的数据条数。

​	修改 `index.html` ，使用 Bootstrap 的分页组件，代码如下：

```html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>鸭鸭社区</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/community.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>
<nav class="navbar navbar-default">
	// other code
</nav>

<div class="container-fluid main">
    <div class="row">
        <div class="col-lg-9 col-md-12 col-sm-12 col-xs-12 question-list">
            <h2><span class="glyphicon glyphicon-list" aria-hidden="true"></span> 发现</h2>
            <hr>
            <div class="media" th:each="question : ${pagination.data}">
                <div class="media-left">
                    <a href="#">
                        <img class="media-object img-rounded" th:src="${question.user.avatarUrl}"/>
                    </a>
                </div>
                <div class="media-body">
                    <h4 class="media-heading" th:text="${question.title}"></h4>
                    <span class="text-desc">
                        <a class="question-tags" href="#" th:text="${question.tag}"></a> •
                        <span th:text="${question.user.name}"></span> 发表了文章 •
                        <span th:text="${question.commentCount}"></span> 个评论 •
                        <span th:text="${question.viewCount}"></span> 次浏览 •
                        <span th:text="${#dates.format(question.gmtCreate,'yyyy-MM-dd HH:mm')}"></span>
                    </span>
                </div>
            </div>

            <div class="comm-pagination">
                <nav aria-label="...">
                    <ul class="pagination">
                        <li th:if="${pagination.showFirstPage}">
                            <a th:href="@{/(page=1)}" aria-label="Previous"><span aria-hidden="true">&lt;&lt;</span></a>
                        </li>
                        <li th:if="${pagination.showPrevPage}">
                            <a th:href="@{/(page=${pagination.currentPage-1})}" aria-label="Previous"><span aria-hidden="true">&lt;</span></a>
                        </li>

                        <li th:each="page : ${pagination.pages}" th:class="${pagination.currentPage == page}? 'active' : ''">
                            <a th:href="@{/(page=${page})}" th:text="${page}"></a>
                        </li>

                        <li th:if="${pagination.showNextPage}">
                            <a th:href="@{/(page=${pagination.currentPage+1})}" aria-label="Next"><span aria-hidden="true">&gt;</span></a>
                        </li>
                        <li th:if="${pagination.showLastPage}">
                            <a th:href="@{/(page=${pagination.totalPages})}" aria-label="Next"><span aria-hidden="true">&gt;&gt;</span></a>
                        </li>
                    </ul>
                </nav>
            </div>
        </div>
        <div class="col-lg-3 col-md-12 col-sm-12 col-xs-12">
            <h3>热门话题</h3>
        </div>
    </div>
</div>

</body>
</html>
```

​	启动应用程序，访问 `http://localhost:8080/` ，效果如下：

<img src="screenshots\83-pagination.png" style="zoom:100%;"/>

<img src="screenshots\84-pagination.png" style="zoom:100%;"/>

<img src="screenshots\85-pagination.png" style="zoom:100%;"/>

<img src="screenshots\86-pagination.png" style="zoom:100%;"/>





# 14、页面拆解复用导航栏

​	首先需要创建一个专门放复用模板段的文件 `navigation.html` ，代码如下：

```html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<body>

    <div th:fragment="navigation">
        <nav class="navbar navbar-default">
            <div class="container-fluid">

                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                        <span class="sr-only">鸭鸭社区</span>
                    </button>
                    <a class="navbar-brand" href="/">鸭鸭社区</a>
                </div>

                <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                    <form class="navbar-form navbar-left">
                        <div class="form-group">
                            <input type="text" class="form-control" placeholder="搜索问题">
                        </div>
                        <button type="submit" class="btn btn-default">搜索</button>
                    </form>
                    <ul class="nav navbar-nav navbar-right">
                        <li th:if="${session.user != null}"><a href="/publish">提问</a></li>
                        <li th:if="${session.user == null}"><a href="https://github.com/login/oauth/authorize?client_id=ce46b85af14a2d21447b&redirect_uri=http://localhost:8080/callback&scope=user&state=2">登录</a></li>
                        <li th:if="${session.user != null}" class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
                                <span th:text="${session.user.name}"></span>
                                <span class="caret"></span>
                            </a>
                            <ul class="dropdown-menu">
                                <li><a href="/profile/questions">消息中心</a></li>
                                <li><a href="#">个鸭资料</a></li>
                                <li><a href="/logout">退出登录</a></li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>
        </nav>
    </div>

</body>
```

​	在 `index.html ` 、`publish.html` 中引入模板段，删除重复代码

```html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>鸭鸭社区</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/community.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>
<!-- 引用模板 -->
<div th:insert="navigation :: navigation"></div>

<div class="container-fluid main">
	...
</div>
```

​	我们发现问题列表页和分页导航栏，也很适合拆解复用，在 `navigation.html` 中新增代码模板：

```java
...

   <div th:fragment="questionList">
        <div class="media" th:each="question : ${pagination.data}">
            <div class="media-left">
                <a href="#">
                    <img class="media-object img-rounded" th:src="${question.user.avatarUrl}"/>
                </a>
            </div>
            <div class="media-body">
                <a th:href="@{'/question/' + ${question.id}}">
                <h4 class="media-heading" th:text="${question.title}"></h4>
                </a>
                <span class="text-desc">
                        <a class="question-tags" href="#" th:text="${question.tag}"></a> •
                        <span th:text="${question.user.name}"></span> 发表了文章 •
                        <span th:text="${question.commentCount}"></span> 个评论 •
                        <span th:text="${question.viewCount}"></span> 次浏览 •
                        <span th:text="${#dates.format(question.gmtCreate,'yyyy-MM-dd HH:mm')}"></span>
                    </span>
            </div>
        </div>
    </div>

    <div th:fragment="pagination">
        <div class="comm-pagination">
            <nav aria-label="...">
                <ul class="pagination">
                    <li th:if="${pagination.showFirstPage}">
                        <a th:href="${section == null} ? @{./(page=1)} : @{'./'+${section}(page=1)}" aria-label="Previous"><span aria-hidden="true">&lt;&lt;</span></a>
                    </li>
                    <li th:if="${pagination.showPrevPage}">
                        <a th:href="${section == null} ? @{./(page=${pagination.currentPage-1})} : @{'./'+${section}(page=${pagination.currentPage-1})}" aria-label="Previous"><span aria-hidden="true">&lt;</span></a>
                    </li>

                    <li th:each="page : ${pagination.pages}" th:class="${pagination.currentPage == page}? 'active' : ''">
                        <a th:href="${section == null} ? @{./(page=${page})} : @{'./'+${section}(page=${page})}" th:text="${page}"></a>
                    </li>

                    <li th:if="${pagination.showNextPage}">
                        <a th:href="${section == null} ? @{./(page=${pagination.currentPage+1})} : @{'./'+${section}(page=${pagination.currentPage+1})}" aria-label="Next"><span aria-hidden="true">&gt;</span></a>
                    </li>
                    <li th:if="${pagination.showLastPage}">
                        <a th:href="${section == null} ? @{./(page=${pagination.totalPages})} : @{'./'+${section}(page=${pagination.totalPages})}" aria-label="Next"><span aria-hidden="true">&gt;&gt;</span></a>
                    </li>
                </ul>
            </nav>
        </div>
    </div>
...
```

​	这样 `index.html` 、`profile.html` 可以简化为：

```html
<!--index.html-->
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>鸭鸭社区</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/community.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>
<!-- 引用模板 -->
<div th:insert="navigation :: navigation"></div>

<div class="container-fluid main">
    <div class="row">
        <div class="col-lg-9 col-md-12 col-sm-12 col-xs-12 question-list">
            <h2><span class="glyphicon glyphicon-list" aria-hidden="true"></span> 发现</h2>
            <hr>
            <div th:insert="navigation :: questionList"></div>
            <div th:insert="navigation :: pagination"></div>
        </div>
        <div class="col-lg-3 col-md-12 col-sm-12 col-xs-12">
            <h3>热门话题</h3>
        </div>
    </div>
</div>

</body>
</html>

<!--profile.html-->
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title th:text="${sectionName}"></title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/community.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>

    <div th:insert="navigation :: navigation"></div>

    <div class="container-fluid main">
        <div class="row">
            <div class="col-lg-9 col-md-12 col-sm-12 col-xs-12 question-list">
                <h2>
                    <span class="glyphicon glyphicon-pushpin" aria-hidden="true"></span>
                    <span th:text="${sectionName}"></span>
                </h2>
                <hr>
                <div th:insert="navigation :: questionList"></div>
                <div th:insert="navigation :: pagination"></div>
            </div>

            <div class="col-lg-3 col-md-12 col-sm-12 col-xs-12 profile">
                <div class="list-group section">
                    <a href="/profile/questions" th:class="${section == 'questions'} ? 'list-group-item active' : 'list-group-item'">
                        我的问题
                        <span class="badge" th:if="${section == 'questions'}" th:text="${pagination.totalCount}"></span>
                    </a>
                    <a href="/profile/replies" th:class="${section == 'replies'} ? 'list-group-item active' : 'list-group-item'">
                        最新回复
                        <span class="badge" th:if="${section == 'replies'}" th:text="${pagination.totalCount}"></span>
                    </a>
                </div>
            </div>
        </div>
    </div>

</body>
</html>
```





# 15、添加个人资料发布问题列表

​	首先要实现数据接口，在首页显示列表的基础上新增一个根据用户ID查询的条件，在 `QuestionMapper` 中新增方法如下：

```java
@Select("select * from question where creator = #{creator} limit #{offset}, #{size}")
List<Question> userListPage(@Param("creator") Long creator, @Param("offset") Integer offset, @Param("size") Integer size);

@Select("select count(1) from question where creator = #{creator}")
Integer userCount(@Param("creator") Long creator);
```

​	在 `QuestionService` 中新增查询用户发布问题分页的方法：

```java
public PaginationDTO userPageListWithBar(Long userId, Integer page, Integer size) {
	Integer offset = (page - 1) * size;
	List<QuestionDTO> questionDTOS = getQuestionDTOS(questionMapper.userListPage(userId, offset, size));

	Integer totalCount = questionMapper.userCount(userId);
	PaginationDTO paginationDTO = new PaginationDTO();
	paginationDTO.init(totalCount, page, size);
	paginationDTO.setData(questionDTOS.stream()
			.map(o -> (Object) o)
			.collect(Collectors.toList()));

	return paginationDTO;
}
```

​	在查询用户发布问题列表的网页右侧，还要显示用户已发布问题的数量，所以要在 `PaginationDTO` 中新增一个 `totalCount` 的整型属性，并且在初始化方法中赋值：

```java
@Data
public class PaginationDTO {
    // ...
    private Integer totalCount;
    
    public void init(Integer totalCount, Integer page, Integer size) {
        this.totalCount = totalCount;
        // ...
    }
}
```

​	创建一个处理用户消息中心的控制器 `ProfileController` ，代码如下：

```java
package life.majiang.community.controller;

import life.majiang.community.dto.PaginationDTO;
import life.majiang.community.dto.QuestionDTO;
import life.majiang.community.mapper.QuestionMapper;
import life.majiang.community.model.Question;
import life.majiang.community.model.User;
import life.majiang.community.service.QuestionService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletRequest;
import java.util.List;

@Controller
public class ProfileController {

    @Autowired
    QuestionService questionService;

    @GetMapping("/profile/{action}")
    public String profile(HttpServletRequest request,
                          Model model,
                          @PathVariable(name = "action") String action,
                          @RequestParam(name = "page", defaultValue = "1") Integer page,
                          @RequestParam(name = "size", defaultValue = "2") Integer size) {
        if (request.getSession() != null && request.getSession().getAttribute("user") == null) {
            return "redirect:/";
        }
        User user = (User) request.getSession().getAttribute("user");

        model.addAttribute("section", action);
        if ("questions".equals(action)) {
            model.addAttribute("sectionName", "我的问题");

            PaginationDTO paginationDTO = questionService.userPageListWithBar(user.getId(), page, size);
            model.addAttribute("pagination", paginationDTO);
        } else if ("replies".equals(action)) {
            model.addAttribute("sectionName", "最新回复");
        }

        return "profile";
    }

}
```

​	控制器可以根据不同的分支，决定 model 要返回页面渲染的数据填充的内容。

​	创建一个 `profile.html` ，代码如下：

```html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title th:text="${sectionName}"></title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/community.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>

    <div th:insert="navigation :: navigation"></div>

    <div class="container-fluid main">
        <div class="row">
            <div class="col-lg-9 col-md-12 col-sm-12 col-xs-12 question-list">
                <h2>
                    <span class="glyphicon glyphicon-pushpin" aria-hidden="true"></span>
                    <span th:text="${sectionName}"></span>
                </h2>
                <hr>
                <div class="media" th:each="question : ${pagination.data}">
                    <div class="media-left">
                        <a href="#">
                            <img class="media-object img-rounded" th:src="${question.user.avatarUrl}"/>
                        </a>
                    </div>
                    <div class="media-body">
                        <h4 class="media-heading" th:text="${question.title}"></h4>
                        <span class="text-desc">
                        <a class="question-tags" href="#" th:text="${question.tag}"></a> •
                        <span th:text="${question.user.name}"></span> 发表了文章 •
                        <span th:text="${question.commentCount}"></span> 个评论 •
                        <span th:text="${question.viewCount}"></span> 次浏览 •
                        <span th:text="${#dates.format(question.gmtCreate,'yyyy-MM-dd HH:mm')}"></span>
                    </span>
                    </div>
                </div>

                <div class="comm-pagination">
                    <nav aria-label="...">
                        <ul class="pagination">
                            <li th:if="${pagination.showFirstPage}">
                                <a th:href="@{'./'+${section}(page=1)}" aria-label="Previous"><span aria-hidden="true">&lt;&lt;</span></a>
                            </li>
                            <li th:if="${pagination.showPrevPage}">
                                <a th:href="@{'./'+${section}(page=${pagination.currentPage-1})}" aria-label="Previous"><span aria-hidden="true">&lt;</span></a>
                            </li>

                            <li th:each="page : ${pagination.pages}" th:class="${pagination.currentPage == page}? 'active' : ''">
                                <a th:href="@{'./'+${section}(page=${page})}" th:text="${page}"></a>
                            </li>

                            <li th:if="${pagination.showNextPage}">
                                <a th:href="@{'./'+${section}(page=${pagination.currentPage+1})}" aria-label="Next"><span aria-hidden="true">&gt;</span></a>
                            </li>
                            <li th:if="${pagination.showLastPage}">
                                <a th:href="@{'./'+${section}(page=${pagination.totalPages})}" aria-label="Next"><span aria-hidden="true">&gt;&gt;</span></a>
                            </li>
                        </ul>
                    </nav>
                </div>
            </div>

            <div class="col-lg-3 col-md-12 col-sm-12 col-xs-12 profile">
                <div class="list-group section">
                    <a href="/profile/questions" th:class="${section == 'questions'} ? 'list-group-item active' : 'list-group-item'">
                        我的问题
                        <span class="badge" th:if="${section == 'questions'}" th:text="${pagination.totalCount}"></span>
                    </a>
                    <a href="/profile/replies" th:class="${section == 'replies'} ? 'list-group-item active' : 'list-group-item'">
                        最新回复
                        <span class="badge" th:if="${section == 'replies'}" th:text="${pagination.totalCount}"></span>
                    </a>
                </div>
            </div>
        </div>
    </div>

</body>
</html>
```

​	启动应用，访问 `http://localhost:8080/profile/questions` ，效果如下：

<img src="screenshots\87-pagination.png" style="zoom:100%;"/>





# 16、拦截器

​	对于所有需要检查用户登录状态的页面，都在控制器里做检查比较繁琐，可以利用 Spring Web 的拦截器功能。

​	自定义一个拦截器需要继承 `org.springframework.web.servlet.HandlerInterceptor` 接口，可以选择实现以下方法：

- `preHandle(..)`：在实际处理程序运行之前
- `postHandle(..)`：处理程序运行后
- `afterCompletion(..)`：完整请求完成后

该`preHandle(..)`方法返回一个布尔值。您可以使用此方法来中断或继续执行链的处理。当此方法返回时`true`，处理程序执行链将继续。当它返回 false 时，`DispatcherServlet` 假设拦截器本身已经处理了请求（例如，呈现了适当的视图）并且不会继续执行执行链中的其他拦截器和实际处理程序。

有关如何配置拦截器的示例，请参阅 MVC 配置部分中的拦截[器](https://docs.spring.io/spring-framework/docs/5.3.28/reference/html/web.html#mvc-config-interceptors)。您还可以通过在各个实现上使用 setter 直接注册它们 `HandlerMapping`。

`postHandle` 方法对于 `@ResponseBody` 和 `ResponseEntity` 方法不太有用，因为它们的响应是在 `HandlerAdapter` 内、`postHandle` 之前写入和提交的。这意味着对响应进行任何更改（例如添加额外的标头）为时已晚。或者在这种情况下，您可以实现 ResponseBodyAdvice 并将其声明为 Controller Advice bean 或直接在 RequestMappingHandlerAdapter 上配置它。

​	首先定义一个拦截器 `SessionInterceptor` ，代码如下：

```java
package life.majiang.community.interceptor;

import life.majiang.community.mapper.UserMapper;
import life.majiang.community.model.User;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

@Component
@Slf4j
public class SessionInterceptor implements HandlerInterceptor {

    @Autowired
    UserMapper userMapper;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        log.info("SessionInterceptor preHandle: set user session!");

        // 若用户已登录并记录session，直接访问视图
        HttpSession session = request.getSession();
        if (session != null && session.getAttribute("user") != null) {
            return true;
        }

        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if ("token".equals(cookie.getName())) {
                    String token = cookie.getValue();
                    User user = userMapper.getByToken(token);
                    if (user != null) {
                        request.getSession().setAttribute("user", user);
                    }
                    break;
                }
            }
        }

        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        HandlerInterceptor.super.afterCompletion(request, response, handler, ex);
    }
}
```

​	重写 `preHandle` 方法，先判断当前请求会话中是否已有用户对象属性，有则直接返回；否则会进入下面的处理，先从 Cookie 中拿到登录 token，再用该 token 从数据库查询用户数据并放到会话属性中。

​	用使用该拦截器，还要先注册，需要定义一个 `WebMvcConfigurer` 的实现类，并重写 `addInterceptor` 方法注册拦截器，代码如下：

```java
package life.majiang.community.interceptor;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Autowired
    SessionInterceptor sessionInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(sessionInterceptor).addPathPatterns("/**");
    }

}
```

​	删除 `IndexController` 拿 Cookie token 查用户再放会话的代码。

​	启动应用，访问页面，发现样式渲染有问题

<img src="screenshots\89-pagination.png" style="zoom:100%;"/>

​	发现是 `/css/community.css` 的加载有问题404 NOT FOUND，查看日志，发现页面去获取样式文件时，Spring 将其当成一个 Web 请求来处理了。

<img src="screenshots\88-pagination.png" style="zoom:100%;"/>

​	为了解决该问题，`WebMvcConfigurer` 同样提供了注册资源处理器的方法，在 `WebConfig` 中新增代码：

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    // other code
  	
    private static final String[] CLASS_RESOURCE_LOACTIONS = {
            "classpath:/META-INF/resources/",
            "classpath:/resources/",
            "classpath:/static/",
            "classpath:/public/"
    };

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/**").addResourceLocations(CLASS_RESOURCE_LOACTIONS);
    }
}

```

​	重启应用访问，页面样式渲染恢复正常。





# 17、完成问题详情页面

​	我们希望通过 `http://localhost:8080/question/12` 这种形式访问某个问题的详情页面，首先这个访问路径的 id 要传递给后端，后端根据 id 从数据库中查到对应的记录。

​	在 `QuestionMapper` 中添加查询方法：

```java
    @Select("select * from question where id = #{id}")
    Question getById(@Param("id") Integer id);
```

​	在 `QuestionService` 中添加提供控制器调用的方法，在方法中调用 mapper 方法并将 bean 转换为 dto 返回，代码如下：

```java
    public QuestionDTO getById(Integer id) {
        Question question = questionMapper.getById(id);
        QuestionDTO questionDTO = new QuestionDTO();
        BeanUtils.copyProperties(question, questionDTO);
        User user = userMapper.getById(question.getCreator());
        questionDTO.setUser(user);

        return questionDTO;
    }
```

​	新增问题控制器 `QuestionController` ，代码如下：

```java
package life.majiang.community.controller;

import life.majiang.community.dto.QuestionDTO;
import life.majiang.community.service.QuestionService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@Controller
public class QuestionController {

    @Autowired
    QuestionService questionService;

    @GetMapping("/question/{id}")
    public String question(@PathVariable(name = "id") Integer id,
                           Model model) {

        QuestionDTO questionDTO = questionService.getById(id);
        model.addAttribute("question", questionDTO);

        return "question";
    }

}
```

​	后端部分完成，前端新增页面 `question.html` ，代码如下：

```java
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title th:text="${question.title}"></title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/community.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>

<div th:insert="navigation :: navigation"></div>

<div class="container-fluid main">
    <div class="row">
        <div class="col-lg-9 col-md-12 col-sm-12 col-xs-12 question-block">
            <h3 class="question-title"><span th:text="${question.title}"></span></h3>
            <span class="text-desc">
            作者：<span th:text="${question.user != null ? question.user.name : '匿名'}"></span> |
            发布时间：<span th:text="${#dates.format(question.gmtCreate,'yyyy-MM-dd HH:mm')}"></span> |
            阅读数：<span th:text="${question.viewCount}"></span>
            </span><br>
            <hr style="margin-top: 10px">

            <div class="col-lg-12 col-md-12 col-sm-12 col-xs-12" style="padding: 0px">
                <span class="question-content" th:text="${question.description}"></span>
                <hr>
                <span class="topic-tag">
                    <a th:text="${question.tag}"></a>
                </span><br>
                <hr>
            </div><br>

            <a th:if="${session.user != null && session.user.id == question.creator}"
               th:href="@{'/publish/'+${question.id}}" class="community-menu">
                <span class="glyphicon glyphicon-pencil" aria-hidden="true">编辑</span>
            </a>
            <hr>
        </div>
        <div class="col-lg-3 col-md-12 col-sm-12 col-xs-12" style="padding: 20px">
            <h5>发起人</h5>
            <div class="media">
                <div class="media-left">
                    <a href="#">
                        <img class="media-object img-rounded" th:src="${question.user != null ? question.user.avatarUrl : '/images/xhy.jpg'}">
                    </a>
                </div>
                <div class="media-body">
                    <h5 class="media-heading" th:text="${question.user != null ? question.user.name : '匿名'}"></h5>
                    <span class="text-desc">
                        <span th:text="${question.user != null} ? ${question.user.bio} : '这个人很神秘'"/>
                    </span>
                </div>
            </div>
            <hr>
            <h4>相关问题</h4>
        </div>
    </div>
</div>

</body>
</html>
```

​	访问首页，点击标题即可进入问题详情页

<img src="screenshots\90-question.png" style="zoom:100%;"/>

​	问题详情页的展现如下：

<img src="screenshots\91-question.png" style="zoom:100%;"/>





# 18、修复登录bug

​	在原来的登录处理中，每次登录都会往用户表插入一条数据，导致同一用户的多次登录产生多条数据

<img src="screenshots\95-loginout.png" style="zoom:90%;"/>

​	这会导致用户下次登录后无法编辑自己上次登录发布的问题，所以在原来往用户表插数的逻辑应该优化为，若用户之前登录过，则更新除了用户 github 账户ID外的其他信息；若用户没登过，才实际插入一条数据的逻辑。

​	为了方便处理逻辑的复用，以及调用代码的间接，首先定义一个 `UserService` 的服务类，代码如下：

```java
package life.majiang.community.service;

import life.majiang.community.mapper.UserMapper;
import life.majiang.community.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    @Autowired
    private UserMapper userMapper;

    public void createOrUpdate(User user) {
        User dbUser = userMapper.getByAccountId(user.getAccountId());
        if (dbUser == null) {
            // 用户尚未授权登录过，插表
            userMapper.insert(user);
        } else {
            // 用户授权登录过，更新用户信息
            dbUser.setName(user.getName());
            dbUser.setToken(user.getToken());
            dbUser.setGmtModified(user.getGmtModified());
            dbUser.setBio(user.getBio());
            dbUser.setAvatarUrl(user.getAvatarUrl());
            userMapper.update(dbUser);
        }

    }
}
```

​	之前 `UserMapper` 还没有更新数据的 SQL，因此在 mapper 中新增对应方法：

```java
    @Update("update c_user set name = #{name}, token = #{token}, gmt_modified = #{gmtModified}, bio = #{bio}, avatar_url = #{avatarUrl} where account_id = #{accountId}")
    public void update(User dbUser);
```

​	最后修改 `AuthorizeController` 的回调方法，将获取到 github 账户信息后由直接插入改为调用 `UserService` 的方法：

```java
userService.createOrUpdate(user);
//userMapper.insert(user);
```

​	在用户登录后的导航栏，点击用户会显示下拉列表，其中有个退出登录的功能，需要编写针对 `/logout` 请求的控制器方法，在授权控制器中新增登出方法，代码如下：

```java
    // 用户登出
    @GetMapping("/logout")
    public String logout(HttpServletRequest request,
                         HttpServletResponse response) {
        // 清除用户会话
        request.removeAttribute("user");

        // 清除cookie
        Cookie cookie = new Cookie("token", null);
        cookie.setMaxAge(0);
        cookie.setPath("/");
        response.addCookie(cookie);

        return "redirect:/";
    }
```

​	在用户登录后，可看到 cookies 中的 token

<img src="screenshots\92-loginout.png" style="zoom:100%;"/>

​	在点击用户退出登录后，再查看 cookie token 信息已被清空

<img src="screenshots\93-loginout.png" style="zoom:100%;"/>

​	启动应用，登录，报错，发现是查询用户返回了多个数据

<img src="screenshots\94-loginout.png" style="zoom:100%;"/>

​	查询发现相同的 accountId 的数据有两条，删除第一条数据

<img src="screenshots\95-loginout.png" style="zoom:100%;"/>

​	重新登录，点击消息中心，可以看到重新登录后，用户依然可以编辑之前发布的问题，用户表更新了时间和token，并没实际插入数据

<img src="screenshots\97-loginout.png" style="zoom:100%;"/>

<img src="screenshots\98-loginout.png" style="zoom:100%;"/>





# 19、实现问题编辑功能

​	对某个以及发布的问题信息进行编辑修改，首先要回显问题信息，在 `PublishController` 中新增编辑方法，代码如下：

```java
    @GetMapping("/publish/{id}")
    public String edit(@PathVariable(name = "id") Integer id,
                       Model model) {
        QuestionDTO question = questionService.getById(id);
        model.addAttribute("title", question.getTitle());
        model.addAttribute("description", question.getDescription());
        model.addAttribute("tag", question.getTag());
        model.addAttribute("id", question.getId());

        return "publish";
    }
```

​	当提交修改时，可以复用原来的 `doPublish` 方法，更新问题信息也需要将 id 上送给该方法，所以修改方法头，新增入参，因为该方法要复用问题发布和编辑，所以新的参数要声明为 `required = false` ，同时原来插入的问题表的代码也要调整为，若上送id则更新；否则插入。所以要先在 `QustionService` 中新增方法如下：

```java
    public void createOrUpdate(Question question) {
        if (question.getId() == null) {
            question.setGmtCreate(System.currentTimeMillis());
            question.setGmtModified(question.getGmtCreate());
            questionMapper.insert(question);
        } else {
            question.setGmtModified(question.getGmtCreate());
            questionMapper.update(question);
        }
    }
```

​	在 `QuestionMapper` 中新增方法：

```java
    @Update("update question set title = #{title}, description = #{description}, tag = #{tag}, gmt_modified = #{gmtModified} where id = #{id}")
    void update(Question question);
```

​	最后修改 `PublishController` ：

```java
    @PostMapping("/publish")
    public String doPublish(@RequestParam(value = "title", required = true) String title,
                            @RequestParam(value = "description", required = true) String description,
                            @RequestParam(value = "tag", required = true) String tag,
                            @RequestParam(value = "id", required = false) Integer id,
                            HttpServletRequest request,
                            Model model) {
        // 方便页面回显，这样页面已经填了的信息不用再重填一次
        model.addAttribute("title", title);
        model.addAttribute("description", description);
        model.addAttribute("tag", tag);
        model.addAttribute("id", id);

        if (StringUtils.isEmpty(title)) {
            model.addAttribute("error", "标题不能为空");
            return "publish";
        }
        if (StringUtils.isEmpty(description)) {
            model.addAttribute("error", "问题补充不能为空");
            return "publish";
        }
        if (StringUtils.isEmpty(tag)) {
            model.addAttribute("error", "标签不能为空");
            return "publish";
        }

        // 如果cookie中不存在token，或根据token查无用户，则返回报错
        if (request.getSession() == null || request.getSession().getAttribute("user") == null) {
            model.addAttribute("error", "用户未登录");
            return "publish";
        }

        User user = (User) request.getSession().getAttribute("user");
        // 记录提交问题带数据库
        Question question = new Question();
        question.setTitle(title);
        question.setDescription(description);
        question.setCreator(user.getId());
        question.setTag(tag);
        //questionMapper.insert(question);
        questionService.createOrUpdate(question);

        return "redirect:/";
    }
```

​	启动应用，访问某个问题 

<img src="screenshots\99-edit.png" style="zoom:100%;"/>

​	提交修改时却返回 tomcat 报错 `Request header is too large ` ，原因是默认的 HTTP 请求头部数据大小为8KB，超过这一大小就会报错，所以调整该参数为100KB

<img src="screenshots\100-edit.png" style="zoom:100%;"/>

​	重新进入编辑页面，再次提交修改，不会再报上述错误。





# 20、MyBatis Generator

## （1）使用配置

​	MyBatis Generator 是一个 MyBatis 代码和配置的生产工具。它会连接到数据库，根据配置文件中指定的表，获取表的字段信息，生成 model 和 mapper 配置文件，并且生成对应的 ModelExample，各种复杂的数据库操作，可以调用 ModelExample 各种方法来达到目标。

​	Maven 项目要引入该工具，需要在 pom.xml 中配置：

```xml
<project>
    ...
	<build>
		<plugins>
		    ...
			<plugin>
                <groupId>org.mybatis.generator</groupId>
                <artifactId>mybatis-generator-maven-plugin</artifactId>
                <version>1.4.2</version>
                <!-- 插件运行时连接数据库需要依赖对应的数据库驱动，所以驱动库要配置上 -->
                <dependencies>
                    <dependency>
                        <groupId>com.h2database</groupId>
                        <artifactId>h2</artifactId>
                        <version>2.1.210</version>
                        <scope>runtime</scope>
                    </dependency>
                </dependencies>
            </plugin>
        </plugins>
    </build>

</project>
```

​	配置完插件后，就可以使用以下 maven 命令来生成 MyBatis 的类和配置文件：

```shell
# -D是可选参数，表示生成的代码和配置文件如果已存在是否要覆盖，可以使用的参数详见文档
mvn mybatis-generator:generate -Dmybatis.generator.overwrite=true
```

​	插件运行要知道去连接哪个数据库，针对哪些表的生成 Java 类和  Mapper，还有其他更详细的配置信息，这些配置都会放在一个配置文件中，从文档中可以知道默认配置文件路径为 `src/main/resources/generatorConfig.xml`

<img src="screenshots\101-MBG.png" style="zoom:100%;"/>

​	所以在资源目录下创建一个 `generatorConfig.xml` ，参考文档的配置文件示例初始内容如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
  PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
  "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">

<generatorConfiguration>
  <classPathEntry location="/Program Files/IBM/SQLLIB/java/db2java.zip" />

  <context id="DB2Tables" targetRuntime="MyBatis3">
    <jdbcConnection driverClass="COM.ibm.db2.jdbc.app.DB2Driver"
        connectionURL="jdbc:db2:TEST"
        userId="db2admin"
        password="db2admin">
    </jdbcConnection>

    <javaTypeResolver >
      <property name="forceBigDecimals" value="false" />
    </javaTypeResolver>

    <javaModelGenerator targetPackage="test.model" targetProject="\MBGTestProject\src">
      <property name="enableSubPackages" value="true" />
      <property name="trimStrings" value="true" />
    </javaModelGenerator>

    <sqlMapGenerator targetPackage="test.xml"  targetProject="\MBGTestProject\src">
      <property name="enableSubPackages" value="true" />
    </sqlMapGenerator>

    <javaClientGenerator type="XMLMAPPER" targetPackage="test.dao"  targetProject="\MBGTestProject\src">
      <property name="enableSubPackages" value="true" />
    </javaClientGenerator>

    <table schema="DB2ADMIN" tableName="ALLTYPES" domainObjectName="Customer" >
      <property name="useActualColumnNames" value="true"/>
      <generatedKey column="ID" sqlStatement="DB2" identity="true" />
      <columnOverride column="DATE_FIELD" property="startDate" />
      <ignoreColumn column="FRED" />
      <columnOverride column="LONG_VARCHAR_FIELD" jdbcType="VARCHAR" />
    </table>

  </context>
</generatorConfiguration>
```

​	下面逐个阅读文档分析每个配置元素的作用，决定如何修改和删除：

* **classPathEntry**：当需要加载插件运行需要的类库时，可以通过该元素指定，我们在引入插件时就顺带指定了驱动依赖，所以该元素可去除。
* **context**：元素用于指定生成一组对象的环境。子元素用于指定要连接的数据库、要生成的对象类型以及要内省的表。

  这里用的是 H2 所以将 id 改成 `H2Tables` ，targetRuntime 属性是跟生成文件兼容性相关的，这里暂不需要改。

* **jdbcConnection**：配置数据库连接，需要配置驱动、连接URL、用户名密码等，将其修改为

  ><jdbcConnection driverClass="org.h2.Driver"
  >​                connectionURL="jdbc:h2:~/community"
  >​                userId="root"
  >​                password="root">
  ></jdbcConnection>

* **javaTypeResolver**：该元素用于定义 Java 类型解析器的属性，Java 类型解析器用于根据数据库列信息计算 Java 类型。默认的 Java 类型解析器尝试通过在可能的情况下替换整数类型（长整型、整数、短整型等）来使 JDBC DECIMAL 和 NUMERIC 类型更易于使用。如果不希望出现此行为，请将属性“forceBigDecimals”设置为“true”。

* **javaModelGenerator**：于定义 Java 模型生成器的属性。Java 模型生成器构建与内省表匹配的主键类、记录类和示例查询类。该元素是元素必需的子元素。

  我们希望将代码生成到 `life.majiang.community.mbg.model` 这个包下，代码源目录为 `src/main/java` ，配置修改为：

  > <javaModelGenerator targetPackage="life.majiang.community.mbg.model" targetProject="src/main/java">
  > ​    <property name="enableSubPackages" value="true" />
  > ​    <property name="trimStrings" value="true" />
  > </javaModelGenerator>

* **sqlMapGenerator**：元素用于定义 SQL 映射生成器的属性。SQL 映射生成器为每个内省表构建一个 MyBatis 格式的 SQL 映射 XML 文件。

  我们希望生成的 mapper.xml 放到 src/main/resources 下的 mapper目录，因此配置修改为：

  > <sqlMapGenerator targetPackage="mapper"  targetProject="src/main/resources">
  > ​    <property name="enableSubPackages" value="true" />
  > </sqlMapGenerator>


* **javaClientGenerator**：该元素用于定义 Java 客户端生成器的属性。Java 客户端生成器构建 Java 接口和类，以便轻松使用生成的 Java 模型和 XML 映射文件。对于MyBatis，生成的对象采用映射器接口的形式。

  我们希望将代码生成到 `life.majiang.community.mbg.mapper这个包下，代码源目录为 `src/main/java` ，配置修改为：

  > <javaClientGenerator type="XMLMAPPER" targetPackage="life.majiang.community.mbg.mapper"  targetProject="src/main/java">
  > ​    <property name="enableSubPackages" value="true" />
  > </javaClientGenerator>


* **table**：元素用于选择数据库中的表进行内省。选定的表将导致为每个表生成以下对象：

  - MyBatis 格式的 SQL Map 文件
  - 形成表“模型”的一组类，包括：
    - 与表的主键匹配的类（如果表有主键）。
    - 用于匹配表中非主键字段和非 BLOB 字段的类。如果有主键，该类将扩展主键。
    - 用于保存表中任何 BLOB 字段（如果有）的类。该类将根据表的配置扩展前两个类之一。
    - 用于在不同的“by example”方法（selectByExample、deleteByExample）中生成动态 where 子句的类。
  - （可选）MyBatis 映射器接口

  **schema** 不是必需的可以删除；

  **useActualColumnNames** 表示是否使用实际列名，为 true 表示使用实际列名，比如数据库字段为 `user_name`，则生成的 Java 类字段名也为 `user_name` ；为 false 表示自动进行驼峰转换，Java 类字段名会生成为 `userName` 。默认是 false，所以可以删除保留默认配置即可；

  **generatedKey** 指定插入数据是否自动生成 key，没有这个需求，删除配置；

  **columnOverride** 是否要指定覆盖生成的列名，没有这个需求，删除配置；

  **ignoreColumn** 是否要忽略某一列，没有这个需求，删除配置；

  我们想对数据库表 `c_user` 生成 `User` 类，所以配置修改为：

  > <table tableName="C_USER" domainObjectName="User" />

综上所述，修改后的配置文件如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">

<generatorConfiguration>
    <context id="H2Tables" targetRuntime="MyBatis3">
        <!-- 数据库连接 -->
        <jdbcConnection driverClass="org.h2.Driver"
                        connectionURL="jdbc:h2:~/community"
                        userId="root"
                        password="root">
        </jdbcConnection>

        <!-- Java类型解析器，在将数据库列类型转换为Java类型时
             如果想要将 DECIMAL、NUMERIC 转换为 BigDecimal，则将 forceBigDecimals 属性设置为 true -->
        <javaTypeResolver >
            <property name="forceBigDecimals" value="false" />
        </javaTypeResolver>

        <!-- Java 模型生成器
            targetPackage - 指定生成类存放的包
            targetProject - 代码目录
            enableSubPackages - 该属性用于选择MyBatis Generator是否根据内省表的目录和模式为对象生成不同的Java包。
                                例如，假设模式 MYSCHMA 中有一个表 MYTABLE。还假设 targetPackage 属性设置为“com.mycompany”。
                                如果此属性为 true，则为表生成的对象将放置在包“com.mycompany.myschema”中。
                                如果该属性为 false，则生成的对象将放置在“com.mycompany”架构中。
            trimStrings - 该属性用于选择 MyBatis Generator 是否添加代码来修剪从数据库返回的字符字段中的空格。如果您的数据库将数据存储在 CHAR 字段而不是 VARCHAR 字段中，这会很有用。

         -->
        <javaModelGenerator targetPackage="life.majiang.community.mbg.model" targetProject="src/main/java">
            <property name="enableSubPackages" value="true" />
            <property name="trimStrings" value="true" />
        </javaModelGenerator>

        <!-- SQL mapper.xml 生成器 -->
        <sqlMapGenerator targetPackage="mapper"  targetProject="src/main/resources">
            <property name="enableSubPackages" value="true" />
        </sqlMapGenerator>

        <!-- Java 客户端生成器构建 Java 接口和类，以便轻松使用生成的 Java 模型和 XML 映射文件。 -->
        <javaClientGenerator type="XMLMAPPER" targetPackage="life.majiang.community.mbg.mapper"  targetProject="src/main/java">
            <property name="enableSubPackages" value="true" />
        </javaClientGenerator>

        <!-- 指定要对哪些表生成类 -->
        <table tableName="C_USER" domainObjectName="User" />
        <table tableName="QUESTION" domainObjectName="Question" />

    </context>
</generatorConfiguration>
```

​	执行 maven 生成命令

<img src="screenshots\102-MBG.png" style="zoom:100%;"/>

​	可以看到顺利生成了 model 类、mapper 接口和 mapper.xml

<img src="screenshots\103-MBG.png" style="zoom:60%;"/>



## （2）修改数据服务

​	接下来就是使用生成的代码和配置。

​	`QuestionService` 代码修改如下（新增包和类）：

```java
package life.majiang.community.mbg.service;

import life.majiang.community.mbg.dto.PaginationDTO;
import life.majiang.community.mbg.dto.QuestionDTO;
import life.majiang.community.mbg.mapper.QuestionMapper;
import life.majiang.community.mbg.mapper.UserMapper;
import life.majiang.community.mbg.model.Question;
import life.majiang.community.mbg.model.QuestionExample;
import life.majiang.community.mbg.model.User;
import org.apache.ibatis.session.RowBounds;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class QuestionService {

    @Autowired
    private QuestionMapper questionMapper;

    @Autowired
    private UserMapper userMapper;

    public List<QuestionDTO> list() {
        QuestionExample example = new QuestionExample();
        example.createCriteria();
        return getQuestionDTOS(questionMapper.selectByExample(example));
    }

    public List<QuestionDTO> pageList(Integer page, Integer size) {
        // 计算分页偏移量
        Integer offset = (page - 1) * size;
        QuestionExample example = new QuestionExample();
        example.createCriteria();
        return getQuestionDTOS(questionMapper.selectByExampleWithRowbounds(example, new RowBounds(offset, size)));
    }

    public PaginationDTO list(Integer page, Integer size) {
        // 获得要展现页的数据
        Integer offset = (page - 1) * size;
        QuestionExample example = new QuestionExample();
        example.createCriteria();
        List<QuestionDTO> questionDTOS = getQuestionDTOS(questionMapper.selectByExampleWithRowbounds(example, new RowBounds(offset, size)));

        Integer totalCount = Integer.valueOf(questionMapper.countByExample(example) + "");
        return getPaginationDTO(totalCount, page, size, questionDTOS);
    }

    public PaginationDTO list(Long userId, Integer page, Integer size) {
        Integer offset = (page - 1) * size;
        QuestionExample example = new QuestionExample();
        example.createCriteria()
                .andCreatorEqualTo(Integer.valueOf(userId + ""));
        List<QuestionDTO> questionDTOS = getQuestionDTOS(questionMapper.selectByExampleWithRowbounds(example, new RowBounds(offset, size)));

        Integer totalCount = Integer.valueOf(questionMapper.countByExample(example) + "");
        return getPaginationDTO(totalCount, page, size, questionDTOS);
    }


    private List<QuestionDTO> getQuestionDTOS(List<Question> questions) {
        List<QuestionDTO> questionDTOS = new ArrayList<>();

        for (Question question : questions) {
            QuestionDTO questionDTO = new QuestionDTO();
            BeanUtils.copyProperties(question, questionDTO);
            questionDTO.setUser(userMapper.selectByPrimaryKey(Long.valueOf(question.getCreator())));
            questionDTOS.add(questionDTO);
        }

        return questionDTOS;
    }

    private PaginationDTO getPaginationDTO(Integer totalCount, Integer page, Integer size, List<QuestionDTO> questionDTOS) {
        PaginationDTO paginationDTO = new PaginationDTO();
        paginationDTO.init(totalCount, page, size);
        paginationDTO.setData(questionDTOS.stream()
                .map(o -> (Object) o)
                .collect(Collectors.toList()));

        return paginationDTO;
    }

    public QuestionDTO getById(Integer id) {
        Question question = questionMapper.selectByPrimaryKey(id);
        QuestionDTO questionDTO = new QuestionDTO();
        BeanUtils.copyProperties(question, questionDTO);
        User user = userMapper.selectByPrimaryKey((long) question.getCreator());
        questionDTO.setUser(user);

        return questionDTO;
    }

    public void createOrUpdate(Question question) {
        if (question.getId() != null) {
            questionMapper.updateByPrimaryKeySelective(question);
        } else {
            questionMapper.insert(question);
        }
    }
}
```

​	新增 `UserService` ，代码如下：

```java
package life.majiang.community.mbg.service;

import life.majiang.community.mbg.mapper.UserMapper;
import life.majiang.community.mbg.model.User;
import life.majiang.community.mbg.model.UserExample;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@Slf4j
public class UserService {

    @Autowired
    private UserMapper userMapper;

    public void createOrUpdate(User user) {
        UserExample userExample = new UserExample();
        userExample.createCriteria()
                   .andAccountIdEqualTo(user.getAccountId());
        List<User> users = userMapper.selectByExample(userExample);
        User dbUser = users.get(0);
        if (dbUser != null) {
            log.debug("login: exists user");

            // 用户已存在，更新信息即可
            dbUser.setName(user.getName());
            dbUser.setToken(user.getToken());
            dbUser.setGmtModified(System.currentTimeMillis());
            dbUser.setAvatarUrl(user.getAvatarUrl());

            userExample.createCriteria()
                       .andIdEqualTo(dbUser.getId());
            userMapper.updateByExampleSelective(dbUser, userExample);
        } else {
            log.debug("login: new user");
            // 用户不存在，插入数据
            userMapper.insert(user);
        }
    }

}
```



## （3）修改控制器

​	创建新的控制器包 `life.majiang.community.mbg.controller` 。

​	新增控制器 `IndexController` ，代码如下：

```java
package life.majiang.community.mbg.controller;

import life.majiang.community.mbg.dto.PaginationDTO;
import life.majiang.community.mbg.service.QuestionService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletRequest;

@Controller
public class IndexController {

    @Autowired
    private QuestionService questionService;

    @GetMapping("/")
    public String index(HttpServletRequest request,
                        Model model,
                        @RequestParam(name = "page", defaultValue = "1") Integer page,
                        @RequestParam(name = "size", defaultValue = "2") Integer size) {
        PaginationDTO questionDTOS = questionService.list(page, size);
        model.addAttribute("pagination", questionDTOS);

        return "index";
    }

}
```

​	新增控制器 `AuthorizeController`，代码如下：

```java
package life.majiang.community.mbg.controller;

import life.majiang.community.mbg.model.User;
import life.majiang.community.mbg.provider.GithubProvider;
import life.majiang.community.mbg.provider.dto.AccessTokenDTO;
import life.majiang.community.mbg.provider.dto.GithubUser;
import life.majiang.community.mbg.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.UUID;

@Controller
@Slf4j
public class AuthorizeController {

    @Value("${github.client.id}")
    private String clientId;

    @Value("${github.client.secret}")
    private String clientSecret;

    @Value("${github.redirect.uri}")
    private String redirectUrl;

    @Autowired
    private GithubProvider githubProvider;

    @Autowired
    private UserService userService;

    @GetMapping("/callback")
    public String callback(@RequestParam(name = "code") String code,
                           @RequestParam(name = "state") String state,
                           HttpServletRequest request,
                           HttpServletResponse response) {
        AccessTokenDTO accessTokenDTO = new AccessTokenDTO();
        accessTokenDTO.setClientId(clientId);
        accessTokenDTO.setClientSecret(clientSecret);
        accessTokenDTO.setCode(code);
        accessTokenDTO.setState(state);
        accessTokenDTO.setRedirectUri(redirectUrl);
        log.info("AccessTokenDTO = " + accessTokenDTO);

        String accessToken = githubProvider.getAccessToken(accessTokenDTO);
        GithubUser githubUser = null;
        if (accessToken != null) {
            log.info("accessToken=" + accessToken);
            githubUser = githubProvider.getGithubUser(accessToken);
        }

        if (githubUser != null && githubUser.getId() != null) {
            log.info("Github OAuth succ");

            User user = new User();
            user.setAccountId(String.valueOf(githubUser.getId()));
            user.setName(githubUser.getName());
            user.setToken(UUID.randomUUID().toString());
            user.setGmtCreate(System.currentTimeMillis());
            user.setGmtModified(user.getGmtCreate());
            user.setBio(githubUser.getBio());
            user.setAvatarUrl(githubUser.getAvatarUrl());
            userService.createOrUpdate(user);

            // 设置用户登录会话
            //request.getSession().setAttribute("user", user);
            Cookie cookie = new Cookie("token", user.getToken());
            cookie.setPath("/");
            cookie.setMaxAge(3600 + 8 * 3600);   // 设置超时时间东八区时区要加八小时
            response.addCookie(cookie);

            return "redirect:/";
        } else {
            // 登录失败，重新登录
            log.info("Github OAuth fail");
            return "redirect:/";
        }
    }

}
```

​	新增控制器 `ProfileController`，代码如下：

```java
package life.majiang.community.mbg.controller;

import life.majiang.community.mbg.dto.PaginationDTO;
import life.majiang.community.mbg.model.User;
import life.majiang.community.mbg.service.QuestionService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletRequest;

@Controller
public class ProfileController {

    @Autowired
    QuestionService questionService;

    @GetMapping("/profile/{action}")
    public String profile(HttpServletRequest request,
                          Model model,
                          @PathVariable(name = "action") String action,
                          @RequestParam(name = "page", defaultValue = "1") Integer page,
                          @RequestParam(name = "size", defaultValue = "2") Integer size) {
        if (request.getSession() != null && request.getSession().getAttribute("user") == null) {
            return "redirect:/";
        }
        User user = (User) request.getSession().getAttribute("user");

        model.addAttribute("section", action);
        if ("questions".equals(action)) {
            model.addAttribute("sectionName", "我的问题");

            PaginationDTO paginationDTO = questionService.list(user.getId(), page, size);
            model.addAttribute("pagination", paginationDTO);
        } else if ("replies".equals(action)) {
            model.addAttribute("sectionName", "最新回复");
        }

        return "profile";
    }

}
```

​	新增 `PublishController`，代码如下：

```java
package life.majiang.community.mbg.controller;

import life.majiang.community.mbg.dto.QuestionDTO;
import life.majiang.community.mbg.model.Question;
import life.majiang.community.mbg.model.User;
import life.majiang.community.mbg.service.QuestionService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletRequest;

@Controller
public class PublishController {

    @Autowired
    QuestionService questionService;

    @GetMapping("/publish")
    public String publish(HttpServletRequest request) {
        if (request.getSession() != null && request.getSession().getAttribute("user") == null) {
            return "redirect:/";
        }
        return "publish";
    }

    @PostMapping("/publish")
    public String doPublish(@RequestParam(value = "title") String title,
                            @RequestParam(value = "description") String description,
                            @RequestParam(value = "tag") String tag,
                            @RequestParam(value = "id", required = false) Integer id,
                            HttpServletRequest request,
                            Model model) {
        // 方便页面回显，这样页面已经填了的信息不用再重填一次
        model.addAttribute("title", title);
        model.addAttribute("description", description);
        model.addAttribute("tag", tag);
        model.addAttribute("id", id);

        if (StringUtils.isEmpty(title)) {
            model.addAttribute("error", "标题不能为空");
            return "publish";
        }
        if (StringUtils.isEmpty(description)) {
            model.addAttribute("error", "问题补充不能为空");
            return "publish";
        }
        if (StringUtils.isEmpty(tag)) {
            model.addAttribute("error", "标签不能为空");
            return "publish";
        }

        // 如果cookie中不存在token，或根据token查无用户，则返回报错
        if (request.getSession() == null || request.getSession().getAttribute("user") == null) {
            model.addAttribute("error", "用户未登录");
            return "publish";
        }

        User user = (User) request.getSession().getAttribute("user");
        // 记录提交问题带数据库
        Question question = new Question();
        question.setId(id);
        question.setTitle(title);
        question.setDescription(description);
        question.setGmtCreate(System.currentTimeMillis());
        question.setGmtModified(question.getGmtCreate());
        question.setCreator(Integer.valueOf(user.getId() + ""));
        question.setTag(tag);
        questionService.createOrUpdate(question);

        return "redirect:/";
    }

    @GetMapping("/publish/{id}")
    public String edit(@PathVariable(name = "id") Integer id,
                       Model model) {
        QuestionDTO questionDTO = questionService.getById(id);

        model.addAttribute("title", questionDTO.getTitle());
        model.addAttribute("description", questionDTO.getDescription());
        model.addAttribute("tag", questionDTO.getTag());
        model.addAttribute("id", questionDTO.getId());

        return "publish";
    }

}
```

​	新增 `QuestionController`，代码如下：

```java
package life.majiang.community.mbg.controller;

import life.majiang.community.mbg.dto.QuestionDTO;
import life.majiang.community.mbg.service.QuestionService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@Controller
public class QuestionController {

    @Autowired
    QuestionService questionService;

    @GetMapping("/question/{id}")
    public String question(@PathVariable(name = "id") Integer id,
                           Model model) {

        QuestionDTO questionDTO = questionService.getById(id);
        model.addAttribute("question", questionDTO);

        return "question";
    }

}
```



## （4）测试

​	为了避免启动类注册bean冲突，修改启动类注解，代码如下：

```java
package life.majiang.community;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication(scanBasePackages = {"life.majiang.community.mbg"})
@MapperScan({"life.majiang.community.mbg.mapper"})
public class CommunityApplication {

    public static void main(String[] args) {
        SpringApplication.run(CommunityApplication.class, args);
    }

}
```

​	测试用户登录时，发现如果是第一次访问的客户插入 c_user 表会报错，因为 MBG 默认生成的 mapper.xml 的 id 为 `insert`  的插入标签会生成所有的字段，而 id 在表定义中是自增的，所以修改对应的 xml 配置为如下即可：

```xml
  <insert id="insert" parameterType="life.majiang.community.mbg.model.User">
    insert into C_USER (ACCOUNT_ID, NAME,
      TOKEN, GMT_CREATE, GMT_MODIFIED, 
      BIO, AVATAR_URL)
    values (#{accountId,jdbcType=VARCHAR}, #{name,jdbcType=VARCHAR},
      #{token,jdbcType=CHAR}, #{gmtCreate,jdbcType=BIGINT}, #{gmtModified,jdbcType=BIGINT}, 
      #{bio,jdbcType=VARCHAR}, #{avatarUrl,jdbcType=VARCHAR})
  </insert>
```

​	非首次登录用户会更新 c_user 数据也会报错，因为生成的 xml 配置也会更新 id 字段，即使值没变，因其为唯一索引字段，也会报错，因此 id 为 `updateByExampleSelective` 的更新标签也需要移除 id 字段的更新，修正后配置如下：

```xml
  <update id="updateByExampleSelective" parameterType="map">
    update C_USER
    <set>
      <if test="row.accountId != null">
        ACCOUNT_ID = #{row.accountId,jdbcType=VARCHAR},
      </if>
      <if test="row.name != null">
        NAME = #{row.name,jdbcType=VARCHAR},
      </if>
      <if test="row.token != null">
        TOKEN = #{row.token,jdbcType=CHAR},
      </if>
      <if test="row.gmtCreate != null">
        GMT_CREATE = #{row.gmtCreate,jdbcType=BIGINT},
      </if>
      <if test="row.gmtModified != null">
        GMT_MODIFIED = #{row.gmtModified,jdbcType=BIGINT},
      </if>
      <if test="row.bio != null">
        BIO = #{row.bio,jdbcType=VARCHAR},
      </if>
      <if test="row.avatarUrl != null">
        AVATAR_URL = #{row.avatarUrl,jdbcType=VARCHAR},
      </if>
    </set>
    <if test="example != null">
      <include refid="Update_By_Example_Where_Clause" />
    </if>
  </update>
```

​	为了保留代码不需要注释的基础上切回原来不使用 MBG 的代码，启动类注解需要调整为：

```java
package life.majiang.community;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.FilterType;

// 不扫描life.majiang.community.mbg包及其子包下使用注解配置的bean
@SpringBootApplication
@ComponentScan(excludeFilters = {@ComponentScan.Filter(type = FilterType.REGEX, pattern = "life.majiang.community.mbg.*")})
public class CommunityApplication {

    public static void main(String[] args) {
        SpringApplication.run(CommunityApplication.class, args);
    }

}
```

相关文档：

【官网】https://mybatis.org/generator/quickstart.html

* [使用Maven运行 MyBatis Generator](https://mybatis.org/generator/running/runningWithMaven.html)
* [MBG XML配置](https://mybatis.org/generator/configreference/xmlconfig.html)

【掘金】https://juejin.cn/post/6844904116422983694





# 21、WEB 异常处理

​	默认情况下，Spring Boot 提供了一个 `/error` 映射，以合理的方式处理所有错误，并且它在 servlet 容器中被注册为一个“全局”的错误页面。对于机器客户端，它会生成一个 JSON 响应，其中包含错误、HTTP 状态和异常消息的详细信息。对于浏览器客户端，有一个“白标签”错误视图以 HTML 格式呈现相同的数据（要自定义它，请添加一个解析错误的视图）。

​	要替代默认的异常报错白页，可以在 `/src/main/resources/templates` 目录下创建一个 error.html 的错误页，代码如下所示：

```html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>鸭鸭社区</title>
    <meta http-equiv="content-type" content="text/html" charset="UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/community.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>
<div th:insert="navigation :: navigation"></div>

<div class="container-fluid">
    <div class="jumbotron">
        <h1>出错啦！！！</h1>
        <p>服务太热啦，要不然稍等下再来试试~</p>
        <p><a class="btn btn-primary btn-lg" href="/" role="button">回到主页</a></p>
    </div>
</div>
</body>
</html>
```

​	启动应用，访问 `http://localhost:8080/question/301`，不存在ID为301的问题，所以访问该页面应该跳到错误白页，因为我们自定义了错误页，所以会访问 error.html，效果如下：

<img src="screenshots/替换报错白页.png"/>

​	但是页面上只是显示固定的报错信息，我们希望有个组件可以拦截异常报错，并且把异常信息渲染展现到页面上。

​	程序会抛出各种异常，想根据不同异常情况在错误页上显示不同的报错信息，需要定义一个使用 `@ControllerAdvice` 注解的错误处理器。

```java
package life.majiang.community.advice;

import life.majiang.community.exception.CustomizeException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

import javax.servlet.RequestDispatcher;
import javax.servlet.http.HttpServletRequest;

@ControllerAdvice
@Slf4j
public class CustomizedErrorHandler extends ResponseEntityExceptionHandler {

    @ResponseBody
    @ExceptionHandler(Exception.class)
    public ModelAndView handleControllerException(HttpServletRequest request, Throwable ex, Model model) {
        if (ex instanceof CustomizeException) {
            model.addAttribute("message", ex.getMessage());
        } else {
            model.addAttribute("message", "服务太热啦，要不然你稍候再来试试~");
        }
        return new ModelAndView("error");
    }

}
```

​	该错误处理器需要继承类 `ResponseEntityExceptionHandler`，当程序抛出 CustomizeException 异常时，返回异常信息，默认情况下返回报错信息**服务太热啦，要不然你稍候再来试试~**

​	在业务代码中，经常会定义各种业务异常，这里我们定义一个通用异常，它是一个运行时异常，这样就不需要在程序中强制捕获，而由错误处理器来处理。

```java
package life.majiang.community.exception;

public class CustomizeException extends RuntimeException {

    private String message;
    private Integer code;

    public CustomizeException(ICustomizeErrorCode errorCode) {
        this.code = errorCode.getCode();
        this.message = errorCode.getMessage();
    }

    @Override
    public String getMessage() {
        return message;
    }

    public Integer getCode() {
        return code;
    }

}
```

​	相同的错误信息通常会出现在程序的不同角落，一种比较优雅的方式是定义一个枚举类，把系统定义错误码和报错信息集中放在一起，避免对象定义爆炸。

​	我们可能会分类定义不同的报错类型，所以先定义一个通用的接口，代码如下：

```java
package life.majiang.community.exception;

public interface ICustomizeErrorCode {

    Integer getCode();
    String getMessage();

}
```

​	再定义报错码枚举类，代码如下：

```java
package life.majiang.community.exception;

public enum CustomizeErrorCode implements ICustomizeErrorCode {
    QUESTION_NOT_FOUND(2001, "你找到问题不在了，要不要换个试试？");

    private Integer code;
    private String message;

    CustomizeErrorCode(Integer code, String message) {
        this.code = code;
        this.message = message;
    }

    @Override
    public Integer getCode() {
        return code;
    }

    @Override
    public String getMessage() {
        return message;
    }
}
```

​	修改报错页，显示报错码和报错信息：

```html
...
<div class="container-fluid">
    <div class="jumbotron">
        <h1>出错啦！！！</h1>
        <p>错误码：<span th:text="${code}"></span></p>
        <p th:text="${message}">服务太热啦，要不然稍等下再来试试~</p>
        <p><a class="btn btn-primary btn-lg" href="/" role="button">回到主页</a></p>
    </div>
</div>
...
```

​	当访问一个不存在的问题时 `http://localhost:8080/question/1000`，在代码里抛出异常，如下所示：

```java
    public QuestionDTO getById(Integer id) {
        Question question = questionMapper.getById(id);
        if (question == null) {
            throw new CustomizeException(CustomizeErrorCode.QUESTION_NOT_FOUND);
        }
        ...
    }
```

​	会被异常处理器所处理，并将异常信息显示到错误页，如下所示：

<img src="screenshots\104-error.png"/>

​	当异常无法被错误处理器处理时，比如404、500之类的异常，需要自定义实现一个错误控制器，参考代码如下：

```java
package life.majiang.community.controller;

import org.springframework.boot.web.servlet.error.ErrorController;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.Collections;
import java.util.Map;

@Controller
@RequestMapping("${server.error.path:${error.path:/error}}")
public class CustomizeController implements ErrorController {

    @Override
    public String getErrorPath() {
        return "/error";
    }

    @RequestMapping(produces = MediaType.TEXT_HTML_VALUE)
    public ModelAndView errorHtml(HttpServletRequest request,
                                  Model model) {
        HttpStatus status = getStatus(request);
        if (status.is4xxClientError()) {
            model.addAttribute("message", "你这个请求错了吧，要不然换个姿势？");
            model.addAttribute("code", status.value() + " " +status.getReasonPhrase());
        }
        if (status.is5xxServerError()) {
            model.addAttribute("message", "服务器冒烟了，要不然你稍后再试试！！！");
            model.addAttribute("code", status.value() + " " +status.getReasonPhrase());
        }
        return new ModelAndView("error");
    }

    private HttpStatus getStatus(HttpServletRequest request) {
        Integer statusCode = (Integer) request
                .getAttribute("javax.servlet.error.status_code");
        if (statusCode == null) {
            return HttpStatus.INTERNAL_SERVER_ERROR;
        }
        try {
            return HttpStatus.valueOf(statusCode);
        }
        catch (Exception ex) {
            return HttpStatus.INTERNAL_SERVER_ERROR;
        }
    }
}
```

​	访问 `http://localhost:8080/questions` ，效果如下：

<img src="screenshots\105-error.png"/>

【相关文档】

[Error Handler](https://springdoc.cn/spring-boot/web.html#web.servlet.spring-mvc) 





# 22、阅读数功能

​	在问题的详情页，目前的阅读数是0不变的，我们希望每次用户进入某个问题详情页时，统计的阅读数同步+1。

​	在 Mapper 接口里先新增递增阅读数的方法：

```java
@Mapper
public interface QuestionMapper {
	...
    @Update("update question set view_count = view_count + 1 where id = #{id}")
    Integer incView(@Param("id") Integer id);
}
```

​	在 `QuestionService` 中添加对应的方法：

```java
@Service
public class QuestionService {
	...
    public void incView(Integer id) {
        questionMapper.incView(id);
    }
}
```

​	最后在 `QuestionService` 里调用该服务方法：

```java
@Controller
public class QuestionController {

    @Autowired
    QuestionService questionService;

    @GetMapping("/question/{id}")
    public String question(@PathVariable(name = "id") Integer id,
                           Model model) {
        questionService.incView(id);
        QuestionDTO questionDTO = questionService.getById(id);
        model.addAttribute("question", questionDTO);

        return "question";
    }

}
```

​	访问某个问题页面，发现每次都会累加阅读数，达到效果

<img src="screenshots\106-viewCount.png"/>

​	再访问首页，阅读数也正常显示

<img src="screenshots\107-viewCount.png"/>





# 23、评论功能

## （1）回复和异常处理

​	我们希望实现类似下面的评论功能

<img src="screenshots\112-comment.png"/>

​	当发表评论报错时，不是跳转到错误页面，也是有个弹窗之类的提示

<img src="screenshots\113-comment.png" style="zoom:70%;"/>

​	这就要求后端数据接口和前端要实现前后端分离，交互使用JSON格式。	

​	首先建立一张评论表，要有评论问题id、评论人id、评论类型、内容、点赞数、创建时间、更新时间等字段，由此得到建表 DDL：

```sql
create table COMMENT
(
    id           bigint auto_increment,
    parent_id    bigint not null,
    type         int    not null,
    commentator  int    not null,
    comment      varchar(300) not null,
    like_count   bigint default 0,
    gmt_create   bigint not null,
    gmt_modified bigint not null
);
```

​	执行该脚本后，建立表对应的对象

```java
package life.majiang.community.model;

import lombok.Data;

@Data
public class Comment {

    private Long id;
    private Long parentId;
    private Integer type;
    private Integer commentator;
    private String content;
    private Long likeCount;
    private Long gmtCreate;
    private Long gmtModified;

}
```

​	发布评论时需要往表里插数据，新增对应的 Mapper 接口

```java
package life.majiang.community.mapper;

import life.majiang.community.model.Comment;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface CommentMapper {

    @Insert("insert into comment(parent_id, type, commentator, content, like_count, gmt_create, gmt_modified) values (#{parentId}, #{type}, #{commentator}, #{content}, #{likeCount}, #{gmtCreate}, #{gmtModified})")
    public Integer insert(Comment comment);

}
```

​	业务代码逻辑判断与数据库操作解耦，封装一个 service

```java
package life.majiang.community.service;

import life.majiang.community.exception.CustomizeErrorCode;
import life.majiang.community.exception.CustomizeException;
import life.majiang.community.mapper.CommentMapper;
import life.majiang.community.model.Comment;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class CommentService {

    @Autowired
    private CommentMapper commentMapper;

    public void addComment(Comment comment) {
        if (comment.getParentId() == null || comment.getParentId() == 0) {
            throw new CustomizeException(CustomizeErrorCode.TARGET_PARAM_NOT_FOUND);
        }      
        commentMapper.insert(comment);
    }

}
```

​	评论会通过 POST 请求提交到 `/comment` ，新增控制器，代码如下：

```java
	package life.majiang.community.controller;

import life.majiang.community.dto.CommentDTO;
import life.majiang.community.dto.ResultDTO;
import life.majiang.community.exception.CustomizeErrorCode;
import life.majiang.community.mapper.CommentMapper;
import life.majiang.community.model.Comment;
import life.majiang.community.model.User;
import life.majiang.community.service.CommentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.http.HttpServletRequest;

@Controller
public class CommentController {

    @Autowired
    private CommentService commentService;

    @PostMapping("/comment")
    @ResponseBody
    public Object comment(HttpServletRequest request,
                          @RequestBody CommentDTO commentDTO) {
        User user = (User) request.getSession().getAttribute("user");
        if (user == null) {
            return ResultDTO.errorOf(CustomizeErrorCode.NO_LOGIN);
        }

        Comment comment = new Comment();
        comment.setParentId(commentDTO.getParentId());
        comment.setType(commentDTO.getType());
        comment.setCommentator(Integer.valueOf(user.getId()+""));
        comment.setContent(commentDTO.getContent());
        comment.setGmtCreate(System.currentTimeMillis());
        comment.setGmtModified(comment.getGmtCreate());

        commentService.addComment(comment);

        return ResultDTO.okOf();
    }

}
```

​	上送的数据主要是问题id、评论内容和父id。当评论为一级评论时，父id为问题id；当评论为二级评论时，父id为评论id，这里定义一个 DTO 来接收上送数据

```java
package life.majiang.community.dto;

import lombok.Data;

@Data
public class CommentDTO {

    private Long parentId;
    private String content;
    private Integer type;

}
```

​	请求是 JSON，我们希望返回也是一个 JSON，所以先定义一个返回数据对象 `ResultDTO`

```java
package life.majiang.community.dto;

import life.majiang.community.exception.CustomizeErrorCode;
import lombok.Data;
import org.springframework.web.bind.annotation.RequestParam;

@Data
public class ResultDTO {

    private Integer code;
    private String message;

    public static ResultDTO errorOf(Integer code, String message) {
        ResultDTO resultDTO = new ResultDTO();
        resultDTO.setCode(code);
        resultDTO.setMessage(message);
        return resultDTO;
    }

    public static ResultDTO errorOf(CustomizeErrorCode customizeErrorCode) {
        return errorOf(customizeErrorCode.getCode(), customizeErrorCode.getMessage());
    }

    public static ResultDTO errorOf(CustomizeException ex) {
        return errorOf(ex.getCode(), ex.getMessage());
    }  
  
    public static ResultDTO okOf() {
        ResultDTO resultDTO = new ResultDTO();
        resultDTO.setCode(0);
        resultDTO.setMessage("处理成功");
        return resultDTO;
    }
}
```

​	针对用户未登录和未上送问题id，在错误码枚举类中新增字典

```java
public enum CustomizeErrorCode implements ICustomizeErrorCode {
    ...
    NO_LOGIN(2002, "未登录不能进行评论，请先登录"),
    TARGET_PARAM_NOT_FOUND(2003, "未选中任何问题或评论进行回复");
    ...
}
```

​	用户登录后才允许评论，所以要先判断用户登录状态，如果未登录则返回报错

<img src="screenshots\108-comment.png"/>	

​	在插入用户评论前先判断是否上送问题id，为上送则抛出异常

<img src="screenshots\111-comment.png"/>

​	但是发现异常时，按照之前的错误处理，默认是会返回报错页面，我们不想返回页面而是一个json，需要修改错误处理器，代码如下：

```java
package life.majiang.community.advice;

import com.alibaba.fastjson.JSON;
import life.majiang.community.dto.ResultDTO;
import life.majiang.community.exception.CustomizeErrorCode;
import life.majiang.community.exception.CustomizeException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

import javax.servlet.RequestDispatcher;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

@ControllerAdvice
@Slf4j
public class CustomizedErrorHandler extends ResponseEntityExceptionHandler {

    @ResponseBody
    @ExceptionHandler(Exception.class)
    public ModelAndView handleControllerException(HttpServletRequest request,
                                                  HttpServletResponse response,
                                                  Throwable ex,
                                                  Model model) {
        if ("application/json".equals(request.getContentType())) {
            // 返回JSON
            ResultDTO resultDTO;
            if (ex instanceof CustomizeException) {
                resultDTO = ResultDTO.errorOf((CustomizeException) ex);
            } else {
                resultDTO = ResultDTO.errorOf(CustomizeErrorCode.SYSTEM_ERROR);
            }
            try {
                response.setContentType("application/json");
                response.setStatus(200);
                response.setCharacterEncoding("UTF-8");
                PrintWriter writer = response.getWriter();
                writer.write(JSON.toJSONString(resultDTO));
                writer.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            
            return null;
        } else {
            // 展示报错页
            if (ex instanceof CustomizeException) {
                model.addAttribute("message", ex.getMessage());
                model.addAttribute("code", ((CustomizeException) ex).getCode());
            } else {
                model.addAttribute("message", CustomizeErrorCode.SYSTEM_ERROR.getMessage());
                model.addAttribute("code", CustomizeErrorCode.SYSTEM_ERROR.getCode());
            }
            return new ModelAndView("error");
        }
    }

}
```

​	再次启动程序测试，问题id未上送时，返回json的响应

<img src="screenshots\114-comment.png"/>

​	用户正常登录后，上送数据也完整时，这时候发布评论正常，数据表多了一条评论数据

<img src="screenshots\109-comment.png"/>

<img src="screenshots\110-comment.png"/>

​	继续完善处理逻辑，首先强制要求上送评论类型，否则抛出异常，所以要定义一个评论类型的枚举类

```java
package life.majiang.community.enums;

public enum CommentTypeEnum {
    QUESTION(1),
    COMMENT(2);
    private Integer type;

    CommentTypeEnum(Integer type) {
        this.type = type;
    }

    public Integer getType() {
        return type;
    }

    public static boolean isExist(Integer type) {
        for (CommentTypeEnum value : CommentTypeEnum.values()) {
            if (value.getType() == type) {
                return true;
            }
        }
        return false;
    }
}ja
```

​	如果评论类型是评论，则只需要往 comment 表中插入数据即可；如果评论时对问题的评论，则还要更新 question 问题的评论数。

​	`QuestionMapper` 要新增一个更新评论数的方法

```java
@Update("update question set comment_count = comment_count + #{commentCount} where id = #{id}")
Integer updateCommentCount(Question question);
```

​	在 `CustomizeErrorCode` 中新增报错码枚举字典

```java
    TARGET_PARAM_WRONG(2004, "上送评论类型错误"),
    COMMENT_NOT_FOUND(2005, "你找到评论不在了，要不要换个试试？");
```

​	修改 `CommentService` 处理逻辑

```java
package life.majiang.community.service;

import life.majiang.community.enums.CommentTypeEnum;
import life.majiang.community.exception.CustomizeErrorCode;
import life.majiang.community.exception.CustomizeException;
import life.majiang.community.mapper.CommentMapper;
import life.majiang.community.mapper.QuestionMapper;
import life.majiang.community.model.Comment;
import life.majiang.community.model.Question;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class CommentService {

    @Autowired
    private CommentMapper commentMapper;

    @Autowired
    private QuestionMapper questionMapper;

    public void addComment(Comment comment) {
        if (comment.getParentId() == null || comment.getParentId() == 0) {
            throw new CustomizeException(CustomizeErrorCode.TARGET_PARAM_NOT_FOUND);
        }
        if (comment.getType() == null || !CommentTypeEnum.isExist(comment.getType())) {
            throw new CustomizeException(CustomizeErrorCode.TARGET_PARAM_WRONG);
        }
        if (comment.getType() == CommentTypeEnum.COMMENT.getType()) {
            // 回复评论
            Comment dbComment = commentMapper.selectById(comment.getParentId());
            if (dbComment == null) {
                throw new CustomizeException(CustomizeErrorCode.COMMENT_NOT_FOUND);
            }
            commentMapper.insert(comment);
        } else {
            // 回复问题
            Question question = questionMapper.getById(Integer.valueOf(comment.getParentId() + ""));
            if (question == null) {
                throw new CustomizeException(CustomizeErrorCode.QUESTION_NOT_FOUND);
            }
            question.setCommentCount(1);
            commentMapper.insert(comment);
            questionMapper.updateCommentCount(question);
        }
    }

}
```

​	启动程序测试，若评论类型有误，则报错

<img src="screenshots\116-comment.png"/>

​	正常评论

<img src="screenshots\115-comment.png"/>

​	访问首页，正常显示评论数

<img src="screenshots\117-comment.png"/>



## （2）事务

​	在提交评论时，我们希望往评论表里新增一条数据和问题评论数+1的操作要么全部成功要么全部失败，这就需要借助 Spring 事务，Spring 事务支持声明式和编程式事务管理，声明式事务是 Spring 基于 AOP 实现的，在方法或类上使用 `@Transactional` 注解的非侵入式的事务管理。

​	在 `CommentService` 方法中使用该注解

```java
@Transactional
public void addComment(Comment comment) {
   ...
   commentMapper.insert(comment);
   questionMapper.updateCommentCount(question);
}
```

​	为了演示事务的效果，修改 `QuestionMapper` 的更新评论数的方法，由于 Question 类中不存在 commentCount2 的属性，所以执行该操作时会失败，因为该操作与往评论表中插入数据是同个事务，因此评论表插入数据的操作会被回滚。

```java
@Update("update question set comment_count = comment_count + #{commentCount2} where id = #{id}")
Integer updateCommentCount(Question question);
```

​	为了演示不使用事务的情况下数据操作不一致的问题，先将事务注解注释，启动应用，访问首页查看问题id为1的问题当前评论数为2

<img src="screenshots\117-comment.png"/>

​	使用 postman 发起请求

<img src="screenshots\118-comment.png"/>

​	异常日志显示报错原因

<img src="screenshots\119-comment.png"/>

​	查看数据库，成功新增了一条评论数据

<img src="screenshots\120-comment.png"/>

​	但是问题的评论数并没有更新为3

<img src="screenshots\121-comment.png"/>

​	如果在使用事务的情况下，则不会产生这种数据不一致的问题，评论表不会新增记录因为问题表评论数没有成功+1。



## （3）页面提交回复

​	首先要完善页面元素，显示登录用户头像和用户名，添加文本域和回复按钮，修改 `question.html` 代码如下：

```html
...
<div class="row">
	<div class="col-lg-9 col-md-12 col-sm-12 col-xs-12 question-block">
		<div class="col-lg-12 col-md-12 col-sm-12 col-xs-12">
			<h3 class="question-title"><span th:text="${question.title}"></span></h3>
			<span class="text-desc">
			作者：<span th:text="${question.user != null ? question.user.name : '匿名'}"></span> |
			发布时间：<span th:text="${#dates.format(question.gmtCreate,'yyyy-MM-dd HH:mm')}"></span> |
			阅读数：<span th:text="${question.viewCount}"></span>
			</span><br>
			<hr style="margin-top: 10px">

			<div class="col-lg-12 col-md-12 col-sm-12 col-xs-12" style="padding: 0px">
				<span class="question-content" th:text="${question.description}"></span>
				<hr>
				<span class="topic-tag">
					<a th:text="${question.tag}"></a>
				</span><br>
				<hr>
			</div><br>

			<a th:if="${session.user != null && session.user.id == question.creator}"
			   th:href="@{'/publish/'+${question.id}}" class="community-menu">
				<span class="glyphicon glyphicon-pencil" aria-hidden="true">编辑</span>
			</a>
			<hr>
		</div>

		<div class="col-lg-12 col-md-12 col-sm-12 col-xs-12" th:if="${session.user != null}">
			<input type="hidden" id="questionId" th:value="${question.id}"/>
			<div class="media">
				<div class="media-left">
					<a href="#">
						<img class="media-object img-rounded" th:src="${question.user != null ? question.user.avatarUrl : '/images/xhy.jpg'}">
					</a>
				</div>
				<div class="media-body">
					<h5 class="media-heading comment-user" th:text="${question.user != null ? question.user.name : '匿名'}"></h5>
					<span class="text-desc">
				</span>
				</div>
			</div>
			<textarea class="form-control comment-content" id="commentText" rows="3"></textarea>
			<button type="button" class="btn btn-success btn-publish" onclick="comment()">回复</button>
		</div>
	</div>
    ...
</div
...
```

​	页面效果如下：

<img src="screenshots\122-comment.png"/>	

​	创建 `community.js` ，编写点击按钮时前端向后端发起请求的处理，并将该 js 引入问题详情页中。

```javascript
function comment() {
    var questionId = $("#questionId").val();
    var comment = $("#commentText").val();
    console.log(questionId);
    console.log(comment);
    $.ajax({
        type: "POST",
        contentType : "application/json",
        url: "/comment",
        data: JSON.stringify({
            "parentId" : questionId,
            "content" : comment,
            "type" : 1
        }),
        success: function (response) {
            console.log(response);
            if (response.code != 0) {
                alert(response.message);
            } else {
                $("#commentText").val("");
            }
        },
        dataType: "json"
    });
}
```

​	点击回复按钮时，会获取问题id和评论内容发送给后端，如果返回响应码非成功，则弹窗提示错误原因，否则清空文本域的评论内容。

​	

##（4）页面不刷新登录

​	当用户登录状态进入问题页评论提交评论之前，在另一个页面退出登录，则提交评论返回报错是未登录时应该跳转登录，修改 `community.js` 代码如下：

```javascript
function comment() {
    var questionId = $("#questionId").val();
    var comment = $("#commentText").val();
    console.log(questionId);
    console.log(comment);
    $.ajax({
        type: "POST",
        contentType : "application/json",
        url: "/comment",
        data: JSON.stringify({
            "parentId" : questionId,
            "content" : comment,
            "type" : 1
        }),
        success: function (response) {
            console.log(response);
            if (response.code != 0) {
                if (response.code == 2002) {
                    var isAccepted = confirm(response.message);
                    if (isAccepted) {
                        window.open("https://github.com/login/oauth/authorize?client_id=ce46b85af14a2d21447b&redirect_uri=http://localhost:8080/callback&scope=user&state=2");
                        window.localStorage.setItem("closable", true);
                    }
                } else {
                    alert(response.message);
                }
            } else {
                $("#commentText").val("");
            }
        },
        dataType: "json"
    });
}
```

​	效果如下所示：

<img src="screenshots\123-comment.png"/>

​	用户登录后默认会跳转到首页 `index.html` ，如果 localstorage 中存在 `closable` 的数据，证明本次访问首页是因为其他页面未登录跳转导致，应立即将当前页面关掉，在 `index.html` 中添加脚本如下：

```javascript
    <script type="application/javascript">
        window.onload = function () {
            var closable = window.localStorage.getItem("closable");
            if (closable == "true") {
                window.close();
                window.localStorage.removeItem("closable");
            }
        }
    </script>
```

​	这里现在评论成功了，但是却没有显示最新的评论，所以页面加载时需要有个评论列表。



## （5）显示评论列表

​	首先添加前端页面列表元素，在 `question.html` 中问题详情和评论框之间添加元素：

```html
...
<!-- 评论列表 -->
<h4 style="margin-left: 15px;">
	<span th:text="${question.commentCount}"></span> 个回复
</h4>
<hr>
<div class="col-lg-12 col-md-12 col-sm-12 col-xs-12">
	<div class="media" th:each="comment : ${comments}">
		<div class="media-left">
			<a href="#">
				<img class="media-object img-rounded small-avatar" th:src="${comment.user != null ? comment.user.avatarUrl : '/images/xhy.jpg'}">
			</a>
		</div>
		<div class="media-body">
			<h5 class="media-heading" th:text="${comment.user != null ? comment.user.name : '匿名'}"></h5>
			<div class="comment-text" th:text="${comment.getContent()}"></div>
			<span class="text-desc">
				<a class="question-tags cursor-link">
					<span class="glyphicon glyphicon-thumbs-up icon" aria-hidden="true"></span>0赞
				</a>
			</span>
			<span class="text-desc">
				<a class="question-tags cursor-link">
					<span class="glyphicon glyphicon-comment icon" aria-hidden="true"></span>回复
				</a>
			</span>
			<span class="text-color-999 pull-right" th:text="${#dates.format(question.gmtCreate,'yyyy-MM-dd')}"></span>
		</div>
		<hr class="comment-hr">
	</div>
</div>
...
```

​	效果如下：

<img src="screenshots\124-comment.png"/>

​	后端要返一个 `comments` 的数据列表给前端，数据列表的每一个数据都对应一个 `CommentDTO`对象，将原来的 `CommentDTO` 类改名为 `CommentCreateDTO` ，新增的 DTO 中要组合 `User` 对象，因为每个评论都要显示用户头像和用户名，代码如下：

```java
package life.majiang.community.dto;

import life.majiang.community.model.User;
import lombok.Data;

@Data
public class CommentDTO {

    private Long id;
    private Long parentId;
    private Integer type;
    private Integer commentator;
    private String content;
    private Long likeCount;
    private Long gmtCreate;
    private Long gmtModified;
    private User user;

}
```

​	在 `CommentMapper` 中新增根据问题号查询评论的方法：

```java
@Select("select * from comment where parent_id = #{parentId}")
List<Comment> selectByParentId(@Param("parentId") Long parentId);
```

​	每条评论都带有评论人的 id，这样就可以得到评论人的 id 列表，因为同个评论人可能回复多条评论，因此将列表去重成集合，再根据集合去查询 `User` 表，这样就拿到发表评论的所有用户信息，在 `UserMapper` 中新增根据用户 id 列表查询用户列表的方法：

```java
@Select({"<script>",
			"select * from c_user where id in",
				"<foreach collection='ids' item='id' open='(' separator=',' close=')'>",
					"#{id}",
				"</foreach>",
		"</script>"
})
public List<User> selectByIds(@Param("ids") List<Long> ids);
```

​	在 `CommentService` 中新增根据问题号查 DTO 数据对象列表的方法，代码如下：

```java
public List<CommentDTO> listByQuestionId(Integer parentId) {
	// 根据问题号查询该问题下评论数
	List<Comment> comments = commentMapper.selectByParentId(Long.valueOf(parentId + ""));
	if (comments.size() == 0) {
		new ArrayList<CommentDTO>();
	}

	// 因为可能有多条评论是同个人评的，所以这里先去重
	Set<Long> commentators = comments.stream().map(comment -> comment.getCommentator()).collect(Collectors.toSet());
	List<Long> userIds = new ArrayList<>();
	userIds.addAll(commentators);
	List<User> users = userMapper.selectByIds(userIds);
	Map<Long, User> userMap = users.stream().collect(Collectors.toMap(user -> user.getId(), user -> user));

	List<CommentDTO> commentDTOS = comments.stream().map(comment -> {
		CommentDTO commentDTO = new CommentDTO();
		BeanUtils.copyProperties(comment, commentDTO);
		commentDTO.setUser(userMap.get(comment.getCommentator()));
		return commentDTO;
	}).collect(Collectors.toList());

	return commentDTOS;
}
```

​	查到的用户 id，先去重，再转换为列表，然后去查用户列表，再通过 lambda 语法转换为 Map，Comment 列表再转换为 CommentDTO 列表，每条数据转换时根据用户 id 从 Map 中获取用户对象设置到 DTO 中，最后返回 CommentDTO 列表。

​	修改 `QuestionController` 方法，添加对 `CommentService.listByQuestionId()` 的调用并设置到返回渲染的 model 中，代码如下：

```java
@Controller
public class QuestionController {

	...

    @GetMapping("/question/{id}")
    public String question(@PathVariable(name = "id") Integer id,
                           Model model) {
        questionService.incView(id);
        QuestionDTO questionDTO = questionService.getById(id);

        // 获取问题评论
        List<CommentDTO> comments = commentService.listByQuestionId(id);

        model.addAttribute("question", questionDTO);
        model.addAttribute("comments", comments);

        return "question";
    }

}
```

​	延续上一小节的问题，评论列表只是解决了加载页面时显示评论的问题，评论成功时，只是清空了原来文本域，并没有在页面上显示刚才新增的元素，也没有更新累加总评论数。为实现这个功能，首先在页面中新增默认不显示的模板：

```html
<!-- 新增评论模板 -->
<div style="display: none" id="comment-template">
	<div class="media">
		<div class="media-left">
			<a href="#">
				<img class="media-object img-rounded small-avatar" src="/images/xhy.jpg"/>
			</a>
		</div>
		<div class="media-body">
			<h5 class="media-heading">张三</h5>
			<div class="comment-text">我是评论内容</div>
			<span class="text-desc">
				<a class="question-tags cursor-link">
					<span class="glyphicon glyphicon-thumbs-up icon" aria-hidden="true"></span>0赞
				</a>
			</span>
			<span class="text-desc">
				<a class="question-tags cursor-link">
					<span class="glyphicon glyphicon-comment icon" aria-hidden="true"></span>回复
				</a>
			</span>
			<span class="text-color-999 pull-right">2024-01-12</span>
		</div>
		<hr class="comment-hr">
	</div>
</div>
```

​	当提交评论接口返回成功时，获取模板元素，将评论数据设置到模板中对应位置，最后将其 append 到评论列表后，最后评论总数+1，js 代码如下：

```javascript
...
success: function (response) {
	console.log(response);
	if (response.code != 0) {
		if (response.code == 2002) {
			var isAccepted = confirm(response.message);
			if (isAccepted) {
				window.open("https://github.com/login/oauth/authorize?client_id=ce46b85af14a2d21447b&redirect_uri=http://localhost:8080/callback&scope=user&state=2");
				window.localStorage.setItem("closable", true);
			}
		} else {
			alert(response.message);
		}
	} else {
		var userAvatar = $("#userAvatar")[0].src;
		var userName = $("#userName").text();

		var template = $("#comment-template").children(".media");
		template.find(".small-avatar").attr("src", userAvatar);
		template.find(".media-heading").text(userName);
		template.find(".comment-text").text(comment);
		template.find(".pull-right").text(getFormatDate());
		$("#comment-divider").after(template.html())
		$("#commentText").val("");

		// 评论总数加1
		var commentCount = parseInt($("#comment-count").text());
		$("#comment-count").text(commentCount + 1);
	}
}
...
```



## （6）二级评论

​	我们想要实现一个如下二级评论的效果，如下所示：

<img src="screenshots\125-subComment.png"/>

​	当页面初始化加载问题评论时，只会加载显示一级评论，只有点击一级评论回复时才会加载二级评论，所以后端需要有一个提供前端使用的根据一级评论id获取二级评论列表的接口，因为之前已经有根据问题id加载一级评论列表的功能，只需要在原有基础上修改即可，在评论表中一级评论的 parentId 为问题 id，二级评论的 parentId 为一级评论 id。

​	修改 `CommentMapper` ：

```xml
...
@Select("select * from comment where parent_id = #{parentId} and type = #{type} order by gmt_create desc")
List<Comment> selectByParentId(@Param("parentId") Long parentId, @Param("type") Integer type);
...
```

​	修改 `CommentService` ：

```java
...
public List<CommentDTO> listByQuestionId(Long  parentId, CommentTypeEnum type) {
	// 根据问题号查询该问题下评论数
	List<Comment> comments = commentMapper.selectByParentId(parentId, type.getType());
	if (comments.size() == 0) {
		return new ArrayList<CommentDTO>();
	}

	// 因为可能有多条评论是同个人评的，所以这里先去重
	Set<Long> commentators = comments.stream().map(comment -> comment.getCommentator()).collect(Collectors.toSet());
	List<Long> userIds = new ArrayList<>();
	userIds.addAll(commentators);
	List<User> users = userMapper.selectByIds(userIds);
	Map<Long, User> userMap = users.stream().collect(Collectors.toMap(user -> user.getId(), user -> user));

	List<CommentDTO> commentDTOS = comments.stream().map(comment -> {
		CommentDTO commentDTO = new CommentDTO();
		BeanUtils.copyProperties(comment, commentDTO);
		commentDTO.setUser(userMap.get(comment.getCommentator()));
		return commentDTO;
	}).collect(Collectors.toList());

	return commentDTOS;
}
...
```

​	在 `CommentController` 中新增获取子评论的方法：

```java
@GetMapping("/subComment/{id}")
@ResponseBody
public Object getSubComment(HttpServletRequest request,
							@PathVariable(value = "id") Long id) {
	User user = (User) request.getSession().getAttribute("user");
	if (user == null) {
		return ResultDTO.errorOf(CustomizeErrorCode.NO_LOGIN);
	}

	List<CommentDTO> commentDTOS = commentService.listByQuestionId(id, CommentTypeEnum.COMMENT);
	ResultDTO<List<CommentDTO>> resultDTO = ResultDTO.okOf();
	resultDTO.setData(commentDTOS);
	return resultDTO;
}
```

​	完成后端接口后，再来实现前端功能，先在每条一级评论元素中增加二级评论的 div，并且默认情况下是不显示的。

```java
<div class="media" th:each="comment : ${comments}">
	<div class="media-left">
		...
	</div>
	<div class="media-body">
		<h5 class="media-heading" th:text="${comment.user != null ? comment.user.name : '匿名'}"></h5>
		<div class="comment-text" th:text="${comment.getContent()}"></div>
		<span class="text-desc">
			<a class="question-tags cursor-link">
				<span class="glyphicon glyphicon-thumbs-up icon" aria-hidden="true"></span>0赞
			</a>
		</span>
		<span class="text-desc">
			<a class="question-tags cursor-link" th:data-id="${comment.getId()}" onclick="toggleSubComments(this)">
				<span class="glyphicon glyphicon-comment icon" aria-hidden="true"></span>0回复
			</a>
		</span>
		<span class="text-color-999 pull-right" th:text="${#dates.format(question.gmtCreate,'yyyy-MM-dd HH:mm:ss')}"></span>
		<!-- 二级评论 -->
		<div class="col-lg-12 col-md-12 col-sm-12 col-xs-12 sub-comments collapse" th:id="${'subCommentsBlock-'+comment.getId()}">
			<div class="col-lg-12 col-md-12 col-sm-12 col-xs-12" th:id="${'subComments-'+comment.getId()}">
			</div>
			<div class="col-lg-12 col-md-12 col-sm-12 col-xs-12 background-color-eee com-margin-top">
				<input type="text" class="form-control comment-content" placeholder="评论一下..."/>
				<button type="button" class="btn btn-success btn-publish" th:data-id="${comment.getId()}" onclick="subComment(this)">回复</button>
			</div>
		</div>
	</div>
	<hr class="comment-hr"/>
</div>
```

​	我们想要达到的效果是，第一次点一级评论回复时，会调接口获取二级评论并加载显示列表出来，后面每次点击只会切换二级评论列表的页面元素显示和隐藏，如果提交了二级评论会在列表中追加显示在前面。

​	初始化加载二级评论的 js 代码如下：

```javascript
/**
 * 切换二级评论
 */
function toggleSubComments(e) {
    var id = e.getAttribute("data-id");
    var loaded = e.getAttribute("loaded-subComments");
    console.log(loaded);
    // 用loaded-subComments判断是否已加载过子评论
    if (loaded !== "true") {
        $.ajax({
            type: "GET",
            contentType : "application/json",
            url: "/subComment/" + id,
            data: {},
            success: function (response) {
                console.log(response);
                if (response.code !== 0) {
                    if (response.code === 2002) {
                        var isAccepted = confirm(response.message);
                        if (isAccepted) {
                            window.open("https://github.com/login/oauth/authorize?client_id=ce46b85af14a2d21447b&redirect_uri=http://localhost:8080/callback&scope=user&state=2");
                            window.localStorage.setItem("closable", true);
                        }
                    } else {
                        alert(response.message);
                    }
                } else {
                    e.setAttribute("loaded-subComments", true);
                    var commentData = response.data;
                    var template = $("#comment-template").children(".media");
                    for (var i = 0; i < commentData.length; i++) {
                        template.find(".small-avatar").attr("src", commentData[i].user.avatarUrl);
                        template.find(".media-heading").text(commentData[i].user.name);
                        template.find(".comment-text").text(commentData[i].content);
                        template.find(".pull-right").text(getFormatDate(commentData[i].gmtCreate));
                        if (i === commentData.length - 1) {
                            template.find(".comment-hr").hide();
                        }
                        $("#subComments-" + id).append(template.prop("outerHTML"));
                    }
                    template.find(".comment-hr").show();
                    $("#subCommentsBlock-" + id).addClass("in");
                }
            },
            dataType: "json"
        });
    } else {
        var subCommentsBlock = $("#subCommentsBlock-" + id);
        if (subCommentsBlock.hasClass("in")) {
            subCommentsBlock.removeClass("in");
        } else {
            subCommentsBlock.addClass("in");
        }
    }
}
```

​	效果如下，初始化不显示二级评论，点击回复后展现，再点击隐藏

<img src="screenshots\126-subComment.png"/>

<img src="screenshots\127-subComment.png"/>

​	提交一二级评论本质都是在评论表里插入一条数据，所以将提交评论的方法进行封装，一二级评论都去调用封装的方法：

```javascript
/**
 * 通用评论方法
 * @param questionId
 * @param comment
 * @param type
 */
function universalComment(questionId, comment, type) {
    var appendHtml = "";
    $.ajax({
        type: "POST",
        contentType : "application/json",
        url: "/comment",
        data: JSON.stringify({
            "parentId" : questionId,
            "content" : comment,
            "type" : type
        }),
        async : false,
        success: function (response) {
            console.log(response);
            if (response.code !== 0) {
                if (response.code === 2002) {
                    var isAccepted = confirm(response.message);
                    if (isAccepted) {
                        window.open("https://github.com/login/oauth/authorize?client_id=ce46b85af14a2d21447b&redirect_uri=http://localhost:8080/callback&scope=user&state=2");
                        window.localStorage.setItem("closable", true);
                    }
                } else {
                    alert(response.message);
                }
            } else {
                var userAvatar = $("#userAvatar")[0].src;
                var userName = $("#userName").text();

                var template = $("#comment-template").children(".media");
                template.find(".small-avatar").attr("src", userAvatar);
                template.find(".media-heading").text(userName);
                template.find(".comment-text").text(comment);
                template.find(".pull-right").text(getFormatDate(response.data.gmtCreate));

                appendHtml = template.prop("outerHTML");
            }
        },
        dataType: "json"
    });
    return appendHtml;
}

/**
 * 提交评论
 **/
function comment() {
    var questionId = $("#questionId").val();
    var comment = $("#commentText").val();
    var type = 1;
    var appendHtml = universalComment(questionId, comment, type);

    if (appendHtml !== "") {
        // 显示刚刚提交的评论
        $("#comment-divider").after(appendHtml);

        // 评论成功清空文本域
        $("#commentText").val("");

        // 如果评论类型是一级评论，评论总数加1
        var commentCount = parseInt($("#comment-count").text());
        $("#comment-count").text(commentCount + 1);
    }
}

/**
 * 提交二级评论
 */
function subComment(e) {
    var commentId = e.getAttribute("data-id");
    var comment = $(e).prev().val();
    var type = 2;
    var appendHtml = universalComment(commentId, comment, type);
    if (appendHtml !== "") {
        $("#subComments-" + commentId).prepend(appendHtml);
    }
}
```

​	一级评论下的二级评论数应该在初始化加载页面时显示，但是目前评论表还没有评论数字段，所以先新增评论数的字段：

```sql
ALTER TABLE COMMENT ADD comment_count INT DEFAULT 0 COMMENT '评论数';
```

​	在 `Comment` 、`CommentDTO` 中新增对应的字段，在 `CommentMaper` 中新增支持更新回复数的方法：

```java
@Update("update comment set comment_count = comment_count + #{commentCount} where id = #{id}")
Integer updateCommentCount(@Param("id") Long parentId, @Param("commentCount") Integer commentCount);
```

​	在 `CommentService` 的新增评论方法的二级评论分支处理中，增加更新回复数

```java
@Transactional
public void addComment(Comment comment) {
	...
	if (comment.getType() == CommentTypeEnum.COMMENT.getType()) {
		// 回复评论
		...
		commentMapper.insert(comment);
		commentMapper.updateCommentCount(comment.getParentId(), 1);
	} else {
		// 回复问题
		...
	}
}
```

​	效果如下，提交二级评论前

<img src="screenshots\128-subComment.png"/>

​	提交评论后，评论列表出现刚才提交的评论，并且回复数+1

<img src="screenshots\129-subComment.png"/>

​	我们还想实现点赞的功能，先在 `CommentMapper` 中新增支持更新点赞数的方法：

```java
@Update("update comment set like_count = like_count + #{likeCount} where id = #{id}")
Integer updateLikeCount(@Param("id") Long id, @Param("likeCount") Integer likeCount);
```

​	在 `CommentService` 中新增对应的方法：

```java
public Integer likeCountIncr(Long commentId) {
	return commentMapper.updateLikeCount(commentId, 1);
}
```

​	在 `CommentController` 中新增支持前端请求的方法：

```java
@GetMapping("/commentLike/{id}")
@ResponseBody
public Object like(HttpServletRequest request,
				   @PathVariable(value = "id") Long id) {
	User user = (User) request.getSession().getAttribute("user");
	if (user == null) {
		return ResultDTO.errorOf(CustomizeErrorCode.NO_LOGIN);
	}

	Integer row = commentService.likeCountIncr(id);
	if (row != 1) {
		return ResultDTO.errorOf(CustomizeErrorCode.LIKE_FAILED);
	}

	return ResultDTO.okOf();
}
```

​	修改 `question.html` 中点赞的元素脚本：

```html
<span class="text-desc">
	<a class="question-tags cursor-link" th:data-id="${comment.getId()}" onclick="like(this)">
		<span class="glyphicon glyphicon-thumbs-up icon" aria-hidden="true"></span>
		<span class="icon-num" th:text="${comment.getLikeCount()}">0</span>赞
	</a>
</span>
```

​	新增 js 函数，响应点赞动作：

```java
/**
 * 点赞
 * @param e
 */
function like(e) {
    var id = e.getAttribute("data-id");
    var liked = e.getAttribute("liked");
    if (liked === "true") {
        alert("你已经点赞过了，不要重复点哦~");
    } else {
        $.ajax({
            type: "GET",
            contentType : "application/json",
            url: "/commentLike/" + id,
            data: {},
            dataType: "json",
            success: function (response) {
                if (response.code !== 0) {
                    if (response.code === 2002) {
                        var isAccepted = confirm(response.message);
                        if (isAccepted) {
                            window.open("https://github.com/login/oauth/authorize?client_id=ce46b85af14a2d21447b&redirect_uri=http://localhost:8080/callback&scope=user&state=2");
                            window.localStorage.setItem("closable", true);
                        }
                    } else {
                        alert(response.message);
                    }
                } else {
                    e.setAttribute("liked", true);
                    const likeCount = $(e).children(".icon-num");
                    likeCount.text(parseInt(likeCount.text()) + 1);
                }
            }
        });
    }
}
```

​	效果如下，当页面初始化加载时，点击点赞可以增加点赞数，再次点击提示你刚才已经点过了

<img src="screenshots\130-subComment.png"/>

<img src="screenshots\131-subComment.png"/>

<img src="screenshots\132-subComment.png" style="zoom:70%;"/>





# 24、相关问题

​	进一步完善问题详情页，显示问题所属标签，并在侧边栏的相关问题中显示具有相同标签的问题，首先问题标签我们是存储在问题表的标签字段，页面渲染时，需要将该字段值分割成多个词方便显示多个标签，代码如下：

```html
<div class="col-lg-12 col-md-12 col-sm-12 col-xs-12 no-padding">
	<span class="label label-info topic-tag" th:each="tag : ${question.tag.split(',')}">
		<span class="glyphicon glyphicon-tags"></span>
		<span class="community-tag" th:text="${tag}"></span>
	</span>
</div>
```

​	效果如下：

<img src="screenshots\133-label.png" style="zoom:60%;"/>

​	在侧边栏相关问题栏目，显示具有相同标签的文章链接，所以要在页面渲染前一并查出相关问题的数据，在 mapper 中新增代码：

```java
@Select("select id, title from question where id != #{id} and tag regexp #{tag}")
List<Question> selectRelated(Question question);
```

​	在 service 新增对应方法：

```java
public List<QuestionDTO> selectRelated(QuestionDTO queryDTO) {
	if (StringUtils.isBlank(queryDTO.getTag())) {
		return new ArrayList<>();
	}
	String[] tags = StringUtils.split(queryDTO.getTag(), ",");
	String regexpTag = Arrays.stream(tags).collect(Collectors.joining("|"));
	Question question = new Question();
	question.setId(queryDTO.getId());
	question.setTag(regexpTag);

	List<Question> questions = questionMapper.selectRelated(question);
	List<QuestionDTO> questionDTOS = questions.stream().map(q -> {
		QuestionDTO questionDTO = new QuestionDTO();
		BeanUtils.copyProperties(q, questionDTO);
		return questionDTO;
	}).collect(Collectors.toList());
	return questionDTOS;
}
```

​	这里就是把形如 `aa,bb,cc` 的标签变成 `aa|bb|cc` 方便正则表达式使用，最终会在数据库中执行语句：

```sql
select id, title from question where id != xxx and tag regexp 'aa|bb|cc';
# 效果等同于
select id, title from question where id != xxx and 
(tag like '%aa%' or tag like '%bb%' or tag like '%cc%');
```

​	在控制器中调用 service 方法并设置到 model 中，代码如下：

```java
@GetMapping("/question/{id}")
public String question(@PathVariable(name = "id") Long id,
					   Model model) {
	questionService.incView(id);
	QuestionDTO questionDTO = questionService.getById(id);

	// 获取问题评论
	List<CommentDTO> comments = commentService.listByQuestionId(id, CommentTypeEnum.QUESTION);
	List<QuestionDTO> relatedQuestions = questionService.selectRelated(questionDTO);

	model.addAttribute("question", questionDTO);
	model.addAttribute("comments", comments);
	model.addAttribute("relatedQuestions", relatedQuestions);

	return "question";
}
```

​	页面会对返回的数据列表进行遍历渲染，代码如下：

```html
<div class="col-lg-12 col-md-12 col-sm-12 col-xs-12 no-padding">
	<h5>相关问题</h5>
	<ul class="question-related">
		<li th:each="related : ${relatedQuestions}">
			<a th:href="@{'/question/'+ ${related.id}}" th:text="${related.title}"></a>
		</li>
	</ul>
</div>
```

​	最终页面加载效果如下：

<img src="screenshots\134-label.png" style="zoom:60%;"/>





# 25、标签库

​	论坛社区的文章通常都会在末尾加上标签，表示文章领域和类型，在之前标签的基础上，实现一个标签库，并且非法标签会被过滤返回报错。

<img src="screenshots\135-label.png" style="zoom:60%;"/>

​	首先要在后端代码中建立标签对象，每一类标签都有 id、名字、具体标签属性，代码如下：

```java
package life.majiang.community.dto;

import lombok.Data;

import java.util.List;

@Data
public class TagDTO {
    private String categoryId;
    private String categoryName;
    private List<String> tags;
}
```

​	其次要有一个标签库类，有获取标签库和检查标签是否合法的功能，代码如下：

```java
package life.majiang.community.cache;

import life.majiang.community.dto.TagDTO;
import org.apache.commons.lang3.StringUtils;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.stream.Collectors;

public class TagCache {
    private static final CopyOnWriteArrayList<TagDTO> tagDTOS = new CopyOnWriteArrayList<>();

    public static List<TagDTO> get() {
        if (tagDTOS.isEmpty()) {
            TagDTO program = new TagDTO();
            program.setCategoryName("开发语言");
            program.setCategoryId("program");
            program.setTags(Arrays.asList("javascript", "php", "css", "html", "html5", "java", "node.js", "python", "c++", "c", "golang", "objective-c", "typescript", "shell", "swift", "c#", "sass", "ruby", "bash", "less", "asp.net", "lua", "scala", "coffeescript", "actionscript", "rust", "erlang", "perl"));
            tagDTOS.add(program);

            TagDTO framework = new TagDTO();
            framework.setCategoryName("平台框架");
            framework.setCategoryId("framework");
            framework.setTags(Arrays.asList("laravel", "spring", "express", "django", "flask", "yii", "ruby-on-rails", "tornado", "koa", "struts"));
            tagDTOS.add(framework);

            TagDTO server = new TagDTO();
            server.setCategoryName("服务器");
            server.setCategoryId("server");
            server.setTags(Arrays.asList("linux", "nginx", "docker", "apache", "ubuntu", "centos", "缓存 tomcat", "负载均衡", "unix", "hadoop", "windows-server"));
            tagDTOS.add(server);

            TagDTO db = new TagDTO();
            db.setCategoryName("数据库");
            db.setCategoryId("db");
            db.setTags(Arrays.asList("mysql", "redis", "mongodb", "sql", "oracle", "nosql memcached", "sqlserver", "postgresql", "sqlite"));
            tagDTOS.add(db);

            TagDTO tool = new TagDTO();
            tool.setCategoryName("开发工具");
            tool.setCategoryId("tool");
            tool.setTags(Arrays.asList("git", "github", "visual-studio-code", "vim", "sublime-text", "xcode intellij-idea", "eclipse", "maven", "ide", "svn", "visual-studio", "atom emacs", "textmate", "hg"));
            tagDTOS.add(tool);
        }

        return tagDTOS;
    }

    // 过滤出非法标签
    public static String filterInvalid(String tags) {
        String[] splits = StringUtils.split(tags, ",");
        List<String> tagList = tagDTOS.stream().flatMap(tag -> tag.getTags().stream()).collect(Collectors.toList());
        String invalid = Arrays.stream(splits).filter(t -> !tagList.contains(t)).collect(Collectors.joining(","));
        return invalid;
    }
}
```

​	在 `PublishController` 的每个方法中都添加以下代码，以提供数据到页面渲染：

```java
model.addAttribute("tags", TagCache.get());
```

​	在负责处理问题发布的方法中，增加对标签合法性检查：

```java
String invalidTag = TagCache.filterInvalid(tag);
if (StringUtils.isNotBlank(invalidTag)) {
	model.addAttribute("error", "非法标签[" + invalidTag + "]");
	return "publish";
}
```

​	在 `Publish.html` 中新增显示标签库元素：

```html
<form action="/publish" method="post">
	...
	<div class="form-group">
		<label for="tag">添加标签：</label>
		<input type="text" class="form-control" id="tag" name="tag"
			   placeholder="输入标签，以逗号分隔"
			   autocomplete="off"
			   th:value="${tag}">
	</div>
	<div class="col-lg-12 col-md-12 col-sm-12 col-xs-12 publish-tag-panel" th:class="${error != null ? 'active' : ''}">
		<!-- Nav tabs -->
		<ul class="nav nav-tabs" role="tablist" style="margin-bottom: 5px">
			<li role="presentation" th:each="selectCategory,iterStat : ${tags}"
									th:class="${iterStat.first ? 'active' : ''}">
				<a th:href="${'#' + selectCategory.categoryId}" aria-controls="home" role="tab" data-toggle="tab" th:text="${selectCategory.categoryName}">开发语言</a>
			</li>
		</ul>

		<!-- Tab panes -->
		<div class="tab-content">
			<div role="tabpanel" th:id="${selectCategory.categoryId}"
								 th:each="selectCategory,iterStat : ${tags}"
								 th:class="${iterStat.first ? 'active tab-pane' : 'tab-pane'}">
				<span class="label label-info topic-tag"
					  th:each="selectTag : ${selectCategory.tags}"
					  th:data-tag="${selectTag}"
					  onclick="selectTag(this)">
					<span class="glyphicon glyphicon-tags"></span>
					<span class="community-tag" th:text="${selectTag}"></span>
				</span>
			</div>
		</div>
	</div>
	...
</form>	
```

​	页面对后端返回的标签库数据进行遍历，并且可以切换不同类型的标签 tab

<img src="screenshots\136-label.png" style="zoom:100%;"/>

​	每点击一个标签，就会填充到上面的输入框，效果如下：

<img src="screenshots\137-label.png" style="zoom:100%;"/>

​	如上送的标签中有非标签库中的，则提交会报错

<img src="screenshots\138-label.png" style="zoom:100%;"/>

​	相关控制的 js 代码如下：

```javascript
$(document).ready(function () {
    /**
     * 显示问题标签面板
     */
    const tag = $("#tag");
    tag.click(function () {
        $('.publish-tag-panel').show();
    });

    tag.focus(function () {
        $('.publish-tag-panel').show();
    });
});

// 选择标签
function selectTag(e) {
    var value = e.getAttribute("data-tag");
    var previous = $("#tag").val();
    if (previous.indexOf(value) === -1) {
        if (previous) {
            $("#tag").val(previous + "," + value);
        } else {
            $("#tag").val(value);
        }
    }
}
```





# 26、优化个人页

​	对于个人页，我的问题列表中的每个问题，都应该是可以直接编辑的，目前还需要点进详情再编辑，在显示列表时就添加一个快捷编辑入口，可以方便使用。

​	在问题列表中新增编辑：

```html
<span class="text-desc">
	<a class="question-tags" href="#" th:text="${question.tag}"></a> •
	<span th:text="${question.user.name}"></span> 发表了文章 •
	<span th:text="${question.commentCount}"></span> 个评论 •
	<span th:text="${question.viewCount}"></span> 次浏览 •
	<span th:text="${#dates.format(question.gmtCreate,'yyyy-MM-dd HH:mm')}"></span> •
	<span>
		<a th:if="${session.user != null && session.user.id == question.creator}"
		   th:href="@{'/publish/'+${question.id}}" class="text-edit">
			<span class="glyphicon glyphicon-pencil" aria-hidden="true"></span>
			<span>编辑</span>
		</a>
	</span>
</span>
```

​	效果如下：

<img src="screenshots\139-edit.png" style="zoom:100%;"/>





# 27、回复通知

​	很多网站特别是论坛博客，都有消息通知之类的功能，用户登录后会提示站内有多少对问题的评论、回复点赞等。

<img src="screenshots\141-notify.png" style="zoom:100%;"/>

​	要实现这功能，首先要创建一张存储回复通知数据的表：

```sql
create table notification
(
    id           bigint auto_increment primary key,
    notifier     bigint not null,
    receiver     bigint not null,
    outer_id      bigint not null,
    type         int    not null,
    statue       int    not null,
    gmt_create   bigint not null,
    gmt_modified bigint not null
);

comment on table notification is '通知表';
comment on column notification.id is '通知id';
comment on column notification.notifier is '通知者';
comment on column notification.receiver is '接收者';
comment on column notification.outer_id is '通知内容id';
comment on column notification.type is '通知类型';
comment on column notification.statue is '通知状态';
comment on column notification.gmt_create is '创建时间';
comment on column notification.gmt_modified is '更新时间';
```

​	将上述信息保存在 `V8__Create_notification_table.sql` 并通过 flyway 执行的时候发现，并没有执行新增的 DDL，排查猜测是 IDEA 本身存在缓存，在删除 `.idea` 目录下的 `dataSources` 目录再重新打开 IDEA 再次执行 flyway:migrate 发现新增的 DDL 被执行了。

<img src="screenshots\140-notify.png" style="zoom:100%;"/>

​	我们向实现的效果是 `xxx 回复了问题 yyy` ，xxx 是用户名，yyy 是问题标题，为了减少查询用户表和问题表的开销，干脆将用户名和问题标题存储在通知表中，所以在表中新增两个字段：

```sql
ALTER TABLE NOTIFICATION ADD NOTIFIER_NAME VARCHAR(100) NOT NULL;
ALTER TABLE NOTIFICATION ADD OUTER_TITLE VARCHAR(256) NOT NULL;
ALTER TABLE NOTIFICATION ALTER COLUMN STATUE RENAME TO STATUS;
```

​	完成表的创建之后，创建数据对象，首先创建与表对应的 `Notification` ：

```java
package life.majiang.community.model;

import lombok.Data;

@Data
public class Notification {
    private Long id;
    private Long notifier;
    private String notifierName;
    private Long receiver;
    private Long outerId;
    private String outerTitle;
    private Integer type;
    private Integer status;
    private Long gmtCreate;
    private Long gmtModified;
}
```

​	然后创建要返回到页面使用的数据对象 `NotificationDTO` ：

```java
package life.majiang.community.dto;

import lombok.Data;

@Data
public class NotificationDTO {
    private Long id;
    private Long notifier;
    private String notifierName;
    private Long outerId;
    private String outerTitle;
    private Integer type;
    private String typeName;
    private Integer status;
    private Long gmtCreate;
}
```

​	用户访问 `/profile/replies` 时，需要获取用户未读数据列表，参考问题列表做成分页的形式，新增对应的 mapper 接口 `NotificationMapper`，代码如下：

```java
package life.majiang.community.mapper;

import life.majiang.community.model.Notification;
import org.apache.ibatis.annotations.*;
import java.util.List;

@Mapper
public interface NotificationMapper {
    @Select("select * from notification where receiver = #{receiver} and status = 0 order by gmt_modified desc limit #{offset}, #{size}")
    public List<Notification> selectByReceiver(@Param("receiver") Long receiver, @Param("offset") Integer offset, @Param("size") Integer size);

    @Select("select count(1) from notification where receiver = #{receiver} and status = 0")
    Integer unreadCount(@Param("receiver") Long receiver);
}
```

​	通知分为对问题的评论和对一级评论的二级评论两种，创建 `NotificationTypeEnum` 枚举类，代码如下：

```java
package life.majiang.community.enums;

public enum NotificationTypeEnum {
    REPLY_QUESTION(1, "回复了问题"),
    REPLY_COMMENT(2, "回复了评论");

    private int type;
    private String name;

    NotificationTypeEnum(int type, String name) {
        this.type = type;
        this.name = name;
    }

    public int getType() {
        return type;
    }

    public String getName() {
        return name;
    }

    public static String nameOfType(int type) {
        for (NotificationTypeEnum notificationTypeEnum : NotificationTypeEnum.values()) {
            if (notificationTypeEnum.getType() == type) {
                return notificationTypeEnum.getName();
            }
        }
        return "";
    }
}
```

​	当用户点击了通知问题链接之后，通知会被置为已读，所以同样创建一个表示通知状态的 `NotificationStatusEnum` 枚举类，代码如下：

```java
package life.majiang.community.enums;

public enum NotificationStatusEnum {
    UNREAD(0),
    READ(1);

    private int status;

    NotificationStatusEnum(int status) {
        this.status = status;
    }

    public int getStatus() {
        return status;
    }
}
```

​	创建 `NotificationService` ，代码如下：

```java
package life.majiang.community.service;

import life.majiang.community.dto.NotificationDTO;
import life.majiang.community.dto.PaginationDTO;
import life.majiang.community.enums.NotificationStatusEnum;
import life.majiang.community.enums.NotificationTypeEnum;
import life.majiang.community.exception.CustomizeErrorCode;
import life.majiang.community.exception.CustomizeException;
import life.majiang.community.mapper.NotificationMapper;
import life.majiang.community.model.Notification;
import life.majiang.community.model.User;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

@Service
public class NotificationService {

    @Autowired
    private NotificationMapper notificationMapper;

    public PaginationDTO list(Long receiver, Integer page, Integer size) {
        Integer offset = (page - 1) * size;
        List<NotificationDTO> notificationDTOS = getNotificationDTOS(notificationMapper.selectByReceiver(receiver, offset, size));

        Integer totalCount = notificationMapper.unreadCount(receiver);
        return getPaginationDTO(totalCount, page, size, notificationDTOS);
    }

    private List<NotificationDTO> getNotificationDTOS(List<Notification> notifications) {
        List<NotificationDTO> notificationDTOS = new ArrayList<>();

        for (Notification notification : notifications) {
            NotificationDTO notificationDTO = new NotificationDTO();
            BeanUtils.copyProperties(notification, notificationDTO);
            notificationDTO.setTypeName(NotificationTypeEnum.nameOfType(notification.getType()));
            notificationDTOS.add(notificationDTO);
        }

        return notificationDTOS;
    }

    private PaginationDTO getPaginationDTO(Integer totalCount, Integer page, Integer size, List<NotificationDTO> notificationDTOS) {
        PaginationDTO paginationDTO = new PaginationDTO();
        paginationDTO.init(totalCount, page, size);
        paginationDTO.setData(notificationDTOS.stream()
                .map(o -> (Object) o)
                .collect(Collectors.toList()));

        return paginationDTO;
    }
}
```

​	修改 `ProfileController` ，在获取回复的处理分支，增加返回未读消息列表数据

```java
@Controller
public class ProfileController {

	...

    @GetMapping("/profile/{action}")
    public String profile(HttpServletRequest request,
                          Model model,
                          @PathVariable(name = "action") String action,
                          @RequestParam(name = "page", defaultValue = "1") Integer page,
                          @RequestParam(name = "size", defaultValue = "2") Integer size) {
	    ...

        model.addAttribute("section", action);
        if ("questions".equals(action)) {
		   ...
        } else if ("replies".equals(action)) {
            model.addAttribute("sectionName", "最新回复");

            PaginationDTO paginationDTO = notificationService.list(user.getId(), page, size);
            model.addAttribute("pagination", paginationDTO);
        }

        return "profile";
    }

}
```

​	前端页面的代码如下：

```java
<div class="media" th:each="notification : ${pagination.data}">
	<div class="media-body">
		<p class="media-heading">
			<a class="notify-text" th:text="${notification.notifierName}"></a>
			<span th:text="${notification.typeName}"></span>
			<a class="notify-text" th:text="${notification.outerTitle}" th:href="@{'/notification/' + ${notification.outerId}}"></a>
			<span class="notify-time" th:text="${#dates.format(notification.gmtCreate,'yyyy-MM-dd HH:mm')}"></span>
		</p>
	</div>
	<hr>
</div>
```

​	访问 `/profile/replies` ，效果如下：

<img src="screenshots\142-notify.png" style="zoom:100%;"/>

​	当用户新增问题评论或二级评论时，同样需要新增一条回复通知，所以需要修改 `CommentService` 代码：

```java
@Transactional
public void addComment(Comment comment, User commentator) {
	if (comment.getParentId() == null || comment.getParentId() == 0) {
		throw new CustomizeException(CustomizeErrorCode.TARGET_PARAM_NOT_FOUND);
	}
	if (comment.getType() == null || !CommentTypeEnum.isExist(comment.getType())) {
		throw new CustomizeException(CustomizeErrorCode.TARGET_PARAM_WRONG);
	}
	if (comment.getType() == CommentTypeEnum.COMMENT.getType()) {
		// 回复评论
		Comment dbComment = commentMapper.selectById(comment.getParentId());
		if (dbComment == null) {
			throw new CustomizeException(CustomizeErrorCode.COMMENT_NOT_FOUND);
		}

		// 回复问题
		Question question = questionMapper.getById(dbComment.getParentId());
		if (question == null) {
			throw new CustomizeException(CustomizeErrorCode.QUESTION_NOT_FOUND);
		}
		commentMapper.insert(comment);

		// 增加评论数
		commentMapper.updateCommentCount(comment.getParentId(), 1);

		// 增加通知
		createNotify(commentator, dbComment.getCommentator(), question, NotificationTypeEnum.REPLY_COMMENT);
	} else {
		// 回复问题
		Question question = questionMapper.getById(comment.getParentId());
		if (question == null) {
			throw new CustomizeException(CustomizeErrorCode.QUESTION_NOT_FOUND);
		}
		commentMapper.insert(comment);

		// 增加评论数
		question.setCommentCount(1);
		questionMapper.updateCommentCount(question);

		// 增加通知
		createNotify(commentator, question.getCreator(), question, NotificationTypeEnum.REPLY_COMMENT);
	}
}

private void createNotify(User commentator, Long receiver, Question question, NotificationTypeEnum notificationTypeEnum) {
	Notification notification = new Notification();
	notification.setNotifier(commentator.getId());
	notification.setNotifierName(commentator.getName());
	notification.setReceiver(receiver);
	notification.setOuterId(question.getId());
	notification.setOuterTitle(question.getTitle());
	notification.setType(notificationTypeEnum.getType());
	notification.setStatus(NotificationStatusEnum.UNREAD.getStatus());
	notification.setGmtCreate(System.currentTimeMillis());
	notification.setGmtModified(notification.getGmtCreate());
	notificationMapper.insert(notification);
}
```

* 回复问题时，notifier 是当前登录用户，receiver 是问题的作者，outerId 是问题 id，type 是 `NotificationTypeEnum.REPLY_QUESTION`

* 回复一级评论时，notifier 是当前登录用户，receiver 是一级评论的作者，outerId 是问题 id，type 是 `NotificationTypeEnum.REPLY_COMMENT`

  在 mapper 中新增插入数据的方法：

```java
@Insert("insert into notification (notifier, notifier_name, receiver, outer_id, outer_title, type, status, gmt_create, gmt_modified) values (#{notifier}, #{notifierName}, #{receiver}, #{outerId}, #{outerTitle}, #{type}, #{status}, #{gmtCreate}, #{gmtModified})")
Integer insert(Notification notification);
```

​	现在系统有三个用户，codedog、xhy、biko，首先 xhy 发表了一个提问

<img src="screenshots\146-notify.png" style="zoom:40%;"/>

​	然后 codedog 发表了评论，接着 biko 发起了二级评论

<img src="screenshots\143-notify.png" style="zoom:100%;"/>

​	然后 biko 又提交了对小胡鸭的欢迎

<img src="screenshots\147-notify.png" style="zoom:100%;"/>

​	当小胡鸭打开查看消息，是会在最新回复里收到两条消息，虽然 biko 嘲讽了 codedog 也是一条回复，但针对的是 codedog 的回复。

<img src="screenshots\148-notify.png" style="zoom:100%;"/>

​	codedog 打开查看可以看到一条消息

<img src="screenshots\149-notify.png" style="zoom:100%;"/>

​	点击回复消息链接时，会跳转到 `/notification/xx` ，新增对应的处理控制器 `NotificationController` ，代码如下：

```java
package life.majiang.community.controller;

import life.majiang.community.dto.NotificationDTO;
import life.majiang.community.enums.NotificationTypeEnum;
import life.majiang.community.model.User;
import life.majiang.community.service.NotificationService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

import javax.servlet.http.HttpServletRequest;

@Controller
public class NotificationController {

    @Autowired
    private NotificationService notificationService;

    @GetMapping("/notification/{id}")
    public String question(HttpServletRequest request,
                           @PathVariable(name = "id") Long id,
                           Model model) {
        User user = (User) request.getSession().getAttribute("user");
        if (user == null) {
            return "redirect:/";
        }

        NotificationDTO notificationDTO = notificationService.read(id, user);
        if (notificationDTO != null && (notificationDTO.getType() == NotificationTypeEnum.REPLY_COMMENT.getType() || notificationDTO.getType() == NotificationTypeEnum.REPLY_QUESTION.getType())) {
            Integer unreadCount = (Integer) request.getSession().getAttribute("unreadCount");
            if (unreadCount > 0) {
                unreadCount--;
            }
            request.getSession().setAttribute("unreadCount", unreadCount);                 
            return "redirect:/question/" + notificationDTO.getOuterId();
        } else {
            return "redirect:/";
        }
    }

}
```

​	如果用户未登录重定向到首页，如果上送 id 的回复不存在或者状态非法也重定向到首页，否则查到问题 id 跳转到 `/question/xx` ，在 `NotificationService` 中新增方法：

```java
public NotificationDTO read(Long id, User user) {
	Notification notification = notificationMapper.selectById(id);
	if (notification == null) {
		throw new CustomizeException(CustomizeErrorCode.NOTIFICATION_NOT_FOUND);
	}
	if (!Objects.equals(notification.getReceiver(), user.getId())) {
		throw new CustomizeException(CustomizeErrorCode.READ_NOTIFICATION_FAIL);
	}

	// 将通知状态置为已读
	notification.setStatus(NotificationStatusEnum.READ.getStatus());
	notificationMapper.updateStatus(notification);

	NotificationDTO notificationDTO = new NotificationDTO();
	BeanUtils.copyProperties(notification, notificationDTO);
	notificationDTO.setTypeName(NotificationTypeEnum.nameOfType(notification.getType()));
	return notificationDTO;
}
```

​	首先判断通知是否还存在，其次判断通接收者是否为当前用户，最后将通知状态置为已读，然后转化 DTO 对象返回。

​	小胡鸭打开 biko 的回复后，页头显示的消息数会变为1，这条回复被读取了。

<img src="screenshots\150-notify.png" style="zoom:100%;"/>

​	再次打开消息，列表中只看到 codedog 的回复了。

<img src="screenshots\151-notify.png" style="zoom:100%;"/>

​	再点击一次，小胡鸭的未读消息变为0

<img src="screenshots\152-notify.png" style="zoom:100%;"/>

​	页头显示的消息数量是通过 session 来实现的，这样避免每个页面都去查询未读消息数，在拦截器 `SessionInterceptor` 中，若用户刚登录，则查询用户未读通知数量，并放到会话中。

```java
package life.majiang.community.interceptor;

import life.majiang.community.mapper.UserMapper;
import life.majiang.community.model.User;
import life.majiang.community.service.NotificationService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

@Component
@Slf4j
public class SessionInterceptor implements HandlerInterceptor {
	...
      
    @Autowired
    private NotificationService notificationService;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
		...

        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if ("token".equals(cookie.getName())) {
                    String token = cookie.getValue();
                    User user = userMapper.getByToken(token);
                    if (user != null) {
                        request.getSession().setAttribute("user", user);
                        request.getSession().setAttribute("unreadCount", notificationService.unreadCount(user.getId()));
                    }
                    break;
                }
            }
        }

        return true;
    }

	...
}
```

​	当用户每次点击通知并通过校验成功将通知置为已读时，在 `NotificationController` 中将会话中的未读数减一。

```java
@GetMapping("/notification/{id}")
public String question(HttpServletRequest request,
					   @PathVariable(name = "id") Long id,
					   Model model) {
	User user = (User) request.getSession().getAttribute("user");
	if (user == null) {
		return "redirect:/";
	}

	NotificationDTO notificationDTO = notificationService.read(id, user);
	if (notificationDTO != null && (notificationDTO.getType() == NotificationTypeEnum.REPLY_COMMENT.getType() || notificationDTO.getType() == NotificationTypeEnum.REPLY_QUESTION.getType())) {
		Integer unreadCount = (Integer) request.getSession().getAttribute("unreadCount");
		if (unreadCount > 0) {
			unreadCount--;
		}
		request.getSession().setAttribute("unreadCount", unreadCount);
		return "redirect:/question/" + notificationDTO.getOuterId();
	} else {
		return "redirect:/";
	}
}
```







# 28、回复通知的优化

​	通知点击置为已读之后，用户再次刷新看不到历史通知，如果最新回复列表显示所有历史回复信息，并且标记哪些已读哪些未读，可以方便用户使用。

​	首先修改 `NotificationMapper` 分页查询方法去掉状态未读的筛选条件，并且新增一个获取历史回复数量的方法：

```java
@Select("select * from notification where receiver = #{receiver} order by gmt_modified desc limit #{offset}, #{size}")
public List<Notification> selectByReceiver(@Param("receiver") Long receiver, @Param("offset") Integer offset, @Param("size") Integer size);

@Select("select count(1) from notification where receiver = #{receiver}")
Integer count(@Param("receiver") Long receiver);
```

​	修改 `NotificationService` 返回分页查询 DTO 的方法：

```java
public PaginationDTO list(Long receiver, Integer page, Integer size) {
	Integer offset = (page - 1) * size;
	List<NotificationDTO> notificationDTOS = getNotificationDTOS(notificationMapper.selectByReceiver(receiver, offset, size));

	Integer totalCount = notificationMapper.count(receiver);
	return getPaginationDTO(totalCount, page, size, notificationDTOS);
}
```

​	最新回复显示的数量应该是未读回复数，所以 `ProfileController` 应该去获取用户未读回复数，代码如下：

```java
if ("questions".equals(action)) {
	model.addAttribute("sectionName", "我的问题");

	PaginationDTO paginationDTO = questionService.list(user.getId(), page, size);
	model.addAttribute("pagination", paginationDTO);
} else if ("replies".equals(action)) {
	model.addAttribute("sectionName", "最新回复");

	PaginationDTO paginationDTO = notificationService.list(user.getId(), page, size);
	model.addAttribute("unreadCount", notificationService.unreadCount(user.getId()));
	model.addAttribute("pagination", paginationDTO);
}
```

​	修改 `profile.html` ，加上未读标识和未读数。

```html
...
<div class="media" th:each="notification : ${pagination.data}">
	<div class="media-body">
		<p class="media-heading">
			<a class="notify-text" th:text="${notification.notifierName}"></a>
			<span th:text="${notification.typeName}"></span>
			<a class="notify-text" th:text="${notification.outerTitle}"
								   th:href="@{'/notification/' + ${notification.id}}"></a>
			<span class="label label-danger" th:if="${notification.status == 0}">未读</span>
			<span class="notify-time" th:text="${#dates.format(notification.gmtCreate,'yyyy-MM-dd HH:mm')}"></span>
		</p>
	</div>
	<hr>
</div>
...
<div class="col-lg-3 col-md-12 col-sm-12 col-xs-12 profile">
	<div class="list-group section">
		<a href="/profile/questions" th:class="${section == 'questions'} ? 'list-group-item active' : 'list-group-item'">
			我的问题<span class="badge" th:if="${section == 'questions'}" th:text="${pagination.totalCount}"></span>
		</a>
		<a href="/profile/replies" th:class="${section == 'replies'} ? 'list-group-item active' : 'list-group-item'">
			最新回复<span class="badge" th:if="${section == 'replies'}" th:text="${unreadCount}"></span>
		</a>
	</div>
</div>
...
```

​	效果如下：

<img src="screenshots\153-notify.png" style="zoom:100%;"/>

 	点击未读回复

<img src="screenshots\154-notify.png" style="zoom:100%;"/>

​	未读标识消失

<img src="screenshots\155-notify.png" style="zoom:100%;"/>





# 29、富文本编辑

​	Google 搜索 `markdown editor github` 找到一个简单Markdown编辑器。

<img src="screenshots\156-editor.png" style="zoom:100%;"/>

​	访问[官网](https://pandao.github.io/editor.md/en.html)，下载安装包并拷贝静态文件到工程目录中

<img src="screenshots\157-editor.png" style="zoom:60%;"/>

​	按照文档说明，修改 `publish.html` ，首先引入 css、js

```html
<link rel="stylesheet" type="text/css" href="/editormd/css/editormd.css" />
<script type="application/javascript" src="/editormd/editormd.min.js"></script>
```

​	修改文章内容编辑区元素，设置文本域外围的 div id：

```html
<div class="form-group" id="question-editor">
	<textarea class="form-control" id="description" name="description" rows="10" cols="30" th:text="${description}" style="display:none;"></textarea>
</div>
```

​	新增初始化富文本编辑器脚本：

```javascript
<script type="text/javascript">
	$(function() {
		var editor = editormd("question-editor", {
			width  : "100%",
			height : 300,
			path   : "/editormd/lib/",
			placeholder : "请输入问题描述",
			delay : 0,
			watch : false
		});
	});
</script>
```

​	访问编辑发布页，效果如下：

<img src="screenshots\158-editor.png" style="zoom:60%;"/>

​	在问题详情页，引入 css、js：

```javascript
<link rel="stylesheet" type="text/css" href="/editormd/css/editormd.preview.css" />
<script type="application/javascript" src="/editormd/editormd.min.js"></script>
<script type="application/javascript" src="/editormd/lib/marked.min.js"></script>
<script type="application/javascript" src="/editormd/lib/prettify.min.js"></script>
```

​	在显示文章内容的 div 中新增文本域元素和对应转换 Markdown 为 HTML 的脚本：

```html
<div class="col-lg-12 col-md-12 col-sm-12 col-xs-12 question-content no-padding" id="question-view">
	<textarea style="display: none" th:text="${question.description}"></textarea>
</div>
<script type="text/javascript">
	$(function() {
		editormd.markdownToHTML("question-view", {});
	});
</script>
```

​	访问文章详情，效果如下：

<img src="screenshots\159-editor.png" style="zoom:60%;"/>





# 30、图片上传























































# 【附录】

## 1、Spring 功能集成

访问：https://spring.io/guides

在简明教程列表中选择要集成的功能：

<img src="screenshots\8-SpringGuides.png" style="zoom:100%;"/>






## 2、文档

* [Spring文档](https://spring.io/guides)

  * [Spring Boot](https://docs.spring.io/spring-boot/docs/current/reference/html/index.html)

    * [Spring Boot DataSource](https://docs.spring.io/spring-boot/docs/current/reference/html/data.html)
    * [Spring Boot Mybatis](https://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/zh/index.html)
    * [Spring Boot Devtools](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools)
    * [Error Handler](https://springdoc.cn/spring-boot/web.html#web.servlet.spring-mvc) 



  * [Spring Web](https://docs.spring.io/spring-framework/docs/5.3.28/reference/html/web.html#spring-web)

    * [Interception](https://docs.spring.io/spring-framework/docs/5.3.28/reference/html/web.html#mvc-handlermapping-interceptor)

* [Spring Transaction](https://docs.spring.io/spring-framework/docs/5.3.28/reference/html/data-access.html#transaction)

* [Thymeleaf 官方文档](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html)

  * [Thymeleaf模板](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#including-template-fragments)

* [Bootstrap](https://v3.bootcss.com/)

* [Github OAuth](https://docs.github.com/zh/apps/oauth-apps/building-oauth-apps)

* [H2](https://www.h2database.com/html/main.html)

  重置表自增列序号

  ```sql
  ALTER TABLE COMMENT ALTER COLUMN ID RESTART WITH 1;
  ```

* [Flyway](https://documentation.red-gate.com/fd)

* [lombok](https://projectlombok.org/features/)

* [MyBatis](https://mybatis.org/mybatis-3/zh/index.html)
  * [MyBatis Generator](https://mybatis.org/generator/quickstart.html)

* [pandao/editor.md github](https://github.com/pandao/editor.md)

  * [Meditor.md官网](https://pandao.github.io/editor.md/en.html)





## 3、工具

[Git](https://git-scm.com/download)   
[Visual Paradigm](https://www.visual-paradigm.com)    
[Flyway](https://flywaydb.org/getstarted/firststeps/maven)  
[Lombok](https://www.projectlombok.org)    
[ctotree](https://www.octotree.io/)   
[Table of content sidebar](https://chrome.google.com/webstore/detail/table-of-contents-sidebar/ohohkfheangmbedkgechjkmbepeikkej)    
[One Tab](https://chrome.google.com/webstore/detail/chphlpgkkbolifaimnlloiipkdnihall)    
[Live Reload](https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei/related)  
[Postman](https://chrome.google.com/webstore/detail/coohjcphdfgbiolnekdpbcijmhambjff)




















```json
{
    "login":"huyihao",
    "id":11757351,
    "node_id":"MDQ6VXNlcjExNzU3MzUx",
    "avatar_url":"https://avatars.githubusercontent.com/u/11757351?v=4",
    "gravatar_id":"",
    "url":"https://api.github.com/users/huyihao",
    "html_url":"https://github.com/huyihao",
    "followers_url":"https://api.github.com/users/huyihao/followers",
    "following_url":"https://api.github.com/users/huyihao/following{/other_user}",
    "gists_url":"https://api.github.com/users/huyihao/gists{/gist_id}",
    "starred_url":"https://api.github.com/users/huyihao/starred{/owner}{/repo}",
    "subscriptions_url":"https://api.github.com/users/huyihao/subscriptions",
    "organizations_url":"https://api.github.com/users/huyihao/orgs",
    "repos_url":"https://api.github.com/users/huyihao/repos",
    "events_url":"https://api.github.com/users/huyihao/events{/privacy}",
    "received_events_url":"https://api.github.com/users/huyihao/received_events",
    "type":"User",
    "site_admin":false,
    "name":"codedog",
    "company":null,
    "blog":"",
    "location":null,
    "email":"1123176978@qq.com",
    "hireable":null,
    "bio":"a simple codedog",
    "twitter_username":null,
    "public_repos":18,
    "public_gists":0,
    "followers":0,
    "following":2,
    "created_at":"2015-04-01T16:18:30Z",
    "updated_at":"2023-05-09T13:14:10Z",
    "private_gists":0,
    "total_private_repos":5,
    "owned_private_repos":5,
    "disk_usage":2023496,
    "collaborators":0,
    "two_factor_authentication":false,
    "plan":{
        "name":"free",
        "space":976562499,
        "collaborators":0,
        "private_repos":10000
    }
}
```


