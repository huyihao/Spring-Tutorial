# 1、创建 SpringBoot 项目

## （1）快捷创建项目

​	这里我使用的是IDEA 付费版本【IntelliJ IDEA 2023.1.2 (Ultimate Edition)】，学习该花的钱不要省（嘿嘿，当然某宝也有物美价廉的方案），已经安装好了齐全的 Spring 插件（File -> Settings -> Plugins），这里创建项目用到了 Spring Initializr。

<img src="screenshots\1-IDEA-SpringPlugins.png" style="zoom:80%;"/>

​	File -> New -> New Project，选择 Spring Initializr 来初始化项目，注意一些关键信息要填好。

<img src="screenshots\2-Init-SpringBoot.png" style="zoom:80%;"/>

​	进入下一步，选择 Spring Boot 版本，添加项目用到的 SpringBoot Starter，先选 web，后面用到其他的可以手动添加。

<img src="screenshots\3-Add-SpringBootStarter.png" style="zoom:80%;"/>





## （2）工程目录文件简介

<img src="screenshots\4-ProjectDetails.png" style="zoom:80%;"/>

* **pom.xml**

  ​	Maven 项目依赖管理文件，默认生成的 pom.xml 会以 spring-boot-starter-parent 为父工程，将使用的版本修改为 2.1.4.RELEASE（跟教学视频保持一致），这样下面引用各种 SpringBoot Starter 时就不需要显式指定依赖版本，因为父工程已经指定好了版本，如下所示：

<img src="screenshots\5-SpringBootPom.png" style="zoom:80%;"/>

​	可以看到创建工程时勾选的 web starter，除此之外，还自动引入了 test starter，用于编写对 Spring Boot 的测试代码；在构建插件中，还自动引入了 spring-boot-maven-plugin，用于对工程进行构建打包。

* **.gitignore**

  ​	定义工程中忽略的文件和目录，这些文件和目录在提交代码入库时不会会被忽略，比如 IDE 自动生成的文件和目录，生成编译代码的文件和目录等。

* **HELP.md**

  ​	在 github 上进入一个项目时会有一个简介，github 会自动加载仓库根目录的 README.md 文档并渲染到网页上，这里先把 HELP.md 重命名为 README.md，然后在文档中添加对项目的介绍，包括功能、安装和使用步骤等。

* **src/main/java**

  ​	存放 java 代码的目录，这里已经按照初始化时指定的配置生成了一个代码包 `life.majiang.community`，并且自动创建了工程主类 `CommunityApplication.java`，启动它即可将工程跑起来。

  ​	一般情况下，我们会在 `life.majiang.community` 下创建新的包，比如 `life.majiang.community.controller`、`life.majiang.community.service` 等，因为工程启动时默认会扫描主类包及其子包中所有使用了 Spring 注解定义的 Bean（常用的注解有 `@Controller`、`@Component`、`@Service`等），当然也可以不这样做，比如定义一个新的包 `life.majiang.controller` ，这样要对包扫描时，需要在主类中显式指定要扫描的包。

* **src/main/resources**

  ​	存放工程的资源文件，默认有 static、templates 两个子目录，还有一个 application.properties 文件。

  ​	static 用来存放网站需要的静态文件，比如图片、css样式文件、javascript脚本文件等，一般会在 static 下再建不同的子目录区分，比如 static/images、static/css、static/js。

  ​	templates 用来存放网站需要的模板文件，当然流行的前后端分离一般已经不再使用模板，这里我们使用的引擎是 thymeleaf，后面还要引入相关的依赖。

  ​	application.properties 文件用来配置 Spring Boot 支持的各种参数，比如 web 服务对外暴露端口的参数为 `server.port`，默认值为 8080，如果要修改为 8081，在配置文件中编写如下一行键值对配置即可：

```properties
server.port=8081
```

* **src/main/test**

  ​	存放工程的测试代码，在严格执行单元测试的开发管理中，一个类要有一个对应的 Test 测试类，测试类所处包跟类相同。





## （3）运行工程

​	启动主类，可以看到日志中显示 SpringBoot 工程中嵌入了 Tomcat 服务器，默认启动的端口是 8080。

<img src="screenshots\6-SpringBootStart.png" style="zoom:100%;"/>

​	访问下 http://localhost:8080，可以看到显示的是默认的报错白页，因为此时我们还没编写任何的处理响应的控制器，Spring 找不到处理响应的程序，就只能返回一个 404 的报错。

<img src="screenshots\7-SpringBootStart.png" style="zoom:100%;"/>





# 2、集成 thymeleaf 

​	在 https://spring.io/guides 中找到快捷接入指引：https://spring.io/guides/gs/serving-web-content/

​	首先要引入 thymeleaf 模板引擎对应的 starter，在工程 pom.xml 中添加：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```

​	在启动类所在包下创建一个子包 `life.majiang.community.controller`，并创建一个 HelloController，负责响应 Web 请求，代码如下：

```java
package life.majiang.community.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
public class HelloController {

    @GetMapping("/hello")
    public String hello(@RequestParam(name = "name") String name, Model model) {
        model.addAttribute("name", name);
        return "hello";
    }

}
```

​	首先控制器要使用 `@Controller` 注解，在控制器中创建一个 `hello` 方法，使用 `@GetMapping("/hello")` 表示该方法会响应对 "/hello" 的 GET 请求。

​	请求可能通过 URL 传递参数进来，比如 "/hello?name=hyh"，为了获取参数，在方法头添加 `@RequestParam(name = "name") String name`，表示会从 URL 中获取参数名为 name 的参数并传递给方法入参。

​	我们可能还需要将后端处理好的数据传递给前端，所以给方法添加一个 Model 参数，往 model 对象中添加属性，这些属性能随着响应传递到前端页面模板。

​	最后返回一个 `"hello"` 字符串，因为我们使用了 thymeleaf 模板引擎，所以会自动从资源模板目录 `src/main/resources/templete` 中找到 hello.html，IDEA 会自动提示找不到这个 MVC 视图

<img src="screenshots\9-mvc-view.png" style="zoom:100%;"/>

​	所以接下来到模板目录中创建 hello.html，代码如下：

```html
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Getting Started: Serving Web Content</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>
<body>
    <p th:text="'Hello, ' + ${name} + '!'" />
</body>
</html>
```

​	首先要引入模板引擎的 namespace，告诉 Spring 页面中的 `th` 要使用 Thymeleaf 引擎解析处理，`th:text="'Hello, ' + ${name} + '!'"` 表示要拼接一个字符串渲染到 `<p> ` 标签中，拼接的字符串中 `${name}` 来自后端控制器方法中通过 model 传递给模板处理的属性。

​	访问 `http://localhost:8080/hello?name=hyh` ，响应还是白页

<img src="screenshots\11-没开启自动导入导致的报错.png" style="zoom:100%;"/>

​	看看服务端有什么报错

<img src="screenshots\12-视图解析异常.png" style="zoom:100%;"/>

 	可以看到解析 `hello` 的视图失败，看一下是不是新增的依赖没有自动导入的问题

<img src="screenshots\13-未自动导入maven包.png" style="zoom:80%;"/>

​	可以看到没有我们新引入的 thymeleaf 的依赖，点击左上角的 "Reload All Maven Projects"，才看到依赖真正导入了

<img src="screenshots\14-thmeleaf.png" style="zoom:70%;"/>

​	重启应用再访问，可以看到正常的响应了。

<img src="screenshots\10-hello.png" style="zoom:100%;"/>

​	为了避免在引入新依赖时再次遇到该问题，需要设置 maven 的 auto import，步骤如下

<img src="screenshots\15-maven-autoimport.png" style="zoom:60%;"/>

<img src="screenshots\16-maven-autoimport.png" style="zoom:60%;"/>





# 3、引入 Bootstrap

【Bootstrap】https://v3.bootcss.com/

【样式】https://v3.bootcss.com/css/

【组件】https://v3.bootcss.com/components/

​	下载压缩包

<img src="screenshots\17-bootstrap.png" style="zoom:60%;"/>

​	将压缩包内的 css、fonts、js 目录拷贝到工程的静态资源目录下

<img src="screenshots\18-bootstrap.png" style="zoom:60%;"/>

​	因为这里引用的 Bootstrap V3 是依赖 JQuery 的，所以在 js 目录下还要有 jquery.js，并且在 html 中引入 js 的顺序要先于 bootstrap.js

<img src="screenshots\19-bootstrap.png" style="zoom:100%;"/>





# 4、创建导航栏

​	我们使用 Bootstrap 自带的组件实现一个网站导航栏，从组件库中将默认的导航条样式引入，再在其基础上修改，调整为想要的功能和菜单。

<img src="screenshots\20-bootstrap.png" style="zoom:100%;"/>

​	调整后的新增 index.html 如下：

```html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>鸭鸭社区</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>
    <nav class="navbar navbar-default">
        <div class="container-fluid">

            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                    <span class="sr-only">鸭鸭社区</span>
                </button>
                <a class="navbar-brand" href="/">鸭鸭社区</a>
            </div>

            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <form class="navbar-form navbar-left">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="搜索问题">
                    </div>
                    <button type="submit" class="btn btn-default">搜索</button>
                </form>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="#">登录</a></li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">我 <span class="caret"></span></a>
                        <ul class="dropdown-menu">
                            <li><a href="#">消息中心</a></li>
                            <li><a href="#">个鸭资料</a></li>
                            <li><a href="#">退出登录</a></li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </nav>
</body>
</html>
```

​	新增控制器 IndexController，增加对 `/` 请求的处理，并最后渲染视图 index。

```java
package life.majiang.community.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class IndexController {
    @GetMapping("/")
    public String index() {
        return "index";
    }
}
```

​	完成开发后启动应用，网页访问 `http://localhost:8080/` ，效果如下所示：

<img src="screenshots\21-bootstrap.png" style="zoom:100%;"/>





# 5、Github OAuth 登录开发

​	先找文档在哪里，一般有提供 API 的网站，都能在网站上找到对应的入口

<img src="screenshots\22-github.png" style="zoom:100%;"/>

​	进入可以看到开发者选项，REST API

<img src="screenshots\23-github.png" style="zoom:100%;"/>

<img src="screenshots\24-github.png" style="zoom:60%;"/>

## （1）创建 OAuth 应用

​	登录上 Github，在页面的右上方，单击个人资料照片，然后点击 "Settings"

<img src="screenshots\26-github.png" style="zoom:60%;"/>

​	在左边栏中，点击 Developer settings

<img src="screenshots\27-github.png" style="zoom:100%;"/>

​	点击右侧边栏的 OAuth Apps

<img src="screenshots\28-github.png" style="zoom:60%;"/>

​	点击 "New OAuth App"，填写应用信息：

1、在“Application name（应用程序名称）”中，输入应用程序的名称；

2、在“Homepage URL（主页 URL）”中，输入应用程序网站的完整 URL；

3、（可选）在“Application description（应用程序说明）”中，输入用户将看到的应用程序说明；

4、在“Authorization callback URL（授权回调 URL）”中，输入应用程序的回调 URL。

​	然后点击 "Register application"

<img src="screenshots\29-github.png" style="zoom:100%;"/>

​	创建应用的时候，会自动生成一个客户端ID，这个是不变的，还需要自行点击生成一个客户端密钥，这个是可以重新生成的

<img src="screenshots\30-github.png" style="zoom:100%;"/>

​	点击 "Update application"，至此完成应用创建

<img src="screenshots\31-github.png" style="zoom:65%;"/>







## （3）实战

​	首先要获得授权码，在首页登录按钮配置调整获得授权码的 URL，如下所示：

```html
...
<ul class="nav navbar-nav navbar-right">
   <li><a href="https://github.com/login/oauth/authorize?client_id=ce46b85af14a2d21447b&redirect_uri=http://localhost:8080/callback&scope=user&state=2">登录</a></li>
    
...
```

​	启动应用，访问首页点击登录，看下效果：

<img src="screenshots\32-gitoauth.png" style="zoom:65%;"/>

​	会从当前页面自动跳转到 github 的授权登录页，点击授权，会回调到设定的回调地址，并且回调的同时，返回授权码 code 和跨域用到的 state 字段。

<img src="screenshots\33-gitoauth.png" style="zoom:65%;"/>

​	但是由于暂时没开发响应授权回调的控制器程序，所以会报白页错误。

​	接下来要编写响应回调的程序，首先要编写专门负责向 Github OAuth 接口发起请求的程序，为方便发送和接收数据，先定义两个 DTO 类。

```java
package life.majiang.community.provider.dto;

import lombok.Data;

@Data
public class AccessTokenDTO {
    private String client_id;
    private String client_secret;
    private String code;
    private String redirect_uri;
    private String state;
}

package life.majiang.community.provider.dto;

import lombok.Data;

@Data
public class GithubUser {
    private Long id;
    private String name;
    private String bio;
    private String avatar_url;
}
```

​	`AccessTokenDTO` 类在请求 OAuth 接口获得 accessToken 时用到；`GithubUser` 类对应获取授权 Github 用户数据时用到。

​	发起 HTTP 请求用的是 OK HTTP，同时用到了 fastjson 来处理对象和 JSON 字符串的转换，lombok 方便类编写，先引入依赖：

```xml
<dependency>
	<groupId>com.squareup.okhttp3</groupId>
	<artifactId>okhttp</artifactId>
	<version>3.14.1</version>
</dependency>
<dependency>
	<groupId>com.alibaba</groupId>
	<artifactId>fastjson</artifactId>
	<version>1.2.57</version>
</dependency>
<dependency>
	<groupId>org.projectlombok</groupId>
	<artifactId>lombok</artifactId>
	<scope>provided</scope>
</dependency>
```

​	负责请求的组件类 GithubProvider 定义如下：

```java
package life.majiang.community.provider;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.PropertyNamingStrategy;
import com.alibaba.fastjson.parser.ParserConfig;
import life.majiang.community.provider.dto.AccessTokenDTO;
import life.majiang.community.provider.dto.GithubUser;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;
import org.springframework.stereotype.Component;
import java.io.IOException;

@Component
@Slf4j
public class GithubProvider {

    // 获取accessToken
    public String getAccessToken(AccessTokenDTO accessTokenDTO) {
        MediaType mediumType = MediaType.get("application/json; charset=utf-8");

        OkHttpClient client = new OkHttpClient();
        RequestBody body = RequestBody.create(mediumType, JSON.toJSONString(accessTokenDTO));
        Request request = new Request.Builder()
                .url("https://github.com/login/oauth/access_token")
                .post(body)
                .build();
        try (Response response = client.newCall(request).execute()) {
            String string = response.body().string();
            log.info("Get access token response: " + string);
            String token = string.split("&")[0].split("=")[1];
            return token;
        } catch (IOException e) {
            log.error("Get access token exception: {}", e);
        }
        return null;
    }

    // 获取用户信息
    public GithubUser getGithubUser(String accessToken) {
        OkHttpClient client = new OkHttpClient();
        Request request = new Request.Builder()
                                     .url("https://api.github.com/user")
                                     .addHeader("Authorization", "Bearer " + accessToken)
                                     .build();
        try (Response response = client.newCall(request).execute()) {
            String string = response.body().string();
            log.info("Get github user response: " + string);
            ParserConfig.getGlobalInstance().propertyNamingStrategy = PropertyNamingStrategy.SnakeCase;
            GithubUser githubUser = JSON.parseObject(string, GithubUser.class);
            return githubUser;
        } catch (IOException e) {
            log.error("Get github user exception: {}", e);
        }
        return null;
    }

}
```

​	创建授权控制器 `AuthorizeController` ，接收 Github 的回调后，先获得 accessToken，再用 accessToken 去获取用户信息。

​	在控制器中，要用到 OAuth App 的客户端ID和密钥，已经回调地址，将其放在配置文件 application.properties 中避免硬编码。

```properties
...
# Github OAuth
github.client.id=xxxxxxxxxxxxxx
github.client.secret=xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
github.redirect.uri=http://localhost:8080/callback
...
```

```java
package life.majiang.community.controller;

import life.majiang.community.provider.GithubProvider;
import life.majiang.community.provider.dto.AccessTokenDTO;
import life.majiang.community.provider.dto.GithubUser;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
@Slf4j
public class AuthorizeController {

    @Value("${github.client.id}")
    private String clientId;

    @Value("${github.client.secret}")
    private String clientSecret;

    @Value("${github.redirect.uri}")
    private String redirectUrl;

    @Autowired
    private GithubProvider githubProvider;

    @GetMapping("/callback")
    public String callback(@RequestParam(name = "code") String code,
                           @RequestParam(name = "state") String state) {
        AccessTokenDTO accessTokenDTO = new AccessTokenDTO();
        accessTokenDTO.setClientId(clientId);
        accessTokenDTO.setClientSecret(clientSecret);
        accessTokenDTO.setCode(code);
        accessTokenDTO.setState(state);
        accessTokenDTO.setRedirectUri(redirectUrl);
        log.info("AccessTokenDTO = " + accessTokenDTO);

        String accessToken = githubProvider.getAccessToken(accessTokenDTO);
        GithubUser githubUser = null;
        if (accessToken != null) {
            githubUser = githubProvider.getGithubUser(accessToken);
        }

        if (githubUser != null && githubUser.getId() != null) {
            log.info("Github OAuth succ");
            return "redirect:/";
        } else {
            // 登录失败，重新登录
            return "redirect:/";
        }
    }

}
```

​	启动应用，在首页上点击登录页面，可以看到打印出来的日志，登录成功了，获取到了用户信息。

<img src="screenshots\34-gitoauth.png" style="zoom:100%;"/>

 



# 6、登录会话

​	先说说 cookie 和 session，cookie 是浏览器端会保存的一小块数据缓存，每次用户从浏览器发起新的请求时，会将 cookie 中的数据全部一并发送到服务端，在服务端，通过 `HttpServletRequest` 对象获取请求头部可以拿到 cookie 信息。

​	session 是会话的意思，用户每次登录后，在网站内浏览任意一个页面都应该能够保持登录状态。所以用户每次登录后，要生成一个用户的会话信息ID，并且在登录成功后响应时将其设置到浏览器的 cookie 中，这样后续每次用户访问，服务端都能根据ID拿到用户的会话信息，进而可以判断是哪个用户及其相关登录信息。

​	所以在 Github OAuth 登录成功后，应该设置用户 session，修改授权控制器代码：

```java
    @GetMapping("/callback")
    public String callback(@RequestParam(name = "code") String code,
                           @RequestParam(name = "state") String state,
                           HttpServletRequest request) {
...
        if (githubUser != null && githubUser.getId() != null) {
            log.info("Github OAuth succ");
            // 设置用户登录会话
            request.getSession().setAttribute("user", githubUser);
            return "redirect:/";
        } else {
            // 登录失败，重新登录
            return "redirect:/";
        }
...
    }
```

​	同时页面模板要配合修改，当用户已经登录时，就不应该显示【登录】按钮，同时要显示拿到的 Github 用户名。

```html
<li th:if="${session.user == null}"><a href="https://github.com/login/oauth/authorize?client_id=ce46b85af14a2d21447b&redirect_uri=http://localhost:8080/callback&scope=user&state=2">登录</a></li>
<li th:if="${session.user != null}" class="dropdown">
	<a th:text="${session.user.name}" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">我 <span class="caret"></span></a>
	<ul class="dropdown-menu">
		<li><a href="#">消息中心</a></li>
		<li><a href="#">个鸭资料</a></li>
		<li><a href="#">退出登录</a></li>
	</ul>
</li>
```

​	重启应用，测试效果。

<img src="screenshots\35-gitoauth.png" style="zoom:100%;"/>

​	后面每次刷新页面，都会显示用户名，屏蔽登录按钮。





# 7、集成 H2 

​	H2 是一个用 Java 开发的嵌入式数据库管理系统，在本地开发中，可以使用 H2 作为数据库，方便本地开发测试。

在 IDEA 上使用 Database 组件，创建 H2 数据源

<img src="screenshots\36-h2.png" style="zoom:60%;"/>

<img src="screenshots\37-h2.png" style="zoom:60%;"/>

测试连接是否可用

<img src="screenshots\38-h2.png" style="zoom:60%;"/>

<img src="screenshots\39-h2.png" style="zoom:60%;"/>

创建数据表

<img src="screenshots\40-h2.png" style="zoom:70%;"/>

```sql
create table c_user
(
    id           long auto_increment primary key,
    account_id   varchar(100),
    name         varchar(50),
    token        char(36),
    gmt_create   bigint,
    gmt_modified bigint
);

comment on table c_user is '用户信息表';
comment on column c_user.id is '用户id';
comment on column c_user.account_id is 'github账号ID';
comment on column c_user.name is '用户名';
comment on column c_user.token is '登录token';
comment on column c_user.gmt_create is '创建时间';
comment on column c_user.gmt_modified is '修改时间';
```

<img src="screenshots\43-h2.png" style="zoom:70%;"/>

​	使用 H2 数据库，需要先引入依赖：

```xml
<!-- H2 DB(必须和IDEA Database插件中创建的H2数据库驱动版本一致，否则会报错) -->
<dependency>
	<groupId>com.h2database</groupId>
	<artifactId>h2</artifactId>
	<version>2.1.210</version>
	<scope>runtime</scope>
</dependency>
```

​	使用 H2 作为数据源，需要在 application.properties 中配置数据源：

```properties
# DataSource
spring.datasource.url=jdbc:h2:~/community
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=org.h2.Driver
```





# 8、集成 Mybatis 记录登录用户

​	首先引入依赖：

```xml
<dependency>
	<groupId>org.mybatis.spring.boot</groupId>
	<artifactId>mybatis-spring-boot-starter</artifactId>
	<version>2.0.1</version>
</dependency>
```

​	定义用户对象

```java
package life.majiang.community.model;

import lombok.Data;

@Data
public class User {

    private long id;
    private String accountId;
    private String name;
    private String token;
    private long gmtCreate;
    private long gmtModified;

}
```

​	定义 Mapper 接口

```java
package life.majiang.community.mapper;

import life.majiang.community.model.User;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface UserMapper {

    @Insert("insert into c_user (account_id, name, token, gmt_create, gmt_modified) values (#{accountId}, #{name}, #{token}, #{gmtCreate}, #{gmtModified})")
    public void insert(User user);

}
```

​	修改授权控制器 `AuthorizeController` ，新增获取 Github 用户数据成功后插入到数据库中

```java
@Controller
@Slf4j
public class AuthorizeController {
	...
    @Autowired
    private UserMapper userMapper;	
	...
	
	@GetMapping("/callback")
    public String callback(@RequestParam(name = "code") String code,
                           @RequestParam(name = "state") String state,
                           HttpServletRequest request) {
        if (githubUser != null && githubUser.getId() != null) {
            log.info("Github OAuth succ");
            User user = new User();
            user.setAccountId(String.valueOf(githubUser.getId()));
            user.setName(githubUser.getName());
            user.setToken(UUID.randomUUID().toString());
            user.setGmtCreate(System.currentTimeMillis());
            user.setGmtModified(user.getGmtCreate());
            userMapper.insert(user);

            // 设置用户登录会话
            request.getSession().setAttribute("user", user);
            response.addCookie(new Cookie("token", user.getToken()));          
          
            return "redirect:/";
        } else {
            // 登录失败，重新登录
            log.info("Github OAuth fail");
            return "redirect:/";
        }                           
	}
}
```

​	启动应用进入首页登录，发现点击登录后回显用户名信息了，并且在数据库中插入了一条新的记录

<img src="screenshots\44-h2.png" style="zoom:70%;"/>

​	但是如果关闭应用程序，再重启，由于 session 数据是保存在服务端内存中的数据，所以应用重启后，之前的 session 数据就被清空了，所以重启再打开首页默认还是未登录状态。

​	**优化思路是**，在每次访问首页时，后端尝试从 cookie 中拿到上次登录的 token，再用 token 去查询数据库的用户数据，查到再放到 session 中，这样渲染页面时，就能保持上次的登录状态。

​	首先要在 `UserMapper` 里添加根据 token 查询用户信息的方法：

```java
@Mapper
public interface UserMapper {

	...

    @Select("select * from c_user where token = #{token}")
    public User getByToken(@Param("token") String token);
}
```

​	在访问首页的控制器`IndexController`，修改代码如下：

```java
package life.majiang.community.controller;

import life.majiang.community.mapper.UserMapper;
import life.majiang.community.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;

@Controller
public class IndexController {

    @Autowired
    private UserMapper userMapper;

    @GetMapping("/")
    public String index(HttpServletRequest request) {
        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if ("token".equals(cookie.getName())) {
                    String token = cookie.getValue();
                    User user = userMapper.getByToken(token);
                    if (user != null) {
                        request.getSession().setAttribute("user", user);
                    }
                    break;
                }
            }
        }

        return "index";
    }

}
```

​	一般 cookie 需要设有效期，防止非用户本人访问自动保持登录会话，修改授权控制器 `AuthorizeController` ，代码如下：

```java
@Controller
@Slf4j
public class AuthorizeController {

  	...

    @GetMapping("/callback")
    public String callback(@RequestParam(name = "code") String code,
                           @RequestParam(name = "state") String state,
                           HttpServletRequest request,
                           HttpServletResponse response) {
	    ...

        if (githubUser != null && githubUser.getId() != null) {
            log.info("Github OAuth succ");

		   ...

            // 设置用户登录会话
            //request.getSession().setAttribute("user", user);
            Cookie cookie = new Cookie("token", user.getToken());
            cookie.setPath("/");
            cookie.setMaxAge(3600);
            response.addCookie(cookie);

            return "redirect:/";
        } else {
            // 登录失败，重新登录
            log.info("Github OAuth fail");
            return "redirect:/";
        }
    }

}
```

​	启动应用，点击登录测试

<img src="screenshots\45-h2.png" style="zoom:70%;"/>

​	可以看到浏览器 cookie 中有了 token 的数据，并且设置了有效期。

​	停止应用程序，查看数据库，有了一条新的数据，并且 token 跟浏览器中看到的一致

<img src="screenshots\46-h2.png" style="zoom:100%;"/>

​	重新启动应用，测试是否自动保持登录状态，结果正常登录，再次访问数据库并未发现新增的记录，说明根据 cookie 中的 token 查询数据库并且设置用户会话的处理生效了。

​	与此同时，发现一个新的问题，设置的 token cookie 的有效时间时区不对，跟当前差了 8 个小时，在 application.properties 中设置：

```properties
spring.jackson.time-zone=Asia/Shanghai
```





# 9、集成 Flyway Migration

## （1）简介

​	flyway 是一款让数据库迁移变得简单的工具，下面简单介绍其工作原理，最简单的情况是用 Flyway 将数据库结构迁移到一个空数据库。

<img src="screenshots\47-flyway.png" style="zoom:100%;"/>



​	flyway 自带一个 schema 历史迁移表。若找不到该表，则会先创建该表。

​	执行了之后，数据库中会出现一张空表  *flyway_schema_history*  

<img src="screenshots\48-flyway.png" style="zoom:100%;"/>

​	该表用于跟踪数据库的状态

​	紧接着 Flyway 会开始扫描文件系统或应用的类路径来找到迁移文件，这些文件可能是 Sql 也可能是 Java 文件。

​	迁移的执行顺序会按照文件的版本号进行：

<img src="screenshots\49-flyway.png" style="zoom:100%;"/>

​	应用每次迁移时，架构历史表都会相应更新：

<img src="screenshots\50-flyway.png" style="zoom:100%;"/>

​	元数据和初始状态就位后，我们现在可以讨论迁移到新版本。

​	Flyway 会再次扫描文件系统或应用的类路径，根据架构历史表检查迁移，如果它们的版本号低于或等于标记为当前的版本号，则它们将被忽略。

​	剩余的迁移是待处理的迁移：可用，但未应用。

<img src="screenshots\51-flyway.png" style="zoom:100%;"/>

​	然后它们按版本号排序并按顺序执行：

<img src="screenshots\52-flyway.png" style="zoom:100%;"/>

​	架构历史表会相应更新：

<img src="screenshots\53-flyway.png" style="zoom:100%;"/>

​	每次需要改进数据库时，无论是结构（DDL）还是参考数据（DML），只需创建一个版本号高于当前版本号的新迁移即可。Flyway下次启动时，它会找到它并相应地升级数据库。



## （2）Maven 插件

​	首先在 Maven 工程的 pom.xml 中添加配置：

```xml
<project xmlns="...">
    <build>
        <plugins>
            <plugin>
                <groupId>org.flywaydb</groupId>
                <artifactId>flyway-maven-plugin</artifactId>
                <version>9.17.0</version>
                <configuration>
                    <url>jdbc:h2:~/community</url>
                    <user>root</user>
                    <password>root</password>
                </configuration>
                <dependencies>
                    <!-- 插件的版本要跟Jar包引入保持一致 -->
                    <dependency>
                        <groupId>com.h2database</groupId>
                        <artifactId>h2</artifactId>
                        <version>2.1.210</version>
                    </dependency>
                </dependencies>
            </plugin>
        </plugins>
    </build>
</project>
```

​	迁移文件的目录是 `src/main/resources/db/migration` ，在该目录下创建迁移文件 `V1__Create_user_table.sql` :

```sql
create table c_user
(
    id           long auto_increment primary key,
    account_id   varchar(100),
    name         varchar(50),
    token        char(36),
    gmt_create   bigint,
    gmt_modified bigint
);

comment on table c_user is '用户信息表';
comment on column c_user.id is '用户id';
comment on column c_user.account_id is 'github账号ID';
comment on column c_user.name is '用户名';
comment on column c_user.token is '登录token';
comment on column c_user.gmt_create is '创建时间';
comment on column c_user.gmt_modified is '修改时间';
```

​	在工程目录下执行 `mvn flyway:migrate` 

<img src="screenshots\54-flyway.png" style="zoom:100%;"/>

​	原来的用户表被删了再重建，数据被清空，同时还多了一张迁移表

<img src="screenshots\55-flyway.png" style="zoom:100%;"/>

​	迁移表记录了执行迁移的记录，包括文件、版本等信息

<img src="screenshots\56-flyway.png" style="zoom:100%;"/>

​	新增一个 V2 版本的迁移 SQL 文件，脚本如下：

```sql
ALTER TABLE C_USER ADD bio VARCHAR(256) NULL;
```

​	再次执行 `mvn flyway:migrate` 

<img src="screenshots\57-flyway.png" style="zoom:100%;"/>

​	查看迁移表，又多了一条记录

<img src="screenshots\58-flyway.png" style="zoom:100%;"/>

​	查看变结构，多了一个字段

<img src="screenshots\59-flyway.png" style="zoom:60%;"/>

​	



# 10、添加文章发布功能

## （1）前端

​	新增页面 publish.html

```html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>鸭鸭社区</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/community.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>
    <nav class="navbar navbar-default">
        <div class="container-fluid">

            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                    <span class="sr-only">鸭鸭社区</span>
                </button>
                <a class="navbar-brand" href="/">鸭鸭社区</a>
            </div>

            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <form class="navbar-form navbar-left">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="搜索问题">
                    </div>
                    <button type="submit" class="btn btn-default">搜索</button>
                </form>
                <ul class="nav navbar-nav navbar-right">
                    <li th:if="${session.user != null}"><a href="/publish">发布</a></li>
                    <li th:if="${session.user == null}"><a href="https://github.com/login/oauth/authorize?client_id=ce46b85af14a2d21447b&redirect_uri=http://localhost:8080/callback&scope=user&state=2">登录</a></li>
                    <li th:if="${session.user != null}" class="dropdown">
                        <a th:text="${session.user.name}" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">我 <span class="caret"></span></a>
                        <ul class="dropdown-menu">
                            <li><a href="#">消息中心</a></li>
                            <li><a href="#">个鸭资料</a></li>
                            <li><a href="#">退出登录</a></li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container-fluid main">
        <div class="row">
            <div class="col-lg-9 col-md-12 col-sm-12 col-xs-12">
                <h2><span class="glyphicon glyphicon-plus" aria-hidden="true"></span>发起</h2>
                <hr>

                <form action="/publish" method="post">
                    <input type="text" style="display:none" id="id" name="id" th:value="${id}"/>
                    <div class="form-group">
                        <label for="title">问题标题（简单扼要）：</label>
                        <input type="text" class="form-control" id="title" name="title" placeholder="问题标题……" th:value="${title}">
                    </div>
                    <div class="form-group">
                        <label for="description">问题补充（必填，请参照右侧提示）:</label>
                        <textarea class="form-control" id="description" name="description" rows="10" cols="30" th:text="${description}"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="tag">添加标签：</label>
                        <input type="text" class="form-control" id="tag" name="tag" placeholder="输入标签，以逗号分隔" th:value="${tag}">
                    </div>

                    <div class="container-fluid" style="padding-right: 0">
                        <div class="row">
                            <div class="col-lg-9 col-md-12 col-sm-12 col-xs-12">
                                <div class="alert alert-danger" role="alert" th:text="${error}" th:if="${error != null}"></div>
                            </div>
                            <div class="col-lg-3 col-md-12 col-sm-12 col-xs-12">
                                <button type="submit" class="btn btn-success btn-publish">提问</button>
                            </div>
                        </div>
                    </div>
                </form>
            </div>
            <div class="col-lg-3 col-md-12 col-sm-12 col-xs-12">
                <h3>热门话题</h3>
            </div>
        </div>
    </div>

</body>
</html>
```

​	编写一个响应请求展现页面的控制器 `PublishController` ，代码如下：

```java
package life.majiang.community.controller;

import life.majiang.community.mapper.QuestionMapper;
import life.majiang.community.model.Question;
import life.majiang.community.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletRequest;

@Controller
public class PublishController {

    @GetMapping("/publish")
    public String publish(HttpServletRequest request) {
        return "publish";
    }
}
```

​	启动应用，访问 `http://localhost:8080/publish` ，页面展现如下

<img src="screenshots\60-publish.png" style="zoom:100%;"/>

​	用户还没登录，就可以发布问题，显然是不合理的，所以在访问页面时，控制器里应先判断当前用户会话是否为空，会话中保存的用户信息是否为空，是则跳转到首页，用户在首页登录后再访问本页才能展现页面，代码修改如下：

```java
    @GetMapping("/publish")
    public String publish(HttpServletRequest request) {
        if (request.getSession() != null && request.getSession().getAttribute("user") == null) {
            return "redirect:/";
        }
        return "publish";
    }
```

​	重启应用再次访问 `http://localhost:8080/publish` ，会发现会重定向到 `http://localhost:8080/` ，达到想要的效果。

<img src="screenshots\61-publish.png" style="zoom:100%;"/>



## （2）后端

​	首先要有一张表存储用户发布的问题，除了发布页面的标题、内容和标签外，还要有评论数、阅读数、点赞数、作者，方便在接下来的文章详情展示页中展示，除此之外，每条数据还要有创建时间、修改时间，综上所述，建表语句如下：

```sql
create table question
(
    id            INT auto_increment primary key,
    title         VARCHAR(50) COMMENT '问题标题',
    description   TEXT COMMENT '问题描述',
    gmt_create    BIGINT COMMENT '创建时间',
    gmt_modified  BIGINT COMMENT '修改时间',
    creator       INT comment '创建者',
    comment_count INT DEFAULT 0 COMMENT '评论数',
    view_count    INT DEFAULT 0 COMMENT '阅读数',
    like_count    INT DEFAULT 0 COMMENT '点赞数',
    tag           VARCHAR(256) COMMENT '标签'
);
```

​	将其放在 resource/db/migration 目录下的 `V3__Create_question_table.sql` 中，然后执行 `mvn flyway:migrate` 命令执行迁移。

​	接着建立表对应的 POJO 类 `Question` ，代码如下：

```java
package life.majiang.community.model;

import lombok.Data;

@Data
public class Question {

    private Long id;
    private String title;
    private String description;
    private Long gmtCreate;
    private Long gmtModified;
    private Long creator;
    private Integer commentCount;
    private Integer viewCount;
    private Integer likeCount;
    private String tag;

}
```

​	定义对应的 Mapper，新增插入数据的方法：

```java
package life.majiang.community.mapper;

import life.majiang.community.model.Question;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface QuestionMapper {

    @Insert("insert into question (title, description, gmt_create, gmt_modified, creator, tag) values (#{title}, #{description}, #{gmtCreate}, #{gmtModified}, #{creator}, #{tag})")
    void insert(Question question);

}
```

​	在 `PublishController` 中定义处理 POST 请求的方法

```java
@Controller
public class PublishController {
  
	// other code	
  
    @PostMapping("/publish")
    public String doPublish(@RequestParam(value = "title") String title,
                            @RequestParam(value = "description") String description,
                            @RequestParam(value = "tag") String tag,
                            HttpServletRequest request,
                            Model model) {
        // 方便页面回显，这样页面已经填了的信息不用再重填一次
        model.addAttribute("title", title);
        model.addAttribute("description", description);
        model.addAttribute("tag", tag);
        //model.addAttribute("id", id);

        if (StringUtils.isEmpty(title)) {
            model.addAttribute("error", "标题不能为空");
            return "publish";
        }
        if (StringUtils.isEmpty(description)) {
            model.addAttribute("error", "问题补充不能为空");
            return "publish";
        }
        if (StringUtils.isEmpty(tag)) {
            model.addAttribute("error", "标签不能为空");
            return "publish";
        }

        // 如果cookie中不存在token，或根据token查无用户，则返回报错
        if (request.getSession() == null || request.getSession().getAttribute("user") == null) {
            model.addAttribute("error", "用户未登录");
            return "publish";
        }

        User user = (User) request.getSession().getAttribute("user");
        // 记录提交问题带数据库
        Question question = new Question();
        question.setTitle(title);
        question.setDescription(description);
        question.setGmtCreate(System.currentTimeMillis());
        question.setGmtModified(question.getGmtCreate());
        question.setCreator(user.getId());
        question.setTag(tag);
        questionMapper.insert(question);

        return "redirect:/";
    }
}
```

​	启动应用，访问首页登录后点击发布，填写问题相关信息

<img src="screenshots\62-publish.png" style="zoom:100%;"/>

​	点击提交成功后自动跳转到首页，查看数据库，成功插入了一条数据

<img src="screenshots\63-publish.png" style="zoom:100%;"/>

​	当提交问题为空时，会返回报错回显到页面上提示

<img src="screenshots\64-publish.png" style="zoom:100%;"/>





# 11、添加文章列表功能

## （1）添加字段

​	一些论坛社区的通常会有一个帖子或文章列表，如下图所示：

<img src="screenshots\65-list.png" style="zoom:100%;"/>

​	会展示用户头像，所以需要在用户表和对应的 POJO 以及数据库处理中增加对应的字段，新增迁移文件 `V4__Add_avatarUrl_col_to_user_table.sql`：

```sql
ALTER TABLE C_USER ADD avatar_url VARCHAR(100) NULL;

comment on column c_user.avatar_url is '用户头像';
```

​	执行迁移命令，在 `User` 类中添加相应字段

```java
@Data
public class User {

    private long id;
    private String accountId;
    private String name;
    private String token;
    private long gmtCreate;
    private long gmtModified;
    private String bio;
    private String avatarUrl;

}
```

​	在 `AuthorizeController` 中修改 OAuth 登录成功之后的处理代码：

```java
            User user = new User();
            user.setAccountId(String.valueOf(githubUser.getId()));
            user.setName(githubUser.getName());
            user.setToken(UUID.randomUUID().toString());
            user.setGmtCreate(System.currentTimeMillis());
            user.setGmtModified(user.getGmtCreate());
            user.setBio(githubUser.getBio());                 // 新增代码
            user.setAvatarUrl(githubUser.getAvatarUrl());     // 新增代码
            userMapper.insert(user);
```

​	修改 `UserMapper` 

```java
@Mapper
public interface UserMapper {

    @Insert("insert into c_user (account_id, name, token, gmt_create, gmt_modified, bio, avatar_url) values (#{accountId}, #{name}, #{token}, #{gmtCreate}, #{gmtModified}, #{bio}, #{avatarUrl})")
    public void insert(User user);
    
    // other code
}    
```

​	启动程序再次登录，登录成功后查看数据库，记录下了简介和头像两个用户信息

<img src="screenshots\66-list.png" style="zoom:100%;"/>



## （2）前端

​	修改前端页面 `index.html`

```html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>鸭鸭社区</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/community.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>
    <nav class="navbar navbar-default">
        <div class="container-fluid">

            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                    <span class="sr-only">鸭鸭社区</span>
                </button>
                <a class="navbar-brand" href="/">鸭鸭社区</a>
            </div>

            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <form class="navbar-form navbar-left">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="搜索问题">
                    </div>
                    <button type="submit" class="btn btn-default">搜索</button>
                </form>
                <ul class="nav navbar-nav navbar-right">
                    <li th:if="${session.user != null}"><a href="/publish">发布</a></li>
                    <li th:if="${session.user == null}"><a href="https://github.com/login/oauth/authorize?client_id=ce46b85af14a2d21447b&redirect_uri=http://localhost:8080/callback&scope=user&state=2">登录</a></li>
                    <li th:if="${session.user != null}" class="dropdown">
                        <a th:text="${session.user.name}" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">我 <span class="caret"></span></a>
                        <ul class="dropdown-menu">
                            <li><a href="#">消息中心</a></li>
                            <li><a href="#">个鸭资料</a></li>
                            <li><a href="#">退出登录</a></li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container-fluid main">
        <div class="row">
            <div class="col-lg-9 col-md-12 col-sm-12 col-xs-12 question-list">
                <h2><span class="glyphicon glyphicon-plus" aria-hidden="true"></span>发起</h2>
                <hr>
                <div class="media">
                    <div class="media-left">
                        <a href="#">
                            <img class="media-object img-rounded" src="https://avatars.githubusercontent.com/u/11757351?v=4">
                        </a>
                    </div>
                    <div class="media-body">
                        <h4 class="media-heading">Media heading</h4>
                        ...
                        <span class="text-desc">0 个评论 • 409 次浏览 • 2 天前</span>
                    </div>
                </div>
            </div>
            <div class="col-lg-3 col-md-12 col-sm-12 col-xs-12">
                <h3>热门话题</h3>
            </div>
        </div>
    </div>

</body>
</html>
```

​	启动应用访问 `http://localhost:8080`，效果如下：

<img src="screenshots\67-list.png" style="zoom:100%;"/>

​	只要后端提供一个查询问题数据列表的接口，并将数据渲染到该页面上，就可得到一个文章列表。



## （3）后端

​	首先要有一个查询问题列表的数据服务，同时每条数据还要带上用户信息（用于显示提问用户头像），可以选择在 `Question` 类中添加一个 `User` 的成员属性，但是这样不符合类设计的单一职责原则，为了将问题和用户的信息关联组合在一个类中，需要定义一个新的 `QuestionDTO` 类，代码如下：

```java
package life.majiang.community.dto;

import life.majiang.community.model.User;
import lombok.Data;

@Data
public class QuestionDTO {

    private Long id;
    private String title;
    private String description;
    private Long gmtCreate;
    private Long gmtModified;
    private Long creator;
    private Integer commentCount;
    private Integer viewCount;
    private Integer likeCount;
    private String tag;
    private User user;

}
```

​	定义一个问题服务类 `QuestionService` ，代码如下：

```java
package life.majiang.community.service;

import life.majiang.community.dto.QuestionDTO;
import life.majiang.community.mapper.QuestionMapper;
import life.majiang.community.mapper.UserMapper;
import life.majiang.community.model.Question;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;

@Service
public class QuestionService {

    @Autowired
    private QuestionMapper questionMapper;

    @Autowired
    private UserMapper userMapper;

    public List<QuestionDTO> list() {
        List<QuestionDTO> list = new ArrayList<>();

        List<Question> questions = questionMapper.list();
        for (Question question : questions) {
            QuestionDTO questionDTO = new QuestionDTO();
            BeanUtils.copyProperties(question, questionDTO);
            questionDTO.setUser(userMapper.getById(question.getCreator()));
            list.add(questionDTO);
        }

        return list;
    }

}
```

​	该服务中注入了 mapper，并通过 mapper 的数据操作来获取数据，首先 `QuestionMapper` 要有查询所有问题列表的方法，新增代码如下：

```java
@Mapper
public interface QuestionMapper {

    // other code

    @Select("select * from question")
    List<Question> list();
}
```

​	查到问题后，要对每个问题逐个查询提交人是谁，所以 `UserMapper` 也要根据用户id查询用户的方法，新增代码如下：

```java
@Mapper
public interface UserMapper {

	// other code

    @Select("select * from c_user where id = #{id}")
    public User getById(@Param("id") long id);
}
```

​	完成了服务的编写，在访问首页时使用，并将其放到 model 中才能在页面上渲染

```java
@Controller
public class IndexController {

    @Autowired
    private UserMapper userMapper;

    @Autowired
    private QuestionService questionService;

    @GetMapping("/")
    public String index(HttpServletRequest request,
                        Model model) {
		// other code

        List<QuestionDTO> questionDTOS = questionService.list();
        model.addAttribute("questions", questionDTOS);

        return "index";
    }

}
```

​	返回的数据是一个列表，借助 thymeleaf 模板引擎的 `th:each` 进行遍历和渲染，index.html的局部代码修改如下：

```html
<div class="container-fluid main">
    <div class="row">
        <div class="col-lg-9 col-md-12 col-sm-12 col-xs-12 question-list">
            <h2><span class="glyphicon glyphicon-plus" aria-hidden="true"></span>发起</h2>
            <hr>
            <div class="media" th:each="question : ${questions}">
                <div class="media-left">
                    <a href="#">
                        <img class="media-object img-rounded" th:src="${question.user.avatarUrl}"/>
                    </a>
                </div>
                <div class="media-body">
                    <h4 class="media-heading" th:text="${question.title}"></h4>
                    <span th:text="${question.description}"></span><br>
                    <span class="text-desc">
                        <span th:text="${question.commentCount}"></span> 个评论 •
                        <span th:text="${question.viewCount}"></span> 次浏览 •
                        <span th:text="${#dates.format(question.gmtCreate,'yyyy-MM-dd HH:mm')}"></span>
                    </span>
                </div>
            </div>
        </div>
        <div class="col-lg-3 col-md-12 col-sm-12 col-xs-12">
            <h3>热门话题</h3>
        </div>
    </div>
</div>
```

​	启动应用，访问 `http://localhost:8080` ，效果如下：

<img src="screenshots\68-list.png" style="zoom:100%;"/>

​	好像并不是我们要的效果，问题内容应该在详情页才展现，参考下 elasticsearch 中文社区

<img src="screenshots\69-list.png" style="zoom:100%;"/>

​	显示的是文章标签和作者，修改代码如下：

```html
<div class="container-fluid main">
    <div class="row">
        <div class="col-lg-9 col-md-12 col-sm-12 col-xs-12 question-list">
            <h2><span class="glyphicon glyphicon-plus" aria-hidden="true"></span>发起</h2>
            <hr>
            <div class="media" th:each="question : ${questions}">
                <div class="media-left">
                    <a href="#">
                        <img class="media-object img-rounded" th:src="${question.user.avatarUrl}"/>
                    </a>
                </div>
                <div class="media-body">
                    <h4 class="media-heading" th:text="${question.title}"></h4>
                    <span class="text-desc">
                        <a class="question-tags" href="#" th:text="${question.tag}"></a> •
                        <span th:text="${question.user.name}"></span> 发表了文章 •
                        <span th:text="${question.commentCount}"></span> 个评论 •
                        <span th:text="${question.viewCount}"></span> 次浏览 •
                        <span th:text="${#dates.format(question.gmtCreate,'yyyy-MM-dd HH:mm')}"></span>
                    </span>
                </div>
            </div>
        </div>
        <div class="col-lg-3 col-md-12 col-sm-12 col-xs-12">
            <h3>热门话题</h3>
        </div>
    </div>
</div>
```

​	再次启动应用访问首页，达到了想要的效果

<img src="screenshots\70-list.png" style="zoom:100%;"/>

​	<img src="screenshots\71-list.png" style="zoom:100%;"/>



```sql
-- auto-generated definition
create table QUESTION
(
    ID            INTEGER auto_increment
        primary key,
    TITLE         CHARACTER VARYING(50),
    DESCRIPTION   CHARACTER LARGE OBJECT,
    GMT_CREATE    BIGINT,
    GMT_MODIFIED  BIGINT,
    CREATOR       INTEGER,
    COMMENT_COUNT INTEGER default 0,
    VIEW_COUNT    INTEGER default 0,
    LIKE_COUNT    INTEGER default 0,
    TAG           CHARACTER VARYING(256)
);

comment on column QUESTION.TITLE is '问题标题';
comment on column QUESTION.GMT_CREATE is '创建时间';
comment on column QUESTION.GMT_MODIFIED is '修改时间';
comment on column QUESTION.CREATOR is '创建者';
comment on column QUESTION.COMMENT_COUNT is '评论数';
comment on column QUESTION.VIEW_COUNT is '阅读数';
comment on column QUESTION.LIKE_COUNT is '点赞数';
comment on column QUESTION.TAG is '标签';
```









# 【附录】

## 1、Spring 功能集成

访问：https://spring.io/guides

在简明教程列表中选择要集成的功能：

<img src="screenshots\8-SpringGuides.png" style="zoom:100%;"/>

* [Spring Boot DataSource](https://docs.spring.io/spring-boot/docs/current/reference/html/data.html)
* [Spring Boot Mybatis](https://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/zh/index.html)





## 2、文档

* [Spring文档](https://spring.io/guides)
* [Spring Web](https://docs.spring.io/spring-framework/docs/5.3.28/reference/html/web.html#spring-web)
* [Thymeleaf 官方文档](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html)
* [Bootstrap](https://v3.bootcss.com/)
* [Github OAuth](https://docs.github.com/zh/apps/oauth-apps/building-oauth-apps)
* [H2](https://www.h2database.com/html/main.html)
* [Flyway](https://documentation.red-gate.com/fd)
* [lombok](https://projectlombok.org/features/)





## 3、工具






















```json
{
    "login":"huyihao",
    "id":11757351,
    "node_id":"MDQ6VXNlcjExNzU3MzUx",
    "avatar_url":"https://avatars.githubusercontent.com/u/11757351?v=4",
    "gravatar_id":"",
    "url":"https://api.github.com/users/huyihao",
    "html_url":"https://github.com/huyihao",
    "followers_url":"https://api.github.com/users/huyihao/followers",
    "following_url":"https://api.github.com/users/huyihao/following{/other_user}",
    "gists_url":"https://api.github.com/users/huyihao/gists{/gist_id}",
    "starred_url":"https://api.github.com/users/huyihao/starred{/owner}{/repo}",
    "subscriptions_url":"https://api.github.com/users/huyihao/subscriptions",
    "organizations_url":"https://api.github.com/users/huyihao/orgs",
    "repos_url":"https://api.github.com/users/huyihao/repos",
    "events_url":"https://api.github.com/users/huyihao/events{/privacy}",
    "received_events_url":"https://api.github.com/users/huyihao/received_events",
    "type":"User",
    "site_admin":false,
    "name":"codedog",
    "company":null,
    "blog":"",
    "location":null,
    "email":"1123176978@qq.com",
    "hireable":null,
    "bio":"a simple codedog",
    "twitter_username":null,
    "public_repos":18,
    "public_gists":0,
    "followers":0,
    "following":2,
    "created_at":"2015-04-01T16:18:30Z",
    "updated_at":"2023-05-09T13:14:10Z",
    "private_gists":0,
    "total_private_repos":5,
    "owned_private_repos":5,
    "disk_usage":2023496,
    "collaborators":0,
    "two_factor_authentication":false,
    "plan":{
        "name":"free",
        "space":976562499,
        "collaborators":0,
        "private_repos":10000
    }
}
```







# 使用MyBatis Generator

1、引入插件

```xml
<project>
  ...
  <build>
    ...
    <plugins>
      ...
      <plugin>
		<groupId>org.mybatis.generator</groupId>
		<artifactId>mybatis-generator-maven-plugin</artifactId>
		<version>1.3.7</version>
      </plugin>
    </plugins>
  </build>
</project>
```



2、执行maven命令（生成执行 MyBatis 需要的 model 和 mapper 文件）

```shell
# -Dmybatis.generator.overwrite=true 表示生成的文件是否覆盖原文件，不覆盖则生成文件为 MyClass.java.1
mvn mybatis-generator:generate -Dmybatis.generator.overwrite=true
```



3、创建配置文件

【默认路径】src/main/resources/generatorConfig.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
<generatorConfiguration>
    <context id="simple" targetRuntime="MyBatis3">
        <!-- 配置数据库连接，MBG才知道去连接哪个数据库获取表信息 -->
        <jdbcConnection driverClass="org.h2.Driver"
                        connectionURL="jdbc:h2:~/community"
                        userId="root"
                        password="root"/>

        <!-- 配置生成的Java Model类要放在哪个目录哪个包中 -->
        <javaModelGenerator targetPackage="life.majiang.community.model" targetProject="src/main/java"/>

        <!-- 配置生成的mapper.xml存放位置 -->
        <sqlMapGenerator targetPackage="mapper" targetProject="src/main/resources"/>

        <!-- ava 客户端生成器构建 Java 接口和类，以便轻松使用生成的 Java 模型和 XML 映射文件。 -->
        <javaClientGenerator type="XMLMAPPER" targetPackage="life.majiang.community.mapper" targetProject="src/main/java"/>

        <!-- 配置要扫描哪些表生成文件 -->
        <table tableName="cuser" domainObjectName="User"/>
    </context>
</generatorConfiguration>
```





# 1、Spring Error Handler

​	默认情况下，Spring Boot 提供了一个 `/error` 映射，以合理的方式处理所有错误，并且它在 servlet 容器中被注册为一个“全局”的错误页面。对于机器客户端，它会生成一个 JSON 响应，其中包含错误、HTTP 状态和异常消息的详细信息。对于浏览器客户端，有一个“白标签”错误视图以 HTML 格式呈现相同的数据（要自定义它，请添加一个解析错误的视图）。

​	要替代默认的异常报错白页，可以在 `/src/main/resources/templates` 目录下创建一个 error.html 的错误页，代码如下所示：

```html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>鸭鸭社区</title>
    <meta http-equiv="content-type" content="text/html" charset="UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/community.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>
<div th:insert="navigation :: navigation"></div>

<div class="container-fluid">
    <div class="jumbotron">
        <h1>出错啦！！！</h1>
        <p>服务太热啦，要不然稍等下再来试试~</p>
        <p><a class="btn btn-primary btn-lg" href="/" role="button">回到主页</a></p>
    </div>
</div>
</body>
</html>
```

​	启动应用，访问 `http://localhost:8080/question/301`，不存在ID为301的问题，所以访问该页面应该跳到错误白页，因为我们自定义了错误页，所以会访问 error.html，效果如下：

<img src="screenshots/替换报错白页.png"/>

​	但是页面上只是显示固定的报错信息，我们希望有个组件可以拦截异常报错，并且把异常信息渲染展现到页面上。

