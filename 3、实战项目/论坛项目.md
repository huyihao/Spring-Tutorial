# 1、创建 SpringBoot 项目

## （1）快捷创建项目

​	这里我使用的是IDEA 付费版本【IntelliJ IDEA 2023.1.2 (Ultimate Edition)】，学习该花的钱不要省（嘿嘿，当然某宝也有物美价廉的方案），已经安装好了齐全的 Spring 插件（File -> Settings -> Plugins），这里创建项目用到了 Spring Initializr。

<img src="screenshots\1-IDEA-SpringPlugins.png" style="zoom:80%;"/>

​	File -> New -> New Project，选择 Spring Initializr 来初始化项目，注意一些关键信息要填好。

<img src="screenshots\2-Init-SpringBoot.png" style="zoom:80%;"/>

​	进入下一步，选择 Spring Boot 版本，添加项目用到的 SpringBoot Starter，先选 web，后面用到其他的可以手动添加。

<img src="screenshots\3-Add-SpringBootStarter.png" style="zoom:80%;"/>





## （2）工程目录文件简介

<img src="screenshots\4-ProjectDetails.png" style="zoom:80%;"/>

* **pom.xml**

  ​	Maven 项目依赖管理文件，默认生成的 pom.xml 会以 spring-boot-starter-parent 为父工程，将使用的版本修改为 2.1.4.RELEASE（跟教学视频保持一致），这样下面引用各种 SpringBoot Starter 时就不需要显式指定依赖版本，因为父工程已经指定好了版本，如下所示：

<img src="screenshots\5-SpringBootPom.png" style="zoom:80%;"/>

​	可以看到创建工程时勾选的 web starter，除此之外，还自动引入了 test starter，用于编写对 Spring Boot 的测试代码；在构建插件中，还自动引入了 spring-boot-maven-plugin，用于对工程进行构建打包。

* **.gitignore**

  ​	定义工程中忽略的文件和目录，这些文件和目录在提交代码入库时不会会被忽略，比如 IDE 自动生成的文件和目录，生成编译代码的文件和目录等。

* **HELP.md**

  ​	在 github 上进入一个项目时会有一个简介，github 会自动加载仓库根目录的 README.md 文档并渲染到网页上，这里先把 HELP.md 重命名为 README.md，然后在文档中添加对项目的介绍，包括功能、安装和使用步骤等。

* **src/main/java**

  ​	存放 java 代码的目录，这里已经按照初始化时指定的配置生成了一个代码包 `life.majiang.community`，并且自动创建了工程主类 `CommunityApplication.java`，启动它即可将工程跑起来。

  ​	一般情况下，我们会在 `life.majiang.community` 下创建新的包，比如 `life.majiang.community.controller`、`life.majiang.community.service` 等，因为工程启动时默认会扫描主类包及其子包中所有使用了 Spring 注解定义的 Bean（常用的注解有 `@Controller`、`@Component`、`@Service`等），当然也可以不这样做，比如定义一个新的包 `life.majiang.controller` ，这样要对包扫描时，需要在主类中显式指定要扫描的包。

* **src/main/resources**

  ​	存放工程的资源文件，默认有 static、templates 两个子目录，还有一个 application.properties 文件。

  ​	static 用来存放网站需要的静态文件，比如图片、css样式文件、javascript脚本文件等，一般会在 static 下再建不同的子目录区分，比如 static/images、static/css、static/js。

  ​	templates 用来存放网站需要的模板文件，当然流行的前后端分离一般已经不再使用模板，这里我们使用的引擎是 thymeleaf，后面还要引入相关的依赖。

  ​	application.properties 文件用来配置 Spring Boot 支持的各种参数，比如 web 服务对外暴露端口的参数为 `server.port`，默认值为 8080，如果要修改为 8081，在配置文件中编写如下一行键值对配置即可：

```properties
server.port=8081
```

* **src/main/test**

  ​	存放工程的测试代码，在严格执行单元测试的开发管理中，一个类要有一个对应的 Test 测试类，测试类所处包跟类相同。





## （3）运行工程

​	启动主类，可以看到日志中显示 SpringBoot 工程中嵌入了 Tomcat 服务器，默认启动的端口是 8080。

<img src="screenshots\6-SpringBootStart.png" style="zoom:100%;"/>

​	访问下 http://localhost:8080，可以看到显示的是默认的报错白页，因为此时我们还没编写任何的处理响应的控制器，Spring 找不到处理响应的程序，就只能返回一个 404 的报错。

<img src="screenshots\7-SpringBootStart.png" style="zoom:100%;"/>





# 2、集成 thymeleaf 

​	在 https://spring.io/guides 中找到快捷接入指引：https://spring.io/guides/gs/serving-web-content/

​	首先要引入 thymeleaf 模板引擎对应的 starter，在工程 pom.xml 中添加：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```

​	在启动类所在包下创建一个子包 `life.majiang.community.controller`，并创建一个 HelloController，负责响应 Web 请求，代码如下：

```java
package life.majiang.community.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
public class HelloController {

    @GetMapping("/hello")
    public String hello(@RequestParam(name = "name") String name, Model model) {
        model.addAttribute("name", name);
        return "hello";
    }

}
```

​	首先控制器要使用 `@Controller` 注解，在控制器中创建一个 `hello` 方法，使用 `@GetMapping("/hello")` 表示该方法会响应对 "/hello" 的 GET 请求。

​	请求可能通过 URL 传递参数进来，比如 "/hello?name=hyh"，为了获取参数，在方法头添加 `@RequestParam(name = "name") String name`，表示会从 URL 中获取参数名为 name 的参数并传递给方法入参。

​	我们可能还需要将后端处理好的数据传递给前端，所以给方法添加一个 Model 参数，往 model 对象中添加属性，这些属性能随着响应传递到前端页面模板。

​	最后返回一个 `"hello"` 字符串，因为我们使用了 thymeleaf 模板引擎，所以会自动从资源模板目录 `src/main/resources/templete` 中找到 hello.html，IDEA 会自动提示找不到这个 MVC 视图

<img src="screenshots\9-mvc-view.png" style="zoom:100%;"/>

​	所以接下来到模板目录中创建 hello.html，代码如下：

```html
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Getting Started: Serving Web Content</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>
<body>
    <p th:text="'Hello, ' + ${name} + '!'" />
</body>
</html>
```

​	首先要引入模板引擎的 namespace，告诉 Spring 页面中的 `th` 要使用 Thymeleaf 引擎解析处理，`th:text="'Hello, ' + ${name} + '!'"` 表示要拼接一个字符串渲染到 `<p> ` 标签中，拼接的字符串中 `${name}` 来自后端控制器方法中通过 model 传递给模板处理的属性。

​	访问 `http://localhost:8080/hello?name=hyh` ，响应还是白页

<img src="screenshots\11-没开启自动导入导致的报错.png" style="zoom:100%;"/>

​	看看服务端有什么报错

<img src="screenshots\12-视图解析异常.png" style="zoom:100%;"/>

 	可以看到解析 `hello` 的视图失败，看一下是不是新增的依赖没有自动导入的问题

<img src="screenshots\13-未自动导入maven包.png" style="zoom:80%;"/>

​	可以看到没有我们新引入的 thymeleaf 的依赖，点击左上角的 "Reload All Maven Projects"，才看到依赖真正导入了

<img src="screenshots\14-thmeleaf.png" style="zoom:70%;"/>

​	重启应用再访问，可以看到正常的响应了。

<img src="screenshots\10-hello.png" style="zoom:100%;"/>

​	为了避免在引入新依赖时再次遇到该问题，需要设置 maven 的 auto import，步骤如下

<img src="screenshots\15-maven-autoimport.png" style="zoom:60%;"/>

<img src="screenshots\16-maven-autoimport.png" style="zoom:60%;"/>





# 3、引入 Bootstrap

【Bootstrap】https://v3.bootcss.com/

【样式】https://v3.bootcss.com/css/

【组件】https://v3.bootcss.com/components/

​	下载压缩包

<img src="screenshots\17-bootstrap.png" style="zoom:60%;"/>

​	将压缩包内的 css、fonts、js 目录拷贝到工程的静态资源目录下

<img src="screenshots\18-bootstrap.png" style="zoom:60%;"/>

​	因为这里引用的 Bootstrap V3 是依赖 JQuery 的，所以在 js 目录下还要有 jquery.js，并且在 html 中引入 js 的顺序要先于 bootstrap.js

<img src="screenshots\19-bootstrap.png" style="zoom:100%;"/>





# 4、创建导航栏

​	我们使用 Bootstrap 自带的组件实现一个网站导航栏，从组件库中将默认的导航条样式引入，再在其基础上修改，调整为想要的功能和菜单。

<img src="screenshots\20-bootstrap.png" style="zoom:100%;"/>

​	调整后的新增 index.html 如下：

```html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>鸭鸭社区</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>
    <nav class="navbar navbar-default">
        <div class="container-fluid">

            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                    <span class="sr-only">鸭鸭社区</span>
                </button>
                <a class="navbar-brand" href="/">鸭鸭社区</a>
            </div>

            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <form class="navbar-form navbar-left">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="搜索问题">
                    </div>
                    <button type="submit" class="btn btn-default">搜索</button>
                </form>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="#">登录</a></li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">我 <span class="caret"></span></a>
                        <ul class="dropdown-menu">
                            <li><a href="#">消息中心</a></li>
                            <li><a href="#">个鸭资料</a></li>
                            <li><a href="#">退出登录</a></li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </nav>
</body>
</html>
```

​	新增控制器 IndexController，增加对 `/` 请求的处理，并最后渲染视图 index。

```java
package life.majiang.community.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class IndexController {
    @GetMapping("/")
    public String index() {
        return "index";
    }
}
```

​	完成开发后启动应用，网页访问 `http://localhost:8080/` ，效果如下所示：

<img src="screenshots\21-bootstrap.png" style="zoom:100%;"/>





# 5、Github OAuth 登录开发

​	先找文档在哪里，一般有提供 API 的网站，都能在网站上找到对应的入口

<img src="screenshots\22-github.png" style="zoom:100%;"/>

​	进入可以看到开发者选项，REST API

<img src="screenshots\23-github.png" style="zoom:100%;"/>

<img src="screenshots\24-github.png" style="zoom:60%;"/>

## （1）创建 OAuth 应用

​	登录上 Github，在页面的右上方，单击个人资料照片，然后点击 "Settings"

<img src="screenshots\26-github.png" style="zoom:60%;"/>

​	在左边栏中，点击 Developer settings

<img src="screenshots\27-github.png" style="zoom:100%;"/>

​	点击右侧边栏的 OAuth Apps

<img src="screenshots\28-github.png" style="zoom:60%;"/>

​	点击 "New OAuth App"，填写应用信息：

1、在“Application name（应用程序名称）”中，输入应用程序的名称；

2、在“Homepage URL（主页 URL）”中，输入应用程序网站的完整 URL；

3、（可选）在“Application description（应用程序说明）”中，输入用户将看到的应用程序说明；

4、在“Authorization callback URL（授权回调 URL）”中，输入应用程序的回调 URL。

​	然后点击 "Register application"

<img src="screenshots\29-github.png" style="zoom:100%;"/>

​	创建应用的时候，会自动生成一个客户端ID，这个是不变的，还需要自行点击生成一个客户端密钥，这个是可以重新生成的

<img src="screenshots\30-github.png" style="zoom:100%;"/>

​	点击 "Update application"，至此完成应用创建

<img src="screenshots\31-github.png" style="zoom:65%;"/>







## （3）实战

​	首先要获得授权码，在首页登录按钮配置调整获得授权码的 URL，如下所示：

```html
...
<ul class="nav navbar-nav navbar-right">
   <li><a href="https://github.com/login/oauth/authorize?client_id=ce46b85af14a2d21447b&redirect_uri=http://localhost:8080/callback&scope=user&state=2">登录</a></li>
    
...
```

​	启动应用，访问首页点击登录，看下效果：

<img src="screenshots\32-gitoauth.png" style="zoom:65%;"/>

​	会从当前页面自动跳转到 github 的授权登录页，点击授权，会回调到设定的回调地址，并且回调的同时，返回授权码 code 和跨域用到的 state 字段。

<img src="screenshots\33-gitoauth.png" style="zoom:65%;"/>

​	但是由于暂时没开发响应授权回调的控制器程序，所以会报白页错误。

​	接下来要编写响应回调的程序，首先要编写专门负责向 Github OAuth 接口发起请求的程序，为方便发送和接收数据，先定义两个 DTO 类。

```java
package life.majiang.community.provider.dto;

import lombok.Data;

@Data
public class AccessTokenDTO {
    private String client_id;
    private String client_secret;
    private String code;
    private String redirect_uri;
    private String state;
}

package life.majiang.community.provider.dto;

import lombok.Data;

@Data
public class GithubUser {
    private Long id;
    private String name;
    private String bio;
    private String avatar_url;
}
```

​	`AccessTokenDTO` 类在请求 OAuth 接口获得 accessToken 时用到；`GithubUser` 类对应获取授权 Github 用户数据时用到。

​	发起 HTTP 请求用的是 OK HTTP，同时用到了 fastjson 来处理对象和 JSON 字符串的转换，lombok 方便类编写，先引入依赖：

```xml
<dependency>
	<groupId>com.squareup.okhttp3</groupId>
	<artifactId>okhttp</artifactId>
	<version>3.14.1</version>
</dependency>
<dependency>
	<groupId>com.alibaba</groupId>
	<artifactId>fastjson</artifactId>
	<version>1.2.57</version>
</dependency>
<dependency>
	<groupId>org.projectlombok</groupId>
	<artifactId>lombok</artifactId>
	<scope>provided</scope>
</dependency>
```

​	负责请求的组件类 GithubProvider 定义如下：

```java
package life.majiang.community.provider;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.PropertyNamingStrategy;
import com.alibaba.fastjson.parser.ParserConfig;
import life.majiang.community.provider.dto.AccessTokenDTO;
import life.majiang.community.provider.dto.GithubUser;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;
import org.springframework.stereotype.Component;
import java.io.IOException;

@Component
@Slf4j
public class GithubProvider {

    // 获取accessToken
    public String getAccessToken(AccessTokenDTO accessTokenDTO) {
        MediaType mediumType = MediaType.get("application/json; charset=utf-8");

        OkHttpClient client = new OkHttpClient();
        RequestBody body = RequestBody.create(mediumType, JSON.toJSONString(accessTokenDTO));
        Request request = new Request.Builder()
                .url("https://github.com/login/oauth/access_token")
                .post(body)
                .build();
        try (Response response = client.newCall(request).execute()) {
            String string = response.body().string();
            log.info("Get access token response: " + string);
            String token = string.split("&")[0].split("=")[1];
            return token;
        } catch (IOException e) {
            log.error("Get access token exception: {}", e);
        }
        return null;
    }

    // 获取用户信息
    public GithubUser getGithubUser(String accessToken) {
        OkHttpClient client = new OkHttpClient();
        Request request = new Request.Builder()
                                     .url("https://api.github.com/user")
                                     .addHeader("Authorization", "Bearer " + accessToken)
                                     .build();
        try (Response response = client.newCall(request).execute()) {
            String string = response.body().string();
            log.info("Get github user response: " + string);
            ParserConfig.getGlobalInstance().propertyNamingStrategy = PropertyNamingStrategy.SnakeCase;
            GithubUser githubUser = JSON.parseObject(string, GithubUser.class);
            return githubUser;
        } catch (IOException e) {
            log.error("Get github user exception: {}", e);
        }
        return null;
    }

}
```

​	创建授权控制器 `AuthorizeController` ，接收 Github 的回调后，先获得 accessToken，再用 accessToken 去获取用户信息。

​	在控制器中，要用到 OAuth App 的客户端ID和密钥，已经回调地址，将其放在配置文件 application.properties 中避免硬编码。

```properties
...
# Github OAuth
github.client.id=xxxxxxxxxxxxxx
github.client.secret=xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
github.redirect.uri=http://localhost:8080/callback
...
```

```java
package life.majiang.community.controller;

import life.majiang.community.provider.GithubProvider;
import life.majiang.community.provider.dto.AccessTokenDTO;
import life.majiang.community.provider.dto.GithubUser;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
@Slf4j
public class AuthorizeController {

    @Value("${github.client.id}")
    private String clientId;

    @Value("${github.client.secret}")
    private String clientSecret;

    @Value("${github.redirect.uri}")
    private String redirectUrl;

    @Autowired
    private GithubProvider githubProvider;

    @GetMapping("/callback")
    public String callback(@RequestParam(name = "code") String code,
                           @RequestParam(name = "state") String state) {
        AccessTokenDTO accessTokenDTO = new AccessTokenDTO();
        accessTokenDTO.setClientId(clientId);
        accessTokenDTO.setClientSecret(clientSecret);
        accessTokenDTO.setCode(code);
        accessTokenDTO.setState(state);
        accessTokenDTO.setRedirectUri(redirectUrl);
        log.info("AccessTokenDTO = " + accessTokenDTO);

        String accessToken = githubProvider.getAccessToken(accessTokenDTO);
        GithubUser githubUser = null;
        if (accessToken != null) {
            githubUser = githubProvider.getGithubUser(accessToken);
        }

        if (githubUser != null && githubUser.getId() != null) {
            log.info("Github OAuth succ");
            return "redirect:/";
        } else {
            // 登录失败，重新登录
            return "redirect:/";
        }
    }

}
```

​	启动应用，在首页上点击登录页面，可以看到打印出来的日志，登录成功了，获取到了用户信息。

<img src="screenshots\34-gitoauth.png" style="zoom:100%;"/>

 



# 6、登录会话

​	先说说 cookie 和 session，cookie 是浏览器端会保存的一小块数据缓存，每次用户从浏览器发起新的请求时，会将 cookie 中的数据全部一并发送到服务端，在服务端，通过 `HttpServletRequest` 对象获取请求头部可以拿到 cookie 信息。

​	session 是会话的意思，用户每次登录后，在网站内浏览任意一个页面都应该能够保持登录状态。所以用户每次登录后，要生成一个用户的会话信息ID，并且在登录成功后响应时将其设置到浏览器的 cookie 中，这样后续每次用户访问，服务端都能根据ID拿到用户的会话信息，进而可以判断是哪个用户及其相关登录信息。

​	所以在 Github OAuth 登录成功后，应该设置用户 session，修改授权控制器代码：

```java
    @GetMapping("/callback")
    public String callback(@RequestParam(name = "code") String code,
                           @RequestParam(name = "state") String state,
                           HttpServletRequest request) {
...
        if (githubUser != null && githubUser.getId() != null) {
            log.info("Github OAuth succ");
            // 设置用户登录会话
            request.getSession().setAttribute("user", githubUser);
            return "redirect:/";
        } else {
            // 登录失败，重新登录
            return "redirect:/";
        }
...
    }
```

​	同时页面模板要配合修改，当用户已经登录时，就不应该显示【登录】按钮，同时要显示拿到的 Github 用户名。

```html
<li th:if="${session.user == null}"><a href="https://github.com/login/oauth/authorize?client_id=ce46b85af14a2d21447b&redirect_uri=http://localhost:8080/callback&scope=user&state=2">登录</a></li>
<li th:if="${session.user != null}" class="dropdown">
	<a th:text="${session.user.name}" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">我 <span class="caret"></span></a>
	<ul class="dropdown-menu">
		<li><a href="#">消息中心</a></li>
		<li><a href="#">个鸭资料</a></li>
		<li><a href="#">退出登录</a></li>
	</ul>
</li>
```

​	重启应用，测试效果。

<img src="screenshots\35-gitoauth.png" style="zoom:100%;"/>

​	后面每次刷新页面，都会显示用户名，屏蔽登录按钮。





# 7、集成 H2 

​	H2 是一个用 Java 开发的嵌入式数据库管理系统，在本地开发中，可以使用 H2 作为数据库，方便本地开发测试。

在 IDEA 上使用 Database 组件，创建 H2 数据源

<img src="screenshots\36-h2.png" style="zoom:60%;"/>

<img src="screenshots\37-h2.png" style="zoom:60%;"/>

测试连接是否可用

<img src="screenshots\38-h2.png" style="zoom:60%;"/>

<img src="screenshots\39-h2.png" style="zoom:60%;"/>

创建数据表

<img src="screenshots\40-h2.png" style="zoom:70%;"/>

```sql
create table c_user
(
    id           long auto_increment primary key,
    account_id   varchar(100),
    name         varchar(50),
    token        char(36),
    gmt_create   bigint,
    gmt_modified bigint
);

comment on table c_user is '用户信息表';
comment on column c_user.id is '用户id';
comment on column c_user.account_id is 'github账号ID';
comment on column c_user.name is '用户名';
comment on column c_user.token is '登录token';
comment on column c_user.gmt_create is '创建时间';
comment on column c_user.gmt_modified is '修改时间';
```

<img src="screenshots\43-h2.png" style="zoom:70%;"/>

​	使用 H2 数据库，需要先引入依赖：

```xml
<!-- H2 DB(必须和IDEA Database插件中创建的H2数据库驱动版本一致，否则会报错) -->
<dependency>
	<groupId>com.h2database</groupId>
	<artifactId>h2</artifactId>
	<version>2.1.210</version>
	<scope>runtime</scope>
</dependency>
```

​	使用 H2 作为数据源，需要在 application.properties 中配置数据源：

```properties
# DataSource
spring.datasource.url=jdbc:h2:~/community
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=org.h2.Driver
```





# 8、集成 Mybatis 记录登录用户

​	首先引入依赖：

```xml
<dependency>
	<groupId>org.mybatis.spring.boot</groupId>
	<artifactId>mybatis-spring-boot-starter</artifactId>
	<version>2.0.1</version>
</dependency>
```

​	定义用户对象

```java
package life.majiang.community.model;

import lombok.Data;

@Data
public class User {

    private long id;
    private String accountId;
    private String name;
    private String token;
    private long gmtCreate;
    private long gmtModified;

}
```

​	定义 Mapper 接口

```java
package life.majiang.community.mapper;

import life.majiang.community.model.User;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface UserMapper {

    @Insert("insert into c_user (account_id, name, token, gmt_create, gmt_modified) values (#{accountId}, #{name}, #{token}, #{gmtCreate}, #{gmtModified})")
    public void insert(User user);

}
```

​	修改授权控制器 `AuthorizeController` ，新增获取 Github 用户数据成功后插入到数据库中

```java
@Controller
@Slf4j
public class AuthorizeController {
	...
    @Autowired
    private UserMapper userMapper;	
	...
	
	@GetMapping("/callback")
    public String callback(@RequestParam(name = "code") String code,
                           @RequestParam(name = "state") String state,
                           HttpServletRequest request) {
        if (githubUser != null && githubUser.getId() != null) {
            log.info("Github OAuth succ");
            User user = new User();
            user.setAccountId(String.valueOf(githubUser.getId()));
            user.setName(githubUser.getName());
            user.setToken(UUID.randomUUID().toString());
            user.setGmtCreate(System.currentTimeMillis());
            user.setGmtModified(user.getGmtCreate());
            userMapper.insert(user);

            // 设置用户登录会话
            request.getSession().setAttribute("user", user);
            response.addCookie(new Cookie("token", user.getToken()));          
          
            return "redirect:/";
        } else {
            // 登录失败，重新登录
            log.info("Github OAuth fail");
            return "redirect:/";
        }                           
	}
}
```

​	启动应用进入首页登录，发现点击登录后回显用户名信息了，并且在数据库中插入了一条新的记录

<img src="screenshots\44-h2.png" style="zoom:70%;"/>

​	但是如果关闭应用程序，再重启，由于 session 数据是保存在服务端内存中的数据，所以应用重启后，之前的 session 数据就被清空了，所以重启再打开首页默认还是未登录状态。

​	**优化思路是**，在每次访问首页时，后端尝试从 cookie 中拿到上次登录的 token，再用 token 去查询数据库的用户数据，查到再放到 session 中，这样渲染页面时，就能保持上次的登录状态。

​	首先要在 `UserMapper` 里添加根据 token 查询用户信息的方法：

```java
@Mapper
public interface UserMapper {

	...

    @Select("select * from c_user where token = #{token}")
    public User getByToken(@Param("token") String token);
}
```

​	在访问首页的控制器`IndexController`，修改代码如下：

```java
package life.majiang.community.controller;

import life.majiang.community.mapper.UserMapper;
import life.majiang.community.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;

@Controller
public class IndexController {

    @Autowired
    private UserMapper userMapper;

    @GetMapping("/")
    public String index(HttpServletRequest request) {
        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if ("token".equals(cookie.getName())) {
                    String token = cookie.getValue();
                    User user = userMapper.getByToken(token);
                    if (user != null) {
                        request.getSession().setAttribute("user", user);
                    }
                    break;
                }
            }
        }

        return "index";
    }

}
```

​	一般 cookie 需要设有效期，防止非用户本人访问自动保持登录会话，修改授权控制器 `AuthorizeController` ，代码如下：

```java
@Controller
@Slf4j
public class AuthorizeController {

  	...

    @GetMapping("/callback")
    public String callback(@RequestParam(name = "code") String code,
                           @RequestParam(name = "state") String state,
                           HttpServletRequest request,
                           HttpServletResponse response) {
	    ...

        if (githubUser != null && githubUser.getId() != null) {
            log.info("Github OAuth succ");

		   ...

            // 设置用户登录会话
            //request.getSession().setAttribute("user", user);
            Cookie cookie = new Cookie("token", user.getToken());
            cookie.setPath("/");
            cookie.setMaxAge(3600);
            response.addCookie(cookie);

            return "redirect:/";
        } else {
            // 登录失败，重新登录
            log.info("Github OAuth fail");
            return "redirect:/";
        }
    }

}
```

​	启动应用，点击登录测试

<img src="screenshots\45-h2.png" style="zoom:70%;"/>

​	可以看到浏览器 cookie 中有了 token 的数据，并且设置了有效期。

​	停止应用程序，查看数据库，有了一条新的数据，并且 token 跟浏览器中看到的一致

<img src="screenshots\46-h2.png" style="zoom:100%;"/>

​	重新启动应用，测试是否自动保持登录状态，结果正常登录，再次访问数据库并未发现新增的记录，说明根据 cookie 中的 token 查询数据库并且设置用户会话的处理生效了。

​	与此同时，发现一个新的问题，设置的 token cookie 的有效时间时区不对，跟当前差了 8 个小时，在 application.properties 中设置：

```properties
spring.jackson.time-zone=Asia/Shanghai
```





# 9、集成 Flyway Migration

## （1）简介

​	flyway 是一款让数据库迁移变得简单的工具，下面简单介绍其工作原理，最简单的情况是用 Flyway 将数据库结构迁移到一个空数据库。

<img src="screenshots\47-flyway.png" style="zoom:100%;"/>



​	flyway 自带一个 schema 历史迁移表。若找不到该表，则会先创建该表。

​	执行了之后，数据库中会出现一张空表  *flyway_schema_history*  

<img src="screenshots\48-flyway.png" style="zoom:100%;"/>

​	该表用于跟踪数据库的状态

​	紧接着 Flyway 会开始扫描文件系统或应用的类路径来找到迁移文件，这些文件可能是 Sql 也可能是 Java 文件。

​	迁移的执行顺序会按照文件的版本号进行：

<img src="screenshots\49-flyway.png" style="zoom:100%;"/>

​	应用每次迁移时，架构历史表都会相应更新：

<img src="screenshots\50-flyway.png" style="zoom:100%;"/>

​	元数据和初始状态就位后，我们现在可以讨论迁移到新版本。

​	Flyway 会再次扫描文件系统或应用的类路径，根据架构历史表检查迁移，如果它们的版本号低于或等于标记为当前的版本号，则它们将被忽略。

​	剩余的迁移是待处理的迁移：可用，但未应用。

<img src="screenshots\51-flyway.png" style="zoom:100%;"/>

​	然后它们按版本号排序并按顺序执行：

<img src="screenshots\52-flyway.png" style="zoom:100%;"/>

​	架构历史表会相应更新：

<img src="screenshots\53-flyway.png" style="zoom:100%;"/>

​	每次需要改进数据库时，无论是结构（DDL）还是参考数据（DML），只需创建一个版本号高于当前版本号的新迁移即可。Flyway下次启动时，它会找到它并相应地升级数据库。



## （2）Maven 插件

​	首先在 Maven 工程的 pom.xml 中添加配置：

```xml
<project xmlns="...">
    <build>
        <plugins>
            <plugin>
                <groupId>org.flywaydb</groupId>
                <artifactId>flyway-maven-plugin</artifactId>
                <version>9.17.0</version>
                <configuration>
                    <url>jdbc:h2:~/community</url>
                    <user>root</user>
                    <password>root</password>
                </configuration>
                <dependencies>
                    <!-- 插件的版本要跟Jar包引入保持一致 -->
                    <dependency>
                        <groupId>com.h2database</groupId>
                        <artifactId>h2</artifactId>
                        <version>2.1.210</version>
                    </dependency>
                </dependencies>
            </plugin>
        </plugins>
    </build>
</project>
```

​	迁移文件的目录是 `src/main/resources/db/migration` ，在该目录下创建迁移文件 `V1__Create_user_table.sql` :

```sql
create table c_user
(
    id           long auto_increment primary key,
    account_id   varchar(100),
    name         varchar(50),
    token        char(36),
    gmt_create   bigint,
    gmt_modified bigint
);

comment on table c_user is '用户信息表';
comment on column c_user.id is '用户id';
comment on column c_user.account_id is 'github账号ID';
comment on column c_user.name is '用户名';
comment on column c_user.token is '登录token';
comment on column c_user.gmt_create is '创建时间';
comment on column c_user.gmt_modified is '修改时间';
```

​	在工程目录下执行 `mvn flyway:migrate` 

<img src="screenshots\54-flyway.png" style="zoom:100%;"/>

​	原来的用户表被删了再重建，数据被清空，同时还多了一张迁移表

<img src="screenshots\55-flyway.png" style="zoom:100%;"/>

​	迁移表记录了执行迁移的记录，包括文件、版本等信息

<img src="screenshots\56-flyway.png" style="zoom:100%;"/>



```sql
-- auto-generated definition
create table QUESTION
(
    ID            INTEGER auto_increment
        primary key,
    TITLE         CHARACTER VARYING(50),
    DESCRIPTION   CHARACTER LARGE OBJECT,
    GMT_CREATE    BIGINT,
    GMT_MODIFIED  BIGINT,
    CREATOR       INTEGER,
    COMMENT_COUNT INTEGER default 0,
    VIEW_COUNT    INTEGER default 0,
    LIKE_COUNT    INTEGER default 0,
    TAG           CHARACTER VARYING(256)
);

comment on column QUESTION.TITLE is '问题标题';
comment on column QUESTION.GMT_CREATE is '创建时间';
comment on column QUESTION.GMT_MODIFIED is '修改时间';
comment on column QUESTION.CREATOR is '创建者';
comment on column QUESTION.COMMENT_COUNT is '评论数';
comment on column QUESTION.VIEW_COUNT is '阅读数';
comment on column QUESTION.LIKE_COUNT is '点赞数';
comment on column QUESTION.TAG is '标签';
```









# 【附录】

## 1、Spring 功能集成

访问：https://spring.io/guides

在简明教程列表中选择要集成的功能：

<img src="screenshots\8-SpringGuides.png" style="zoom:100%;"/>

* [Spring Boot DataSource](https://docs.spring.io/spring-boot/docs/current/reference/html/data.html)
* [Spring Boot Mybatis](https://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/zh/index.html)





## 2、文档

* [Spring文档](https://spring.io/guides)
* [Spring Web](https://docs.spring.io/spring-framework/docs/5.3.28/reference/html/web.html#spring-web)
* [Thymeleaf 官方文档](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html)
* [Bootstrap](https://v3.bootcss.com/)
* [Github OAuth](https://docs.github.com/zh/apps/oauth-apps/building-oauth-apps)
* [H2](https://www.h2database.com/html/main.html)
* [Flyway](https://documentation.red-gate.com/fd)







## 3、工具






















```json
{
    "login":"huyihao",
    "id":11757351,
    "node_id":"MDQ6VXNlcjExNzU3MzUx",
    "avatar_url":"https://avatars.githubusercontent.com/u/11757351?v=4",
    "gravatar_id":"",
    "url":"https://api.github.com/users/huyihao",
    "html_url":"https://github.com/huyihao",
    "followers_url":"https://api.github.com/users/huyihao/followers",
    "following_url":"https://api.github.com/users/huyihao/following{/other_user}",
    "gists_url":"https://api.github.com/users/huyihao/gists{/gist_id}",
    "starred_url":"https://api.github.com/users/huyihao/starred{/owner}{/repo}",
    "subscriptions_url":"https://api.github.com/users/huyihao/subscriptions",
    "organizations_url":"https://api.github.com/users/huyihao/orgs",
    "repos_url":"https://api.github.com/users/huyihao/repos",
    "events_url":"https://api.github.com/users/huyihao/events{/privacy}",
    "received_events_url":"https://api.github.com/users/huyihao/received_events",
    "type":"User",
    "site_admin":false,
    "name":"codedog",
    "company":null,
    "blog":"",
    "location":null,
    "email":"1123176978@qq.com",
    "hireable":null,
    "bio":"a simple codedog",
    "twitter_username":null,
    "public_repos":18,
    "public_gists":0,
    "followers":0,
    "following":2,
    "created_at":"2015-04-01T16:18:30Z",
    "updated_at":"2023-05-09T13:14:10Z",
    "private_gists":0,
    "total_private_repos":5,
    "owned_private_repos":5,
    "disk_usage":2023496,
    "collaborators":0,
    "two_factor_authentication":false,
    "plan":{
        "name":"free",
        "space":976562499,
        "collaborators":0,
        "private_repos":10000
    }
}
```







# 使用MyBatis Generator

1、引入插件

```xml
<project>
  ...
  <build>
    ...
    <plugins>
      ...
      <plugin>
		<groupId>org.mybatis.generator</groupId>
		<artifactId>mybatis-generator-maven-plugin</artifactId>
		<version>1.3.7</version>
      </plugin>
    </plugins>
  </build>
</project>
```



2、执行maven命令（生成执行 MyBatis 需要的 model 和 mapper 文件）

```shell
# -Dmybatis.generator.overwrite=true 表示生成的文件是否覆盖原文件，不覆盖则生成文件为 MyClass.java.1
mvn mybatis-generator:generate -Dmybatis.generator.overwrite=true
```



3、创建配置文件

【默认路径】src/main/resources/generatorConfig.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
<generatorConfiguration>
    <context id="simple" targetRuntime="MyBatis3">
        <!-- 配置数据库连接，MBG才知道去连接哪个数据库获取表信息 -->
        <jdbcConnection driverClass="org.h2.Driver"
                        connectionURL="jdbc:h2:~/community"
                        userId="root"
                        password="root"/>

        <!-- 配置生成的Java Model类要放在哪个目录哪个包中 -->
        <javaModelGenerator targetPackage="life.majiang.community.model" targetProject="src/main/java"/>

        <!-- 配置生成的mapper.xml存放位置 -->
        <sqlMapGenerator targetPackage="mapper" targetProject="src/main/resources"/>

        <!-- ava 客户端生成器构建 Java 接口和类，以便轻松使用生成的 Java 模型和 XML 映射文件。 -->
        <javaClientGenerator type="XMLMAPPER" targetPackage="life.majiang.community.mapper" targetProject="src/main/java"/>

        <!-- 配置要扫描哪些表生成文件 -->
        <table tableName="cuser" domainObjectName="User"/>
    </context>
</generatorConfiguration>
```





# 1、Spring Error Handler

​	默认情况下，Spring Boot 提供了一个 `/error` 映射，以合理的方式处理所有错误，并且它在 servlet 容器中被注册为一个“全局”的错误页面。对于机器客户端，它会生成一个 JSON 响应，其中包含错误、HTTP 状态和异常消息的详细信息。对于浏览器客户端，有一个“白标签”错误视图以 HTML 格式呈现相同的数据（要自定义它，请添加一个解析错误的视图）。

​	要替代默认的异常报错白页，可以在 `/src/main/resources/templates` 目录下创建一个 error.html 的错误页，代码如下所示：

```html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>鸭鸭社区</title>
    <meta http-equiv="content-type" content="text/html" charset="UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/bootstrap-theme.min.css"/>
    <link rel="stylesheet" type="text/css" href="/css/community.css"/>
    <script type="application/javascript" src="/js/jquery-3.4.1.min.js"></script>
    <script type="application/javascript" src="/js/bootstrap.min.js"></script>
</head>
<body>
<div th:insert="navigation :: navigation"></div>

<div class="container-fluid">
    <div class="jumbotron">
        <h1>出错啦！！！</h1>
        <p>服务太热啦，要不然稍等下再来试试~</p>
        <p><a class="btn btn-primary btn-lg" href="/" role="button">回到主页</a></p>
    </div>
</div>
</body>
</html>
```

​	启动应用，访问 `http://localhost:8080/question/301`，不存在ID为301的问题，所以访问该页面应该跳到错误白页，因为我们自定义了错误页，所以会访问 error.html，效果如下：

<img src="screenshots/替换报错白页.png"/>

​	但是页面上只是显示固定的报错信息，我们希望有个组件可以拦截异常报错，并且把异常信息渲染展现到页面上。

